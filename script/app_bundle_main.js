(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pryvApp = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,setImmediate){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
          return a.priority - b.priority;
        };

        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }

        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };

              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":23,"timers":103}],2:[function(require,module,exports){
// Backbone.BabySitter
// -------------------
// v0.1.11
//
// Copyright (c)2016 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.babysitter

(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore'], function(Backbone, _) {
      return factory(Backbone, _);
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = require('backbone');
    var _ = require('underscore');
    module.exports = factory(Backbone, _);
  } else {
    factory(root.Backbone, root._);
  }

}(this, function(Backbone, _) {
  'use strict';

  var previousChildViewContainer = Backbone.ChildViewContainer;

  // BabySitter.ChildViewContainer
  // -----------------------------
  //
  // Provide a container to store, retrieve and
  // shut down child views.
  
  Backbone.ChildViewContainer = (function (Backbone, _) {
  
    // Container Constructor
    // ---------------------
  
    var Container = function(views){
      this._views = {};
      this._indexByModel = {};
      this._indexByCustom = {};
      this._updateLength();
  
      _.each(views, this.add, this);
    };
  
    // Container Methods
    // -----------------
  
    _.extend(Container.prototype, {
  
      // Add a view to this container. Stores the view
      // by `cid` and makes it searchable by the model
      // cid (and model itself). Optionally specify
      // a custom key to store an retrieve the view.
      add: function(view, customIndex){
        var viewCid = view.cid;
  
        // store the view
        this._views[viewCid] = view;
  
        // index it by model
        if (view.model){
          this._indexByModel[view.model.cid] = viewCid;
        }
  
        // index by custom
        if (customIndex){
          this._indexByCustom[customIndex] = viewCid;
        }
  
        this._updateLength();
        return this;
      },
  
      // Find a view by the model that was attached to
      // it. Uses the model's `cid` to find it.
      findByModel: function(model){
        return this.findByModelCid(model.cid);
      },
  
      // Find a view by the `cid` of the model that was attached to
      // it. Uses the model's `cid` to find the view `cid` and
      // retrieve the view using it.
      findByModelCid: function(modelCid){
        var viewCid = this._indexByModel[modelCid];
        return this.findByCid(viewCid);
      },
  
      // Find a view by a custom indexer.
      findByCustom: function(index){
        var viewCid = this._indexByCustom[index];
        return this.findByCid(viewCid);
      },
  
      // Find by index. This is not guaranteed to be a
      // stable index.
      findByIndex: function(index){
        return _.values(this._views)[index];
      },
  
      // retrieve a view by its `cid` directly
      findByCid: function(cid){
        return this._views[cid];
      },
  
      // Remove a view
      remove: function(view){
        var viewCid = view.cid;
  
        // delete model index
        if (view.model){
          delete this._indexByModel[view.model.cid];
        }
  
        // delete custom index
        _.any(this._indexByCustom, function(cid, key) {
          if (cid === viewCid) {
            delete this._indexByCustom[key];
            return true;
          }
        }, this);
  
        // remove the view from the container
        delete this._views[viewCid];
  
        // update the length
        this._updateLength();
        return this;
      },
  
      // Call a method on every view in the container,
      // passing parameters to the call method one at a
      // time, like `function.call`.
      call: function(method){
        this.apply(method, _.tail(arguments));
      },
  
      // Apply a method on every view in the container,
      // passing parameters to the call method one at a
      // time, like `function.apply`.
      apply: function(method, args){
        _.each(this._views, function(view){
          if (_.isFunction(view[method])){
            view[method].apply(view, args || []);
          }
        });
      },
  
      // Update the `.length` attribute on this container
      _updateLength: function(){
        this.length = _.size(this._views);
      }
    });
  
    // Borrowing this code from Backbone.Collection:
    // http://backbonejs.org/docs/backbone.html#section-106
    //
    // Mix in methods from Underscore, for iteration, and other
    // collection related features.
    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
      'last', 'without', 'isEmpty', 'pluck', 'reduce'];
  
    _.each(methods, function(method) {
      Container.prototype[method] = function() {
        var views = _.values(this._views);
        var args = [views].concat(_.toArray(arguments));
        return _[method].apply(_, args);
      };
    });
  
    // return the public API
    return Container;
  })(Backbone, _);
  

  Backbone.ChildViewContainer.VERSION = '0.1.11';

  Backbone.ChildViewContainer.noConflict = function () {
    Backbone.ChildViewContainer = previousChildViewContainer;
    return this;
  };

  return Backbone.ChildViewContainer;

}));

},{"backbone":5,"underscore":104}],3:[function(require,module,exports){
// MarionetteJS (Backbone.Marionette)
// ----------------------------------
// v1.8.8
//
// Copyright (c)2014 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://marionettejs.com

(function (root, factory) {
  if (typeof exports === 'object') {

    var underscore = require('underscore');
    var backbone = require('backbone');
    var wreqr = require('backbone.wreqr');
    var babysitter = require('backbone.babysitter');

    module.exports = factory(underscore, backbone, wreqr, babysitter);

  } else if (typeof define === 'function' && define.amd) {

    define(['underscore', 'backbone', 'backbone.wreqr', 'backbone.babysitter'], factory);

  }
}(this, function (_, Backbone) {

  var Marionette = (function(global, Backbone, _){
    "use strict";
  
    // Define and export the Marionette namespace
    var Marionette = {};
    Backbone.Marionette = Marionette;
  
    // Get the DOM manipulator for later use
    Marionette.$ = Backbone.$;
  
  // Helpers
  // -------
  
  // For slicing `arguments` in functions
  var slice = Array.prototype.slice;
  
  function throwError(message, name) {
    var error = new Error(message);
    error.name = name || 'Error';
    throw error;
  }
  
  // Marionette.extend
  // -----------------
  
  // Borrow the Backbone `extend` method so we can use it as needed
  Marionette.extend = Backbone.Model.extend;
  
  // Marionette.getOption
  // --------------------
  
  // Retrieve an object, function or other value from a target
  // object or its `options`, with `options` taking precedence.
  Marionette.getOption = function(target, optionName){
    if (!target || !optionName){ return; }
    var value;
  
    if (target.options && (optionName in target.options) && (target.options[optionName] !== undefined)){
      value = target.options[optionName];
    } else {
      value = target[optionName];
    }
  
    return value;
  };
  
  // Marionette.normalizeMethods
  // ----------------------
  
  // Pass in a mapping of events => functions or function names
  // and return a mapping of events => functions
  Marionette.normalizeMethods = function(hash) {
    var normalizedHash = {}, method;
    _.each(hash, function(fn, name) {
      method = fn;
      if (!_.isFunction(method)) {
        method = this[method];
      }
      if (!method) {
        return;
      }
      normalizedHash[name] = method;
    }, this);
    return normalizedHash;
  };
  
  
  // allows for the use of the @ui. syntax within
  // a given key for triggers and events
  // swaps the @ui with the associated selector
  Marionette.normalizeUIKeys = function(hash, ui) {
    if (typeof(hash) === "undefined") {
      return;
    }
  
    _.each(_.keys(hash), function(v) {
      var pattern = /@ui.[a-zA-Z_$0-9]*/g;
      if (v.match(pattern)) {
        hash[v.replace(pattern, function(r) {
          return ui[r.slice(4)];
        })] = hash[v];
        delete hash[v];
      }
    });
  
    return hash;
  };
  
  // Mix in methods from Underscore, for iteration, and other
  // collection related features.
  // Borrowing this code from Backbone.Collection:
  // http://backbonejs.org/docs/backbone.html#section-106
  Marionette.actAsCollection = function(object, listProperty) {
    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
      'last', 'without', 'isEmpty', 'pluck'];
  
    _.each(methods, function(method) {
      object[method] = function() {
        var list = _.values(_.result(this, listProperty));
        var args = [list].concat(_.toArray(arguments));
        return _[method].apply(_, args);
      };
    });
  };
  
  // Trigger an event and/or a corresponding method name. Examples:
  //
  // `this.triggerMethod("foo")` will trigger the "foo" event and
  // call the "onFoo" method.
  //
  // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
  // call the "onFooBar" method.
  Marionette.triggerMethod = (function(){
  
    // split the event name on the ":"
    var splitter = /(^|:)(\w)/gi;
  
    // take the event section ("section1:section2:section3")
    // and turn it in to uppercase name
    function getEventName(match, prefix, eventName) {
      return eventName.toUpperCase();
    }
  
    // actual triggerMethod implementation
    var triggerMethod = function(event) {
      // get the method name from the event name
      var methodName = 'on' + event.replace(splitter, getEventName);
      var method = this[methodName];
  
      // trigger the event, if a trigger method exists
      if(_.isFunction(this.trigger)) {
        this.trigger.apply(this, arguments);
      }
  
      // call the onMethodName if it exists
      if (_.isFunction(method)) {
        // pass all arguments, except the event name
        return method.apply(this, _.tail(arguments));
      }
    };
  
    return triggerMethod;
  })();
  
  // DOMRefresh
  // ----------
  //
  // Monitor a view's state, and after it has been rendered and shown
  // in the DOM, trigger a "dom:refresh" event every time it is
  // re-rendered.
  
  Marionette.MonitorDOMRefresh = (function(documentElement){
    // track when the view has been shown in the DOM,
    // using a Marionette.Region (or by other means of triggering "show")
    function handleShow(view){
      view._isShown = true;
      triggerDOMRefresh(view);
    }
  
    // track when the view has been rendered
    function handleRender(view){
      view._isRendered = true;
      triggerDOMRefresh(view);
    }
  
    // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
    function triggerDOMRefresh(view){
      if (view._isShown && view._isRendered && isInDOM(view)){
        if (_.isFunction(view.triggerMethod)){
          view.triggerMethod("dom:refresh");
        }
      }
    }
  
    function isInDOM(view) {
      return documentElement.contains(view.el);
    }
  
    // Export public API
    return function(view){
      view.listenTo(view, "show", function(){
        handleShow(view);
      });
  
      view.listenTo(view, "render", function(){
        handleRender(view);
      });
    };
  })(document.documentElement);
  
  
  // Marionette.bindEntityEvents & unbindEntityEvents
  // ---------------------------
  //
  // These methods are used to bind/unbind a backbone "entity" (collection/model)
  // to methods on a target object.
  //
  // The first parameter, `target`, must have a `listenTo` method from the
  // EventBinder object.
  //
  // The second parameter is the entity (Backbone.Model or Backbone.Collection)
  // to bind the events from.
  //
  // The third parameter is a hash of { "event:name": "eventHandler" }
  // configuration. Multiple handlers can be separated by a space. A
  // function can be supplied instead of a string handler name.
  
  (function(Marionette){
    "use strict";
  
    // Bind the event to handlers specified as a string of
    // handler names on the target object
    function bindFromStrings(target, entity, evt, methods){
      var methodNames = methods.split(/\s+/);
  
      _.each(methodNames, function(methodName) {
  
        var method = target[methodName];
        if(!method) {
          throwError("Method '"+ methodName +"' was configured as an event handler, but does not exist.");
        }
  
        target.listenTo(entity, evt, method);
      });
    }
  
    // Bind the event to a supplied callback function
    function bindToFunction(target, entity, evt, method){
        target.listenTo(entity, evt, method);
    }
  
    // Bind the event to handlers specified as a string of
    // handler names on the target object
    function unbindFromStrings(target, entity, evt, methods){
      var methodNames = methods.split(/\s+/);
  
      _.each(methodNames, function(methodName) {
        var method = target[methodName];
        target.stopListening(entity, evt, method);
      });
    }
  
    // Bind the event to a supplied callback function
    function unbindToFunction(target, entity, evt, method){
        target.stopListening(entity, evt, method);
    }
  
  
    // generic looping function
    function iterateEvents(target, entity, bindings, functionCallback, stringCallback){
      if (!entity || !bindings) { return; }
  
      // allow the bindings to be a function
      if (_.isFunction(bindings)){
        bindings = bindings.call(target);
      }
  
      // iterate the bindings and bind them
      _.each(bindings, function(methods, evt){
  
        // allow for a function as the handler,
        // or a list of event names as a string
        if (_.isFunction(methods)){
          functionCallback(target, entity, evt, methods);
        } else {
          stringCallback(target, entity, evt, methods);
        }
  
      });
    }
  
    // Export Public API
    Marionette.bindEntityEvents = function(target, entity, bindings){
      iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
    };
  
    Marionette.unbindEntityEvents = function(target, entity, bindings){
      iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
    };
  
  })(Marionette);
  
  
  // Callbacks
  // ---------
  
  // A simple way of managing a collection of callbacks
  // and executing them at a later point in time, using jQuery's
  // `Deferred` object.
  Marionette.Callbacks = function(){
    this._deferred = Marionette.$.Deferred();
    this._callbacks = [];
  };
  
  _.extend(Marionette.Callbacks.prototype, {
  
    // Add a callback to be executed. Callbacks added here are
    // guaranteed to execute, even if they are added after the
    // `run` method is called.
    add: function(callback, contextOverride){
      this._callbacks.push({cb: callback, ctx: contextOverride});
  
      this._deferred.done(function(context, options){
        if (contextOverride){ context = contextOverride; }
        callback.call(context, options);
      });
    },
  
    // Run all registered callbacks with the context specified.
    // Additional callbacks can be added after this has been run
    // and they will still be executed.
    run: function(options, context){
      this._deferred.resolve(context, options);
    },
  
    // Resets the list of callbacks to be run, allowing the same list
    // to be run multiple times - whenever the `run` method is called.
    reset: function(){
      var callbacks = this._callbacks;
      this._deferred = Marionette.$.Deferred();
      this._callbacks = [];
  
      _.each(callbacks, function(cb){
        this.add(cb.cb, cb.ctx);
      }, this);
    }
  });
  
  // Marionette Controller
  // ---------------------
  //
  // A multi-purpose object to use as a controller for
  // modules and routers, and as a mediator for workflow
  // and coordination of other objects, views, and more.
  Marionette.Controller = function(options){
    this.triggerMethod = Marionette.triggerMethod;
    this.options = options || {};
  
    if (_.isFunction(this.initialize)){
      this.initialize(this.options);
    }
  };
  
  Marionette.Controller.extend = Marionette.extend;
  
  // Controller Methods
  // --------------
  
  // Ensure it can trigger events with Backbone.Events
  _.extend(Marionette.Controller.prototype, Backbone.Events, {
    close: function(){
      this.stopListening();
      var args = Array.prototype.slice.call(arguments);
      this.triggerMethod.apply(this, ["close"].concat(args));
      this.off();
    }
  });
  
  // Region
  // ------
  //
  // Manage the visual regions of your composite application. See
  // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/
  
  Marionette.Region = function(options){
    this.options = options || {};
    this.el = Marionette.getOption(this, "el");
  
    if (!this.el){
      throwError("An 'el' must be specified for a region.", "NoElError");
    }
  
    if (this.initialize){
      var args = Array.prototype.slice.apply(arguments);
      this.initialize.apply(this, args);
    }
  };
  
  
  // Region Type methods
  // -------------------
  
  _.extend(Marionette.Region, {
  
    // Build an instance of a region by passing in a configuration object
    // and a default region type to use if none is specified in the config.
    //
    // The config object should either be a string as a jQuery DOM selector,
    // a Region type directly, or an object literal that specifies both
    // a selector and regionType:
    //
    // ```js
    // {
    //   selector: "#foo",
    //   regionType: MyCustomRegion
    // }
    // ```
    //
    buildRegion: function(regionConfig, defaultRegionType){
      var regionIsString = _.isString(regionConfig);
      var regionSelectorIsString = _.isString(regionConfig.selector);
      var regionTypeIsUndefined = _.isUndefined(regionConfig.regionType);
      var regionIsType = _.isFunction(regionConfig);
  
      if (!regionIsType && !regionIsString && !regionSelectorIsString) {
        throwError("Region must be specified as a Region type, a selector string or an object with selector property");
      }
  
      var selector, RegionType;
  
      // get the selector for the region
  
      if (regionIsString) {
        selector = regionConfig;
      }
  
      if (regionConfig.selector) {
        selector = regionConfig.selector;
        delete regionConfig.selector;
      }
  
      // get the type for the region
  
      if (regionIsType){
        RegionType = regionConfig;
      }
  
      if (!regionIsType && regionTypeIsUndefined) {
        RegionType = defaultRegionType;
      }
  
      if (regionConfig.regionType) {
        RegionType = regionConfig.regionType;
        delete regionConfig.regionType;
      }
  
      if (regionIsString || regionIsType) {
        regionConfig = {};
      }
  
      regionConfig.el = selector;
  
      // build the region instance
      var region = new RegionType(regionConfig);
  
      // override the `getEl` function if we have a parentEl
      // this must be overridden to ensure the selector is found
      // on the first use of the region. if we try to assign the
      // region's `el` to `parentEl.find(selector)` in the object
      // literal to build the region, the element will not be
      // guaranteed to be in the DOM already, and will cause problems
      if (regionConfig.parentEl){
        region.getEl = function(selector) {
          var parentEl = regionConfig.parentEl;
          if (_.isFunction(parentEl)){
            parentEl = parentEl();
          }
          return parentEl.find(selector);
        };
      }
  
      return region;
    }
  
  });
  
  // Region Instance Methods
  // -----------------------
  
  _.extend(Marionette.Region.prototype, Backbone.Events, {
  
    // Displays a backbone view instance inside of the region.
    // Handles calling the `render` method for you. Reads content
    // directly from the `el` attribute. Also calls an optional
    // `onShow` and `close` method on your view, just after showing
    // or just before closing the view, respectively.
    // The `preventClose` option can be used to prevent a view from being destroyed on show.
    show: function(view, options){
      this.ensureEl();
  
      var showOptions = options || {};
      var isViewClosed = view.isClosed || _.isUndefined(view.$el);
      var isDifferentView = view !== this.currentView;
      var preventClose =  !!showOptions.preventClose;
  
      // only close the view if we don't want to preventClose and the view is different
      var _shouldCloseView = !preventClose && isDifferentView;
  
      if (_shouldCloseView) {
        this.close();
      }
  
      view.render();
      Marionette.triggerMethod.call(this, "before:show", view);
  
      if (_.isFunction(view.triggerMethod)) {
        view.triggerMethod("before:show");
      } else {
        Marionette.triggerMethod.call(view, "before:show");
      }
  
      if (isDifferentView || isViewClosed) {
        this.open(view);
      }
  
      this.currentView = view;
  
      Marionette.triggerMethod.call(this, "show", view);
  
      if (_.isFunction(view.triggerMethod)) {
        view.triggerMethod("show");
      } else {
        Marionette.triggerMethod.call(view, "show");
      }
  
      return this;
    },
  
    ensureEl: function(){
      if (!this.$el || this.$el.length === 0){
        this.$el = this.getEl(this.el);
      }
    },
  
    // Override this method to change how the region finds the
    // DOM element that it manages. Return a jQuery selector object.
    getEl: function(selector){
      return Marionette.$(selector);
    },
  
    // Override this method to change how the new view is
    // appended to the `$el` that the region is managing
    open: function(view){
      this.$el.empty().append(view.el);
    },
  
    // Close the current view, if there is one. If there is no
    // current view, it does nothing and returns immediately.
    close: function(){
      var view = this.currentView;
      if (!view || view.isClosed){ return; }
  
      // call 'close' or 'remove', depending on which is found
      if (view.close) { view.close(); }
      else if (view.remove) { view.remove(); }
  
      Marionette.triggerMethod.call(this, "close", view);
  
      delete this.currentView;
    },
  
    // Attach an existing view to the region. This
    // will not call `render` or `onShow` for the new view,
    // and will not replace the current HTML for the `el`
    // of the region.
    attachView: function(view){
      this.currentView = view;
    },
  
    // Reset the region by closing any existing view and
    // clearing out the cached `$el`. The next time a view
    // is shown via this region, the region will re-query the
    // DOM for the region's `el`.
    reset: function(){
      this.close();
      delete this.$el;
    }
  });
  
  // Copy the `extend` function used by Backbone's classes
  Marionette.Region.extend = Marionette.extend;
  
  // Marionette.RegionManager
  // ------------------------
  //
  // Manage one or more related `Marionette.Region` objects.
  Marionette.RegionManager = (function(Marionette){
  
    var RegionManager = Marionette.Controller.extend({
      constructor: function(options){
        this._regions = {};
        Marionette.Controller.prototype.constructor.call(this, options);
      },
  
      // Add multiple regions using an object literal, where
      // each key becomes the region name, and each value is
      // the region definition.
      addRegions: function(regionDefinitions, defaults){
        var regions = {};
  
        _.each(regionDefinitions, function(definition, name){
          if (_.isString(definition)){
            definition = { selector: definition };
          }
  
          if (definition.selector){
            definition = _.defaults({}, definition, defaults);
          }
  
          var region = this.addRegion(name, definition);
          regions[name] = region;
        }, this);
  
        return regions;
      },
  
      // Add an individual region to the region manager,
      // and return the region instance
      addRegion: function(name, definition){
        var region;
  
        var isObject = _.isObject(definition);
        var isString = _.isString(definition);
        var hasSelector = !!definition.selector;
  
        if (isString || (isObject && hasSelector)){
          region = Marionette.Region.buildRegion(definition, Marionette.Region);
        } else if (_.isFunction(definition)){
          region = Marionette.Region.buildRegion(definition, Marionette.Region);
        } else {
          region = definition;
        }
  
        this._store(name, region);
        this.triggerMethod("region:add", name, region);
        return region;
      },
  
      // Get a region by name
      get: function(name){
        return this._regions[name];
      },
  
      // Remove a region by name
      removeRegion: function(name){
        var region = this._regions[name];
        this._remove(name, region);
      },
  
      // Close all regions in the region manager, and
      // remove them
      removeRegions: function(){
        _.each(this._regions, function(region, name){
          this._remove(name, region);
        }, this);
      },
  
      // Close all regions in the region manager, but
      // leave them attached
      closeRegions: function(){
        _.each(this._regions, function(region, name){
          region.close();
        }, this);
      },
  
      // Close all regions and shut down the region
      // manager entirely
      close: function(){
        this.removeRegions();
        Marionette.Controller.prototype.close.apply(this, arguments);
      },
  
      // internal method to store regions
      _store: function(name, region){
        this._regions[name] = region;
        this._setLength();
      },
  
      // internal method to remove a region
      _remove: function(name, region){
        region.close();
        region.stopListening();
        delete this._regions[name];
        this._setLength();
        this.triggerMethod("region:remove", name, region);
      },
  
      // set the number of regions current held
      _setLength: function(){
        this.length = _.size(this._regions);
      }
  
    });
  
    Marionette.actAsCollection(RegionManager.prototype, '_regions');
  
    return RegionManager;
  })(Marionette);
  
  
  // Template Cache
  // --------------
  
  // Manage templates stored in `<script>` blocks,
  // caching them for faster access.
  Marionette.TemplateCache = function(templateId){
    this.templateId = templateId;
  };
  
  // TemplateCache object-level methods. Manage the template
  // caches from these method calls instead of creating
  // your own TemplateCache instances
  _.extend(Marionette.TemplateCache, {
    templateCaches: {},
  
    // Get the specified template by id. Either
    // retrieves the cached version, or loads it
    // from the DOM.
    get: function(templateId){
      var cachedTemplate = this.templateCaches[templateId];
  
      if (!cachedTemplate){
        cachedTemplate = new Marionette.TemplateCache(templateId);
        this.templateCaches[templateId] = cachedTemplate;
      }
  
      return cachedTemplate.load();
    },
  
    // Clear templates from the cache. If no arguments
    // are specified, clears all templates:
    // `clear()`
    //
    // If arguments are specified, clears each of the
    // specified templates from the cache:
    // `clear("#t1", "#t2", "...")`
    clear: function(){
      var i;
      var args = slice.call(arguments);
      var length = args.length;
  
      if (length > 0){
        for(i=0; i<length; i++){
          delete this.templateCaches[args[i]];
        }
      } else {
        this.templateCaches = {};
      }
    }
  });
  
  // TemplateCache instance methods, allowing each
  // template cache object to manage its own state
  // and know whether or not it has been loaded
  _.extend(Marionette.TemplateCache.prototype, {
  
    // Internal method to load the template
    load: function(){
      // Guard clause to prevent loading this template more than once
      if (this.compiledTemplate){
        return this.compiledTemplate;
      }
  
      // Load the template and compile it
      var template = this.loadTemplate(this.templateId);
      this.compiledTemplate = this.compileTemplate(template);
  
      return this.compiledTemplate;
    },
  
    // Load a template from the DOM, by default. Override
    // this method to provide your own template retrieval
    // For asynchronous loading with AMD/RequireJS, consider
    // using a template-loader plugin as described here:
    // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
    loadTemplate: function(templateId){
      var template = Marionette.$(templateId).html();
  
      if (!template || template.length === 0){
        throwError("Could not find template: '" + templateId + "'", "NoTemplateError");
      }
  
      return template;
    },
  
    // Pre-compile the template before caching it. Override
    // this method if you do not need to pre-compile a template
    // (JST / RequireJS for example) or if you want to change
    // the template engine used (Handebars, etc).
    compileTemplate: function(rawTemplate){
      return _.template(rawTemplate);
    }
  });
  
  // Renderer
  // --------
  
  // Render a template with data by passing in the template
  // selector and the data to render.
  Marionette.Renderer = {
  
    // Render a template with data. The `template` parameter is
    // passed to the `TemplateCache` object to retrieve the
    // template function. Override this method to provide your own
    // custom rendering and template handling for all of Marionette.
    render: function(template, data){
  
      if (!template) {
        throwError("Cannot render the template since it's false, null or undefined.", "TemplateNotFoundError");
      }
  
      var templateFunc;
      if (typeof template === "function"){
        templateFunc = template;
      } else {
        templateFunc = Marionette.TemplateCache.get(template);
      }
  
      return templateFunc(data);
    }
  };
  
  
  // Marionette.View
  // ---------------
  
  // The core view type that other Marionette views extend from.
  Marionette.View = Backbone.View.extend({
  
    constructor: function(options){
      _.bindAll(this, "render");
  
      // this exposes view options to the view initializer
      // this is a backfill since backbone removed the assignment
      // of this.options
      // at some point however this may be removed
      this.options = _.extend({}, _.result(this, 'options'), _.isFunction(options) ? options.call(this) : options);
  
      // parses out the @ui DSL for events
      this.events = this.normalizeUIKeys(_.result(this, 'events'));
  
      if (_.isObject(this.behaviors)) {
        new Marionette.Behaviors(this);
      }
  
      Backbone.View.prototype.constructor.apply(this, arguments);
  
      Marionette.MonitorDOMRefresh(this);
      this.listenTo(this, "show", this.onShowCalled);
    },
  
    // import the "triggerMethod" to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod,
  
    // Imports the "normalizeMethods" to transform hashes of
    // events=>function references/names to a hash of events=>function references
    normalizeMethods: Marionette.normalizeMethods,
  
    // Get the template for this view
    // instance. You can set a `template` attribute in the view
    // definition or pass a `template: "whatever"` parameter in
    // to the constructor options.
    getTemplate: function(){
      return Marionette.getOption(this, "template");
    },
  
    // Mix in template helper methods. Looks for a
    // `templateHelpers` attribute, which can either be an
    // object literal, or a function that returns an object
    // literal. All methods and attributes from this object
    // are copies to the object passed in.
    mixinTemplateHelpers: function(target){
      target = target || {};
      var templateHelpers = Marionette.getOption(this, "templateHelpers");
      if (_.isFunction(templateHelpers)){
        templateHelpers = templateHelpers.call(this);
      }
      return _.extend(target, templateHelpers);
    },
  
  
    normalizeUIKeys: function(hash) {
      var ui = _.result(this, 'ui');
      return Marionette.normalizeUIKeys(hash, ui);
    },
  
    // Configure `triggers` to forward DOM events to view
    // events. `triggers: {"click .foo": "do:foo"}`
    configureTriggers: function(){
      if (!this.triggers) { return; }
  
      var triggerEvents = {};
  
      // Allow `triggers` to be configured as a function
      var triggers = this.normalizeUIKeys(_.result(this, "triggers"));
  
      // Configure the triggers, prevent default
      // action and stop propagation of DOM events
      _.each(triggers, function(value, key){
  
        var hasOptions = _.isObject(value);
        var eventName = hasOptions ? value.event : value;
  
        // build the event handler function for the DOM event
        triggerEvents[key] = function(e){
  
          // stop the event in its tracks
          if (e) {
            var prevent = e.preventDefault;
            var stop = e.stopPropagation;
  
            var shouldPrevent = hasOptions ? value.preventDefault : prevent;
            var shouldStop = hasOptions ? value.stopPropagation : stop;
  
            if (shouldPrevent && prevent) { prevent.apply(e); }
            if (shouldStop && stop) { stop.apply(e); }
          }
  
          // build the args for the event
          var args = {
            view: this,
            model: this.model,
            collection: this.collection
          };
  
          // trigger the event
          this.triggerMethod(eventName, args);
        };
  
      }, this);
  
      return triggerEvents;
    },
  
    // Overriding Backbone.View's delegateEvents to handle
    // the `triggers`, `modelEvents`, and `collectionEvents` configuration
    delegateEvents: function(events){
      this._delegateDOMEvents(events);
      Marionette.bindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
      Marionette.bindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));
    },
  
    // internal method to delegate DOM events and triggers
    _delegateDOMEvents: function(events){
      events = events || this.events;
      if (_.isFunction(events)){ events = events.call(this); }
  
      var combinedEvents = {};
  
      // look up if this view has behavior events
      var behaviorEvents = _.result(this, 'behaviorEvents') || {};
      var triggers = this.configureTriggers();
  
      // behavior events will be overriden by view events and or triggers
      _.extend(combinedEvents, behaviorEvents, events, triggers);
  
      Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
    },
  
    // Overriding Backbone.View's undelegateEvents to handle unbinding
    // the `triggers`, `modelEvents`, and `collectionEvents` config
    undelegateEvents: function(){
      var args = Array.prototype.slice.call(arguments);
      Backbone.View.prototype.undelegateEvents.apply(this, args);
  
      Marionette.unbindEntityEvents(this, this.model, Marionette.getOption(this, "modelEvents"));
      Marionette.unbindEntityEvents(this, this.collection, Marionette.getOption(this, "collectionEvents"));
    },
  
    // Internal method, handles the `show` event.
    onShowCalled: function(){},
  
    // Default `close` implementation, for removing a view from the
    // DOM and unbinding it. Regions will call this method
    // for you. You can specify an `onClose` method in your view to
    // add custom code that is called after the view is closed.
    close: function(){
      if (this.isClosed) { return; }
  
      var args = Array.prototype.slice.call(arguments);
  
      // allow the close to be stopped by returning `false`
      // from the `onBeforeClose` method
      var shouldClose = this.triggerMethod.apply(this, ["before:close"].concat(args));
      if (shouldClose === false){
        return;
      }
  
      // mark as closed before doing the actual close, to
      // prevent infinite loops within "close" event handlers
      // that are trying to close other views
      this.isClosed = true;
      this.triggerMethod.apply(this, ["close"].concat(args));
  
      // unbind UI elements
      this.unbindUIElements();
  
      // remove the view from the DOM
      this.remove();
    },
  
    // This method binds the elements specified in the "ui" hash inside the view's code with
    // the associated jQuery selectors.
    bindUIElements: function(){
      if (!this.ui) { return; }
  
      // store the ui hash in _uiBindings so they can be reset later
      // and so re-rendering the view will be able to find the bindings
      if (!this._uiBindings){
        this._uiBindings = this.ui;
      }
  
      // get the bindings result, as a function or otherwise
      var bindings = _.result(this, "_uiBindings");
  
      // empty the ui so we don't have anything to start with
      this.ui = {};
  
      // bind each of the selectors
      _.each(_.keys(bindings), function(key) {
        var selector = bindings[key];
        this.ui[key] = this.$(selector);
      }, this);
    },
  
    // This method unbinds the elements specified in the "ui" hash
    unbindUIElements: function(){
      if (!this.ui || !this._uiBindings){ return; }
  
      // delete all of the existing ui bindings
      _.each(this.ui, function($el, name){
        delete this.ui[name];
      }, this);
  
      // reset the ui element to the original bindings configuration
      this.ui = this._uiBindings;
      delete this._uiBindings;
    }
  });
  
  // Item View
  // ---------
  
  // A single item view implementation that contains code for rendering
  // with underscore.js templates, serializing the view's model or collection,
  // and calling several methods on extended views, such as `onRender`.
  Marionette.ItemView = Marionette.View.extend({
  
    // Setting up the inheritance chain which allows changes to
    // Marionette.View.prototype.constructor which allows overriding
    constructor: function(){
      Marionette.View.prototype.constructor.apply(this, arguments);
    },
  
    // Serialize the model or collection for the view. If a model is
    // found, `.toJSON()` is called. If a collection is found, `.toJSON()`
    // is also called, but is used to populate an `items` array in the
    // resulting data. If both are found, defaults to the model.
    // You can override the `serializeData` method in your own view
    // definition, to provide custom serialization for your view's data.
    serializeData: function(){
      var data = {};
  
      if (this.model) {
        data = this.model.toJSON();
      }
      else if (this.collection) {
        data = { items: this.collection.toJSON() };
      }
  
      return data;
    },
  
    // Render the view, defaulting to underscore.js templates.
    // You can override this in your view definition to provide
    // a very specific rendering for your view. In general, though,
    // you should override the `Marionette.Renderer` object to
    // change how Marionette renders views.
    render: function(){
      this.isClosed = false;
  
      this.triggerMethod("before:render", this);
      this.triggerMethod("item:before:render", this);
  
      var data = this.serializeData();
      data = this.mixinTemplateHelpers(data);
  
      var template = this.getTemplate();
      var html = Marionette.Renderer.render(template, data);
  
      this.$el.html(html);
      this.bindUIElements();
  
      this.triggerMethod("render", this);
      this.triggerMethod("item:rendered", this);
  
      return this;
    },
  
    // Override the default close event to add a few
    // more events that are triggered.
    close: function(){
      if (this.isClosed){ return; }
  
      this.triggerMethod('item:before:close');
  
      Marionette.View.prototype.close.apply(this, arguments);
  
      this.triggerMethod('item:closed');
    }
  });
  
  // Collection View
  // ---------------
  
  // A view that iterates over a Backbone.Collection
  // and renders an individual ItemView for each model.
  Marionette.CollectionView = Marionette.View.extend({
    // used as the prefix for item view events
    // that are forwarded through the collectionview
    itemViewEventPrefix: "itemview",
  
    // constructor
    constructor: function(options){
      this._initChildViewStorage();
  
      Marionette.View.prototype.constructor.apply(this, arguments);
  
      this._initialEvents();
      this.initRenderBuffer();
    },
  
    // Instead of inserting elements one by one into the page,
    // it's much more performant to insert elements into a document
    // fragment and then insert that document fragment into the page
    initRenderBuffer: function() {
      this.elBuffer = document.createDocumentFragment();
      this._bufferedChildren = [];
    },
  
    startBuffering: function() {
      this.initRenderBuffer();
      this.isBuffering = true;
    },
  
    endBuffering: function() {
      this.isBuffering = false;
      this.appendBuffer(this, this.elBuffer);
      this._triggerShowBufferedChildren();
      this.initRenderBuffer();
    },
  
    _triggerShowBufferedChildren: function () {
      if (this._isShown) {
        _.each(this._bufferedChildren, function (child) {
          if (_.isFunction(child.triggerMethod)) {
            child.triggerMethod('show');
          } else {
            Marionette.triggerMethod.call(child, 'show');
          }
        });
        this._bufferedChildren = [];
      }
    },
  
    // Configured the initial events that the collection view
    // binds to.
    _initialEvents: function(){
      if (this.collection){
        this.listenTo(this.collection, "add", this.addChildView);
        this.listenTo(this.collection, "remove", this.removeItemView);
        this.listenTo(this.collection, "reset", this.render);
      }
    },
  
    // Handle a child item added to the collection
    addChildView: function(item, collection, options){
      this.closeEmptyView();
      var ItemView = this.getItemView(item);
      var index = this.collection.indexOf(item);
      this.addItemView(item, ItemView, index);
    },
  
    // Override from `Marionette.View` to guarantee the `onShow` method
    // of child views is called.
    onShowCalled: function(){
      this.children.each(function(child){
        if (_.isFunction(child.triggerMethod)) {
          child.triggerMethod('show');
        } else {
          Marionette.triggerMethod.call(child, 'show');
        }
      });
    },
  
    // Internal method to trigger the before render callbacks
    // and events
    triggerBeforeRender: function(){
      this.triggerMethod("before:render", this);
      this.triggerMethod("collection:before:render", this);
    },
  
    // Internal method to trigger the rendered callbacks and
    // events
    triggerRendered: function(){
      this.triggerMethod("render", this);
      this.triggerMethod("collection:rendered", this);
    },
  
    // Render the collection of items. Override this method to
    // provide your own implementation of a render function for
    // the collection view.
    render: function(){
      this.isClosed = false;
      this.triggerBeforeRender();
      this._renderChildren();
      this.triggerRendered();
      return this;
    },
  
    // Internal method. Separated so that CompositeView can have
    // more control over events being triggered, around the rendering
    // process
    _renderChildren: function(){
      this.startBuffering();
  
      this.closeEmptyView();
      this.closeChildren();
  
      if (!this.isEmpty(this.collection)) {
        this.showCollection();
      } else {
        this.showEmptyView();
      }
  
      this.endBuffering();
    },
  
    // Internal method to loop through each item in the
    // collection view and show it
    showCollection: function(){
      var ItemView;
      this.collection.each(function(item, index){
        ItemView = this.getItemView(item);
        this.addItemView(item, ItemView, index);
      }, this);
    },
  
    // Internal method to show an empty view in place of
    // a collection of item views, when the collection is
    // empty
    showEmptyView: function(){
      var EmptyView = this.getEmptyView();
  
      if (EmptyView && !this._showingEmptyView){
        this._showingEmptyView = true;
        var model = new Backbone.Model();
        this.addItemView(model, EmptyView, 0);
      }
    },
  
    // Internal method to close an existing emptyView instance
    // if one exists. Called when a collection view has been
    // rendered empty, and then an item is added to the collection.
    closeEmptyView: function(){
      if (this._showingEmptyView){
        this.closeChildren();
        delete this._showingEmptyView;
      }
    },
  
    // Retrieve the empty view type
    getEmptyView: function(){
      return Marionette.getOption(this, "emptyView");
    },
  
    // Retrieve the itemView type, either from `this.options.itemView`
    // or from the `itemView` in the object definition. The "options"
    // takes precedence.
    getItemView: function(item){
      var itemView = Marionette.getOption(this, "itemView");
  
      if (!itemView){
        throwError("An `itemView` must be specified", "NoItemViewError");
      }
  
      return itemView;
    },
  
    // Render the child item's view and add it to the
    // HTML for the collection view.
    addItemView: function(item, ItemView, index){
      // get the itemViewOptions if any were specified
      var itemViewOptions = Marionette.getOption(this, "itemViewOptions");
      if (_.isFunction(itemViewOptions)){
        itemViewOptions = itemViewOptions.call(this, item, index);
      }
  
      // build the view
      var view = this.buildItemView(item, ItemView, itemViewOptions);
  
      // set up the child view event forwarding
      this.addChildViewEventForwarding(view);
  
      // this view is about to be added
      this.triggerMethod("before:item:added", view);
  
      // Store the child view itself so we can properly
      // remove and/or close it later
      this.children.add(view);
  
      // Render it and show it
      this.renderItemView(view, index);
  
      // call the "show" method if the collection view
      // has already been shown
      if (this._isShown && !this.isBuffering){
        if (_.isFunction(view.triggerMethod)) {
          view.triggerMethod('show');
        } else {
          Marionette.triggerMethod.call(view, 'show');
        }
      }
  
      // this view was added
      this.triggerMethod("after:item:added", view);
  
      return view;
    },
  
    // Set up the child view event forwarding. Uses an "itemview:"
    // prefix in front of all forwarded events.
    addChildViewEventForwarding: function(view){
      var prefix = Marionette.getOption(this, "itemViewEventPrefix");
  
      // Forward all child item view events through the parent,
      // prepending "itemview:" to the event name
      this.listenTo(view, "all", function(){
        var args = slice.call(arguments);
        var rootEvent = args[0];
        var itemEvents = this.normalizeMethods(this.getItemEvents());
  
        args[0] = prefix + ":" + rootEvent;
        args.splice(1, 0, view);
  
        // call collectionView itemEvent if defined
        if (typeof itemEvents !== "undefined" && _.isFunction(itemEvents[rootEvent])) {
          itemEvents[rootEvent].apply(this, args);
        }
  
        Marionette.triggerMethod.apply(this, args);
      }, this);
    },
  
    // returns the value of itemEvents depending on if a function
    getItemEvents: function() {
      if (_.isFunction(this.itemEvents)) {
        return this.itemEvents.call(this);
      }
  
      return this.itemEvents;
    },
  
    // render the item view
    renderItemView: function(view, index) {
      view.render();
      this.appendHtml(this, view, index);
    },
  
    // Build an `itemView` for every model in the collection.
    buildItemView: function(item, ItemViewType, itemViewOptions){
      var options = _.extend({model: item}, itemViewOptions);
      return new ItemViewType(options);
    },
  
    // get the child view by item it holds, and remove it
    removeItemView: function(item){
      var view = this.children.findByModel(item);
      this.removeChildView(view);
      this.checkEmpty();
    },
  
    // Remove the child view and close it
    removeChildView: function(view){
  
      // shut down the child view properly,
      // including events that the collection has from it
      if (view){
        // call 'close' or 'remove', depending on which is found
        if (view.close) { view.close(); }
        else if (view.remove) { view.remove(); }
  
        this.stopListening(view);
        this.children.remove(view);
      }
  
      this.triggerMethod("item:removed", view);
    },
  
    // helper to check if the collection is empty
    isEmpty: function(collection){
      // check if we're empty now
      return !this.collection || this.collection.length === 0;
    },
  
    // If empty, show the empty view
    checkEmpty: function (){
      if (this.isEmpty(this.collection)){
        this.showEmptyView();
      }
    },
  
    // You might need to override this if you've overridden appendHtml
    appendBuffer: function(collectionView, buffer) {
      collectionView.$el.append(buffer);
    },
  
    // Append the HTML to the collection's `el`.
    // Override this method to do something other
    // than `.append`.
    appendHtml: function(collectionView, itemView, index){
      if (collectionView.isBuffering) {
        // buffering happens on reset events and initial renders
        // in order to reduce the number of inserts into the
        // document, which are expensive.
        collectionView.elBuffer.appendChild(itemView.el);
        collectionView._bufferedChildren.push(itemView);
      }
      else {
        // If we've already rendered the main collection, just
        // append the new items directly into the element.
        collectionView.$el.append(itemView.el);
      }
    },
  
    // Internal method to set up the `children` object for
    // storing all of the child views
    _initChildViewStorage: function(){
      this.children = new Backbone.ChildViewContainer();
    },
  
    // Handle cleanup and other closing needs for
    // the collection of views.
    close: function(){
      if (this.isClosed){ return; }
  
      this.triggerMethod("collection:before:close");
      this.closeChildren();
      this.triggerMethod("collection:closed");
  
      Marionette.View.prototype.close.apply(this, arguments);
    },
  
    // Close the child views that this collection view
    // is holding on to, if any
    closeChildren: function(){
      this.children.each(function(child){
        this.removeChildView(child);
      }, this);
      this.checkEmpty();
    }
  });
  
  // Composite View
  // --------------
  
  // Used for rendering a branch-leaf, hierarchical structure.
  // Extends directly from CollectionView and also renders an
  // an item view as `modelView`, for the top leaf
  Marionette.CompositeView = Marionette.CollectionView.extend({
  
    // Setting up the inheritance chain which allows changes to
    // Marionette.CollectionView.prototype.constructor which allows overriding
    constructor: function(){
      Marionette.CollectionView.prototype.constructor.apply(this, arguments);
    },
  
    // Configured the initial events that the composite view
    // binds to. Override this method to prevent the initial
    // events, or to add your own initial events.
    _initialEvents: function(){
  
      // Bind only after composite view is rendered to avoid adding child views
      // to nonexistent itemViewContainer
      this.once('render', function () {
        if (this.collection){
          this.listenTo(this.collection, "add", this.addChildView);
          this.listenTo(this.collection, "remove", this.removeItemView);
          this.listenTo(this.collection, "reset", this._renderChildren);
        }
      });
  
    },
  
    // Retrieve the `itemView` to be used when rendering each of
    // the items in the collection. The default is to return
    // `this.itemView` or Marionette.CompositeView if no `itemView`
    // has been defined
    getItemView: function(item){
      var itemView = Marionette.getOption(this, "itemView") || this.constructor;
  
      if (!itemView){
        throwError("An `itemView` must be specified", "NoItemViewError");
      }
  
      return itemView;
    },
  
    // Serialize the collection for the view.
    // You can override the `serializeData` method in your own view
    // definition, to provide custom serialization for your view's data.
    serializeData: function(){
      var data = {};
  
      if (this.model){
        data = this.model.toJSON();
      }
  
      return data;
    },
  
    // Renders the model once, and the collection once. Calling
    // this again will tell the model's view to re-render itself
    // but the collection will not re-render.
    render: function(){
      this.isRendered = true;
      this.isClosed = false;
      this.resetItemViewContainer();
  
      this.triggerBeforeRender();
      var html = this.renderModel();
      this.$el.html(html);
      // the ui bindings is done here and not at the end of render since they
      // will not be available until after the model is rendered, but should be
      // available before the collection is rendered.
      this.bindUIElements();
      this.triggerMethod("composite:model:rendered");
  
      this._renderChildren();
  
      this.triggerMethod("composite:rendered");
      this.triggerRendered();
      return this;
    },
  
    _renderChildren: function(){
      if (this.isRendered){
        this.triggerMethod("composite:collection:before:render");
        Marionette.CollectionView.prototype._renderChildren.call(this);
        this.triggerMethod("composite:collection:rendered");
      }
    },
  
    // Render an individual model, if we have one, as
    // part of a composite view (branch / leaf). For example:
    // a treeview.
    renderModel: function(){
      var data = {};
      data = this.serializeData();
      data = this.mixinTemplateHelpers(data);
  
      var template = this.getTemplate();
      return Marionette.Renderer.render(template, data);
    },
  
  
    // You might need to override this if you've overridden appendHtml
    appendBuffer: function(compositeView, buffer) {
      var $container = this.getItemViewContainer(compositeView);
      $container.append(buffer);
    },
  
    // Appends the `el` of itemView instances to the specified
    // `itemViewContainer` (a jQuery selector). Override this method to
    // provide custom logic of how the child item view instances have their
    // HTML appended to the composite view instance.
    appendHtml: function(compositeView, itemView, index){
      if (compositeView.isBuffering) {
        compositeView.elBuffer.appendChild(itemView.el);
        compositeView._bufferedChildren.push(itemView);
      }
      else {
        // If we've already rendered the main collection, just
        // append the new items directly into the element.
        var $container = this.getItemViewContainer(compositeView);
        $container.append(itemView.el);
      }
    },
  
    // Internal method to ensure an `$itemViewContainer` exists, for the
    // `appendHtml` method to use.
    getItemViewContainer: function(containerView){
      if ("$itemViewContainer" in containerView){
        return containerView.$itemViewContainer;
      }
  
      var container;
      var itemViewContainer = Marionette.getOption(containerView, "itemViewContainer");
      if (itemViewContainer){
  
        var selector = _.isFunction(itemViewContainer) ? itemViewContainer.call(containerView) : itemViewContainer;
  
        if (selector.charAt(0) === "@" && containerView.ui) {
          container = containerView.ui[selector.substr(4)];
        } else {
          container = containerView.$(selector);
        }
  
        if (container.length <= 0) {
          throwError("The specified `itemViewContainer` was not found: " + containerView.itemViewContainer, "ItemViewContainerMissingError");
        }
  
      } else {
        container = containerView.$el;
      }
  
      containerView.$itemViewContainer = container;
      return container;
    },
  
    // Internal method to reset the `$itemViewContainer` on render
    resetItemViewContainer: function(){
      if (this.$itemViewContainer){
        delete this.$itemViewContainer;
      }
    }
  });
  
  // Layout
  // ------
  
  // Used for managing application layouts, nested layouts and
  // multiple regions within an application or sub-application.
  //
  // A specialized view type that renders an area of HTML and then
  // attaches `Region` instances to the specified `regions`.
  // Used for composite view management and sub-application areas.
  Marionette.Layout = Marionette.ItemView.extend({
    regionType: Marionette.Region,
  
    // Ensure the regions are available when the `initialize` method
    // is called.
    constructor: function (options) {
      options = options || {};
  
      this._firstRender = true;
      this._initializeRegions(options);
  
      Marionette.ItemView.prototype.constructor.call(this, options);
    },
  
    // Layout's render will use the existing region objects the
    // first time it is called. Subsequent calls will close the
    // views that the regions are showing and then reset the `el`
    // for the regions to the newly rendered DOM elements.
    render: function(){
  
      if (this.isClosed){
        // a previously closed layout means we need to
        // completely re-initialize the regions
        this._initializeRegions();
      }
      if (this._firstRender) {
        // if this is the first render, don't do anything to
        // reset the regions
        this._firstRender = false;
      } else if (!this.isClosed){
        // If this is not the first render call, then we need to
        // re-initializing the `el` for each region
        this._reInitializeRegions();
      }
  
      return Marionette.ItemView.prototype.render.apply(this, arguments);
    },
  
    // Handle closing regions, and then close the view itself.
    close: function () {
      if (this.isClosed){ return; }
      this.regionManager.close();
      Marionette.ItemView.prototype.close.apply(this, arguments);
    },
  
    // Add a single region, by name, to the layout
    addRegion: function(name, definition){
      var regions = {};
      regions[name] = definition;
      return this._buildRegions(regions)[name];
    },
  
    // Add multiple regions as a {name: definition, name2: def2} object literal
    addRegions: function(regions){
      this.regions = _.extend({}, this.regions, regions);
      return this._buildRegions(regions);
    },
  
    // Remove a single region from the Layout, by name
    removeRegion: function(name){
      delete this.regions[name];
      return this.regionManager.removeRegion(name);
    },
  
    // Provides alternative access to regions
    // Accepts the region name
    // getRegion('main')
    getRegion: function(region) {
      return this.regionManager.get(region);
    },
  
    // internal method to build regions
    _buildRegions: function(regions){
      var that = this;
  
      var defaults = {
        regionType: Marionette.getOption(this, "regionType"),
        parentEl: function(){ return that.$el; }
      };
  
      return this.regionManager.addRegions(regions, defaults);
    },
  
    // Internal method to initialize the regions that have been defined in a
    // `regions` attribute on this layout.
    _initializeRegions: function (options) {
      var regions;
      this._initRegionManager();
  
      if (_.isFunction(this.regions)) {
        regions = this.regions(options);
      } else {
        regions = this.regions || {};
      }
  
      this.addRegions(regions);
    },
  
    // Internal method to re-initialize all of the regions by updating the `el` that
    // they point to
    _reInitializeRegions: function(){
      this.regionManager.closeRegions();
      this.regionManager.each(function(region){
        region.reset();
      });
    },
  
    // Internal method to initialize the region manager
    // and all regions in it
    _initRegionManager: function(){
      this.regionManager = new Marionette.RegionManager();
  
      this.listenTo(this.regionManager, "region:add", function(name, region){
        this[name] = region;
        this.trigger("region:add", name, region);
      });
  
      this.listenTo(this.regionManager, "region:remove", function(name, region){
        delete this[name];
        this.trigger("region:remove", name, region);
      });
    }
  });
  
  
  // Behavior
  // -----------
  
  // A Behavior is an isolated set of DOM /
  // user interactions that can be mixed into any View.
  // Behaviors allow you to blackbox View specific interactions
  // into portable logical chunks, keeping your views simple and your code DRY.
  
  Marionette.Behavior = (function(_, Backbone){
    function Behavior(options, view){
      // Setup reference to the view.
      // this comes in handle when a behavior
      // wants to directly talk up the chain
      // to the view.
      this.view = view;
      this.defaults = _.result(this, "defaults") || {};
      this.options  = _.extend({}, this.defaults, options);
  
      // proxy behavior $ method to the view
      // this is useful for doing jquery DOM lookups
      // scoped to behaviors view.
      this.$ = function() {
        return this.view.$.apply(this.view, arguments);
      };
  
      // Call the initialize method passing
      // the arguments from the instance constructor
      this.initialize.apply(this, arguments);
    }
  
    _.extend(Behavior.prototype, Backbone.Events, {
      initialize: function(){},
  
      // stopListening to behavior `onListen` events.
      close: function() {
        this.stopListening();
      },
  
      // Setup class level proxy for triggerMethod.
      triggerMethod: Marionette.triggerMethod
    });
  
    // Borrow Backbones extend implementation
    // this allows us to setup a proper
    // inheritence pattern that follow in suite
    // with the rest of Marionette views.
    Behavior.extend = Marionette.extend;
  
    return Behavior;
  })(_, Backbone);
  
  // Marionette.Behaviors
  // --------
  
  // Behaviors is a utility class that takes care of
  // glueing your behavior instances to their given View.
  // The most important part of this class is that you
  // **MUST** override the class level behaviorsLookup
  // method for things to work properly.
  
  Marionette.Behaviors = (function(Marionette, _) {
  
    function Behaviors(view) {
      // Behaviors defined on a view can be a flat object literal
      // or it can be a function that returns an object.
      this.behaviors = Behaviors.parseBehaviors(view, _.result(view, 'behaviors'));
  
      // Wraps several of the view's methods
      // calling the methods first on each behavior
      // and then eventually calling the method on the view.
      Behaviors.wrap(view, this.behaviors, [
        'bindUIElements', 'unbindUIElements',
        'delegateEvents', 'undelegateEvents',
        'behaviorEvents', 'triggerMethod',
        'setElement', 'close'
      ]);
    }
  
    var methods = {
      setElement: function(setElement, behaviors) {
        setElement.apply(this, _.tail(arguments, 2));
  
        // proxy behavior $el to the view's $el.
        // This is needed because a view's $el proxy
        // is not set until after setElement is called.
        _.each(behaviors, function(b) {
          b.$el = this.$el;
        }, this);
      },
  
      close: function(close, behaviors) {
        var args = _.tail(arguments, 2);
        close.apply(this, args);
  
        // Call close on each behavior after
        // closing down the view.
        // This unbinds event listeners
        // that behaviors have registerd for.
        _.invoke(behaviors, 'close', args);
      },
  
      bindUIElements: function(bindUIElements, behaviors) {
        bindUIElements.apply(this);
        _.invoke(behaviors, bindUIElements);
      },
  
      unbindUIElements: function(unbindUIElements, behaviors) {
        unbindUIElements.apply(this);
        _.invoke(behaviors, unbindUIElements);
      },
  
      triggerMethod: function(triggerMethod, behaviors) {
        var args = _.tail(arguments, 2);
        triggerMethod.apply(this, args);
  
        _.each(behaviors, function(b) {
          triggerMethod.apply(b, args);
        });
      },
  
      delegateEvents: function(delegateEvents, behaviors) {
        var args = _.tail(arguments, 2);
        delegateEvents.apply(this, args);
  
        _.each(behaviors, function(b){
          Marionette.bindEntityEvents(b, this.model, Marionette.getOption(b, "modelEvents"));
          Marionette.bindEntityEvents(b, this.collection, Marionette.getOption(b, "collectionEvents"));
        }, this);
      },
  
      undelegateEvents: function(undelegateEvents, behaviors) {
        var args = _.tail(arguments, 2);
        undelegateEvents.apply(this, args);
  
        _.each(behaviors, function(b) {
          Marionette.unbindEntityEvents(b, this.model, Marionette.getOption(b, "modelEvents"));
          Marionette.unbindEntityEvents(b, this.collection, Marionette.getOption(b, "collectionEvents"));
        }, this);
      },
  
      behaviorEvents: function(behaviorEvents, behaviors) {
        var _behaviorsEvents = {};
        var viewUI = _.result(this, 'ui');
  
        _.each(behaviors, function(b, i) {
          var _events = {};
          var behaviorEvents = _.clone(_.result(b, 'events')) || {};
          var behaviorUI = _.result(b, 'ui');
  
          // Construct an internal UI hash first using
          // the views UI hash and then the behaviors UI hash.
          // This allows the user to use UI hash elements
          // defined in the parent view as well as those
          // defined in the given behavior.
          var ui = _.extend({}, viewUI, behaviorUI);
  
          // Normalize behavior events hash to allow
          // a user to use the @ui. syntax.
          behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, ui);
  
          _.each(_.keys(behaviorEvents), function(key) {
            // append white-space at the end of each key to prevent behavior key collisions
            // this is relying on the fact backbone events considers "click .foo" the same  "click .foo "
            // starts with an array of two so the first behavior has one space
  
            // +2 is uses becauce new Array(1) or 0 is "" and not " "
            var whitespace = (new Array(i+2)).join(" ");
            var eventKey   = key + whitespace;
            var handler    = _.isFunction(behaviorEvents[key]) ? behaviorEvents[key] : b[behaviorEvents[key]];
  
            _events[eventKey] = _.bind(handler, b);
          });
  
          _behaviorsEvents = _.extend(_behaviorsEvents, _events);
        });
  
        return _behaviorsEvents;
      }
    };
  
    _.extend(Behaviors, {
  
      // placeholder method to be extended by the user
      // should define the object that stores the behaviors
      // i.e.
      //
      // Marionette.Behaviors.behaviorsLookup: function() {
      //   return App.Behaviors
      // }
      behaviorsLookup: function() {
        throw new Error("You must define where your behaviors are stored. See https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.behaviors.md#behaviorslookup");
      },
  
      // Takes care of getting the behavior class
      // given options and a key.
      // If a user passes in options.behaviorClass
      // default to using that. Otherwise delegate
      // the lookup to the users behaviorsLookup implementation.
      getBehaviorClass: function(options, key) {
        if (options.behaviorClass) {
          return options.behaviorClass;
        }
  
        // Get behavior class can be either a flat object or a method
        return _.isFunction(Behaviors.behaviorsLookup) ? Behaviors.behaviorsLookup.apply(this, arguments)[key] : Behaviors.behaviorsLookup[key];
      },
  
      // Maps over a view's behaviors. Performing
      // a lookup on each behavior and the instantiating
      // said behavior passing its options and view.
      parseBehaviors: function(view, behaviors){
        return _.map(behaviors, function(options, key){
          var BehaviorClass = Behaviors.getBehaviorClass(options, key);
          return new BehaviorClass(options, view);
        });
      },
  
      // wrap view internal methods so that they delegate to behaviors.
      // For example, onClose should trigger close on all of the behaviors and then close itself.
      // i.e.
      //
      // view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);
      wrap: function(view, behaviors, methodNames) {
        _.each(methodNames, function(methodName) {
          view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
        });
      }
    });
  
    return Behaviors;
  
  })(Marionette, _);
  
  
  // AppRouter
  // ---------
  
  // Reduce the boilerplate code of handling route events
  // and then calling a single method on another object.
  // Have your routers configured to call the method on
  // your object, directly.
  //
  // Configure an AppRouter with `appRoutes`.
  //
  // App routers can only take one `controller` object.
  // It is recommended that you divide your controller
  // objects in to smaller pieces of related functionality
  // and have multiple routers / controllers, instead of
  // just one giant router and controller.
  //
  // You can also add standard routes to an AppRouter.
  
  Marionette.AppRouter = Backbone.Router.extend({
  
    constructor: function(options){
      Backbone.Router.prototype.constructor.apply(this, arguments);
  
      this.options = options || {};
  
      var appRoutes = Marionette.getOption(this, "appRoutes");
      var controller = this._getController();
      this.processAppRoutes(controller, appRoutes);
      this.on("route", this._processOnRoute, this);
    },
  
    // Similar to route method on a Backbone Router but
    // method is called on the controller
    appRoute: function(route, methodName) {
      var controller = this._getController();
      this._addAppRoute(controller, route, methodName);
    },
  
    // process the route event and trigger the onRoute
    // method call, if it exists
    _processOnRoute: function(routeName, routeArgs){
      // find the path that matched
      var routePath = _.invert(this.appRoutes)[routeName];
  
      // make sure an onRoute is there, and call it
      if (_.isFunction(this.onRoute)){
        this.onRoute(routeName, routePath, routeArgs);
      }
    },
  
    // Internal method to process the `appRoutes` for the
    // router, and turn them in to routes that trigger the
    // specified method on the specified `controller`.
    processAppRoutes: function(controller, appRoutes) {
      if (!appRoutes){ return; }
  
      var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes
  
      _.each(routeNames, function(route) {
        this._addAppRoute(controller, route, appRoutes[route]);
      }, this);
    },
  
    _getController: function(){
      return Marionette.getOption(this, "controller");
    },
  
    _addAppRoute: function(controller, route, methodName){
      var method = controller[methodName];
  
      if (!method) {
        throwError("Method '" + methodName + "' was not found on the controller");
      }
  
      this.route(route, methodName, _.bind(method, controller));
    }
  });
  
  // Application
  // -----------
  
  // Contain and manage the composite application as a whole.
  // Stores and starts up `Region` objects, includes an
  // event aggregator as `app.vent`
  Marionette.Application = function(options){
    this._initRegionManager();
    this._initCallbacks = new Marionette.Callbacks();
    this.vent = new Backbone.Wreqr.EventAggregator();
    this.commands = new Backbone.Wreqr.Commands();
    this.reqres = new Backbone.Wreqr.RequestResponse();
    this.submodules = {};
  
    _.extend(this, options);
  
    this.triggerMethod = Marionette.triggerMethod;
  };
  
  _.extend(Marionette.Application.prototype, Backbone.Events, {
    // Command execution, facilitated by Backbone.Wreqr.Commands
    execute: function(){
      this.commands.execute.apply(this.commands, arguments);
    },
  
    // Request/response, facilitated by Backbone.Wreqr.RequestResponse
    request: function(){
      return this.reqres.request.apply(this.reqres, arguments);
    },
  
    // Add an initializer that is either run at when the `start`
    // method is called, or run immediately if added after `start`
    // has already been called.
    addInitializer: function(initializer){
      this._initCallbacks.add(initializer);
    },
  
    // kick off all of the application's processes.
    // initializes all of the regions that have been added
    // to the app, and runs all of the initializer functions
    start: function(options){
      this.triggerMethod("initialize:before", options);
      this._initCallbacks.run(options, this);
      this.triggerMethod("initialize:after", options);
  
      this.triggerMethod("start", options);
    },
  
    // Add regions to your app.
    // Accepts a hash of named strings or Region objects
    // addRegions({something: "#someRegion"})
    // addRegions({something: Region.extend({el: "#someRegion"}) });
    addRegions: function(regions){
      return this._regionManager.addRegions(regions);
    },
  
    // Close all regions in the app, without removing them
    closeRegions: function(){
      this._regionManager.closeRegions();
    },
  
    // Removes a region from your app, by name
    // Accepts the regions name
    // removeRegion('myRegion')
    removeRegion: function(region) {
      this._regionManager.removeRegion(region);
    },
  
    // Provides alternative access to regions
    // Accepts the region name
    // getRegion('main')
    getRegion: function(region) {
      return this._regionManager.get(region);
    },
  
    // Create a module, attached to the application
    module: function(moduleNames, moduleDefinition){
  
      // Overwrite the module class if the user specifies one
      var ModuleClass = Marionette.Module.getClass(moduleDefinition);
  
      // slice the args, and add this application object as the
      // first argument of the array
      var args = slice.call(arguments);
      args.unshift(this);
  
      // see the Marionette.Module object for more information
      return ModuleClass.create.apply(ModuleClass, args);
    },
  
    // Internal method to set up the region manager
    _initRegionManager: function(){
      this._regionManager = new Marionette.RegionManager();
  
      this.listenTo(this._regionManager, "region:add", function(name, region){
        this[name] = region;
      });
  
      this.listenTo(this._regionManager, "region:remove", function(name, region){
        delete this[name];
      });
    }
  });
  
  // Copy the `extend` function used by Backbone's classes
  Marionette.Application.extend = Marionette.extend;
  
  // Module
  // ------
  
  // A simple module system, used to create privacy and encapsulation in
  // Marionette applications
  Marionette.Module = function(moduleName, app, options){
    this.moduleName = moduleName;
    this.options = _.extend({}, this.options, options);
    // Allow for a user to overide the initialize
    // for a given module instance.
    this.initialize = options.initialize || this.initialize;
  
    // Set up an internal store for sub-modules.
    this.submodules = {};
  
    this._setupInitializersAndFinalizers();
  
    // Set an internal reference to the app
    // within a module.
    this.app = app;
  
    // By default modules start with their parents.
    this.startWithParent = true;
  
    // Setup a proxy to the trigger method implementation.
    this.triggerMethod = Marionette.triggerMethod;
  
    if (_.isFunction(this.initialize)){
      this.initialize(this.options, moduleName, app);
    }
  };
  
  Marionette.Module.extend = Marionette.extend;
  
  // Extend the Module prototype with events / listenTo, so that the module
  // can be used as an event aggregator or pub/sub.
  _.extend(Marionette.Module.prototype, Backbone.Events, {
  
    // Initialize is an empty function by default. Override it with your own
    // initialization logic when extending Marionette.Module.
    initialize: function(){},
  
    // Initializer for a specific module. Initializers are run when the
    // module's `start` method is called.
    addInitializer: function(callback){
      this._initializerCallbacks.add(callback);
    },
  
    // Finalizers are run when a module is stopped. They are used to teardown
    // and finalize any variables, references, events and other code that the
    // module had set up.
    addFinalizer: function(callback){
      this._finalizerCallbacks.add(callback);
    },
  
    // Start the module, and run all of its initializers
    start: function(options){
      // Prevent re-starting a module that is already started
      if (this._isInitialized){ return; }
  
      // start the sub-modules (depth-first hierarchy)
      _.each(this.submodules, function(mod){
        // check to see if we should start the sub-module with this parent
        if (mod.startWithParent){
          mod.start(options);
        }
      });
  
      // run the callbacks to "start" the current module
      this.triggerMethod("before:start", options);
  
      this._initializerCallbacks.run(options, this);
      this._isInitialized = true;
  
      this.triggerMethod("start", options);
    },
  
    // Stop this module by running its finalizers and then stop all of
    // the sub-modules for this module
    stop: function(){
      // if we are not initialized, don't bother finalizing
      if (!this._isInitialized){ return; }
      this._isInitialized = false;
  
      Marionette.triggerMethod.call(this, "before:stop");
  
      // stop the sub-modules; depth-first, to make sure the
      // sub-modules are stopped / finalized before parents
      _.each(this.submodules, function(mod){ mod.stop(); });
  
      // run the finalizers
      this._finalizerCallbacks.run(undefined,this);
  
      // reset the initializers and finalizers
      this._initializerCallbacks.reset();
      this._finalizerCallbacks.reset();
  
      Marionette.triggerMethod.call(this, "stop");
    },
  
    // Configure the module with a definition function and any custom args
    // that are to be passed in to the definition function
    addDefinition: function(moduleDefinition, customArgs){
      this._runModuleDefinition(moduleDefinition, customArgs);
    },
  
    // Internal method: run the module definition function with the correct
    // arguments
    _runModuleDefinition: function(definition, customArgs){
      // If there is no definition short circut the method.
      if (!definition){ return; }
  
      // build the correct list of arguments for the module definition
      var args = _.flatten([
        this,
        this.app,
        Backbone,
        Marionette,
        Marionette.$, _,
        customArgs
      ]);
  
      definition.apply(this, args);
    },
  
    // Internal method: set up new copies of initializers and finalizers.
    // Calling this method will wipe out all existing initializers and
    // finalizers.
    _setupInitializersAndFinalizers: function(){
      this._initializerCallbacks = new Marionette.Callbacks();
      this._finalizerCallbacks = new Marionette.Callbacks();
    }
  });
  
  // Type methods to create modules
  _.extend(Marionette.Module, {
  
    // Create a module, hanging off the app parameter as the parent object.
    create: function(app, moduleNames, moduleDefinition){
      var module = app;
  
      // get the custom args passed in after the module definition and
      // get rid of the module name and definition function
      var customArgs = slice.call(arguments);
      customArgs.splice(0, 3);
  
      // Split the module names and get the number of submodules.
      // i.e. an example module name of `Doge.Wow.Amaze` would
      // then have the potential for 3 module definitions.
      moduleNames = moduleNames.split(".");
      var length = moduleNames.length;
  
      // store the module definition for the last module in the chain
      var moduleDefinitions = [];
      moduleDefinitions[length-1] = moduleDefinition;
  
      // Loop through all the parts of the module definition
      _.each(moduleNames, function(moduleName, i){
        var parentModule = module;
        module = this._getModule(parentModule, moduleName, app, moduleDefinition);
        this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
      }, this);
  
      // Return the last module in the definition chain
      return module;
    },
  
    _getModule: function(parentModule, moduleName, app, def, args){
      var options = _.extend({}, def);
      var ModuleClass = this.getClass(def);
  
      // Get an existing module of this name if we have one
      var module = parentModule[moduleName];
  
      if (!module){
        // Create a new module if we don't have one
        module = new ModuleClass(moduleName, app, options);
        parentModule[moduleName] = module;
        // store the module on the parent
        parentModule.submodules[moduleName] = module;
      }
  
      return module;
    },
  
    // ## Module Classes
    //
    // Module classes can be used as an alternative to the define pattern.
    // The extend function of a Module is identical to the extend functions
    // on other Backbone and Marionette classes.
    // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
    getClass: function(moduleDefinition) {
      var ModuleClass = Marionette.Module;
  
      if (!moduleDefinition) {
        return ModuleClass;
      }
  
      // If all of the module's functionality is defined inside its class,
      // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
      if (moduleDefinition.prototype instanceof ModuleClass) {
        return moduleDefinition;
      }
  
      return moduleDefinition.moduleClass || ModuleClass;
    },
  
    // Add the module definition and add a startWithParent initializer function.
    // This is complicated because module definitions are heavily overloaded
    // and support an anonymous function, module class, or options object
    _addModuleDefinition: function(parentModule, module, def, args){
      var fn = this._getDefine(def);
      var startWithParent = this._getStartWithParent(def, module);
  
      if (fn){
        module.addDefinition(fn, args);
      }
  
      this._addStartWithParent(parentModule, module, startWithParent);
    },
  
    _getStartWithParent: function(def, module) {
      var swp;
  
      if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
        swp = module.constructor.prototype.startWithParent;
        return _.isUndefined(swp) ? true : swp;
      }
  
      if (_.isObject(def)){
        swp = def.startWithParent;
        return _.isUndefined(swp) ? true : swp;
      }
  
      return true;
    },
  
    _getDefine: function(def) {
      if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
        return def;
      }
  
      if (_.isObject(def)){
        return def.define;
      }
  
      return null;
    },
  
    _addStartWithParent: function(parentModule, module, startWithParent) {
      module.startWithParent = module.startWithParent && startWithParent;
  
      if (!module.startWithParent || !!module.startWithParentIsConfigured){
        return;
      }
  
      module.startWithParentIsConfigured = true;
  
      parentModule.addInitializer(function(options){
        if (module.startWithParent){
          module.start(options);
        }
      });
    }
  });
  
  
    return Marionette;
  })(this, Backbone, _);
  
  return Backbone.Marionette;

}));

},{"backbone":5,"backbone.babysitter":2,"backbone.wreqr":4,"underscore":104}],4:[function(require,module,exports){
// Backbone.Wreqr (Backbone.Marionette)
// ----------------------------------
// v1.4.0
//
// Copyright (c)2016 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.wreqr


(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore'], function(Backbone, _) {
      return factory(Backbone, _);
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = require('backbone');
    var _ = require('underscore');
    module.exports = factory(Backbone, _);
  } else {
    factory(root.Backbone, root._);
  }

}(this, function(Backbone, _) {
  "use strict";

  var previousWreqr = Backbone.Wreqr;

  var Wreqr = Backbone.Wreqr = {};

  Backbone.Wreqr.VERSION = '1.4.0';

  Backbone.Wreqr.noConflict = function () {
    Backbone.Wreqr = previousWreqr;
    return this;
  };

  // Handlers
  // --------
  // A registry of functions to call, given a name
  
  Wreqr.Handlers = (function(Backbone, _){
    "use strict";
    
    // Constructor
    // -----------
  
    var Handlers = function(options){
      this.options = options;
      this._wreqrHandlers = {};
      
      if (_.isFunction(this.initialize)){
        this.initialize(options);
      }
    };
  
    Handlers.extend = Backbone.Model.extend;
  
    // Instance Members
    // ----------------
  
    _.extend(Handlers.prototype, Backbone.Events, {
  
      // Add multiple handlers using an object literal configuration
      setHandlers: function(handlers){
        _.each(handlers, _.bind(function(handler, name){
          var context = null;
  
          if (_.isObject(handler) && !_.isFunction(handler)){
            context = handler.context;
            handler = handler.callback;
          }
  
          this.setHandler(name, handler, context);
        }, this));
      },
  
      // Add a handler for the given name, with an
      // optional context to run the handler within
      setHandler: function(name, handler, context){
        var config = {
          callback: handler,
          context: context
        };
  
        this._wreqrHandlers[name] = config;
  
        this.trigger("handler:add", name, handler, context);
      },
  
      // Determine whether or not a handler is registered
      hasHandler: function(name){
        return !! this._wreqrHandlers[name];
      },
  
      // Get the currently registered handler for
      // the specified name. Throws an exception if
      // no handler is found.
      getHandler: function(name){
        var config = this._wreqrHandlers[name];
  
        if (!config){
          return;
        }
  
        return function(){
          return config.callback.apply(config.context, arguments);
        };
      },
  
      // Remove a handler for the specified name
      removeHandler: function(name){
        delete this._wreqrHandlers[name];
      },
  
      // Remove all handlers from this registry
      removeAllHandlers: function(){
        this._wreqrHandlers = {};
      }
    });
  
    return Handlers;
  })(Backbone, _);
  
  // Wreqr.CommandStorage
  // --------------------
  //
  // Store and retrieve commands for execution.
  Wreqr.CommandStorage = (function(){
    "use strict";
  
    // Constructor function
    var CommandStorage = function(options){
      this.options = options;
      this._commands = {};
  
      if (_.isFunction(this.initialize)){
        this.initialize(options);
      }
    };
  
    // Instance methods
    _.extend(CommandStorage.prototype, Backbone.Events, {
  
      // Get an object literal by command name, that contains
      // the `commandName` and the `instances` of all commands
      // represented as an array of arguments to process
      getCommands: function(commandName){
        var commands = this._commands[commandName];
  
        // we don't have it, so add it
        if (!commands){
  
          // build the configuration
          commands = {
            command: commandName, 
            instances: []
          };
  
          // store it
          this._commands[commandName] = commands;
        }
  
        return commands;
      },
  
      // Add a command by name, to the storage and store the
      // args for the command
      addCommand: function(commandName, args){
        var command = this.getCommands(commandName);
        command.instances.push(args);
      },
  
      // Clear all commands for the given `commandName`
      clearCommands: function(commandName){
        var command = this.getCommands(commandName);
        command.instances = [];
      }
    });
  
    return CommandStorage;
  })();
  
  // Wreqr.Commands
  // --------------
  //
  // A simple command pattern implementation. Register a command
  // handler and execute it.
  Wreqr.Commands = (function(Wreqr, _){
    "use strict";
  
    return Wreqr.Handlers.extend({
      // default storage type
      storageType: Wreqr.CommandStorage,
  
      constructor: function(options){
        this.options = options || {};
  
        this._initializeStorage(this.options);
        this.on("handler:add", this._executeCommands, this);
  
        Wreqr.Handlers.prototype.constructor.apply(this, arguments);
      },
  
      // Execute a named command with the supplied args
      execute: function(name){
        name = arguments[0];
        var args = _.rest(arguments);
  
        if (this.hasHandler(name)){
          this.getHandler(name).apply(this, args);
        } else {
          this.storage.addCommand(name, args);
        }
  
      },
  
      // Internal method to handle bulk execution of stored commands
      _executeCommands: function(name, handler, context){
        var command = this.storage.getCommands(name);
  
        // loop through and execute all the stored command instances
        _.each(command.instances, function(args){
          handler.apply(context, args);
        });
  
        this.storage.clearCommands(name);
      },
  
      // Internal method to initialize storage either from the type's
      // `storageType` or the instance `options.storageType`.
      _initializeStorage: function(options){
        var storage;
  
        var StorageType = options.storageType || this.storageType;
        if (_.isFunction(StorageType)){
          storage = new StorageType();
        } else {
          storage = StorageType;
        }
  
        this.storage = storage;
      }
    });
  
  })(Wreqr, _);
  
  // Wreqr.RequestResponse
  // ---------------------
  //
  // A simple request/response implementation. Register a
  // request handler, and return a response from it
  Wreqr.RequestResponse = (function(Wreqr, _){
    "use strict";
  
    return Wreqr.Handlers.extend({
      request: function(name){
        if (this.hasHandler(name)) {
          return this.getHandler(name).apply(this, _.rest(arguments));
        }
      }
    });
  
  })(Wreqr, _);
  
  // Event Aggregator
  // ----------------
  // A pub-sub object that can be used to decouple various parts
  // of an application through event-driven architecture.
  
  Wreqr.EventAggregator = (function(Backbone, _){
    "use strict";
    var EA = function(){};
  
    // Copy the `extend` function used by Backbone's classes
    EA.extend = Backbone.Model.extend;
  
    // Copy the basic Backbone.Events on to the event aggregator
    _.extend(EA.prototype, Backbone.Events);
  
    return EA;
  })(Backbone, _);
  
  // Wreqr.Channel
  // --------------
  //
  // An object that wraps the three messaging systems:
  // EventAggregator, RequestResponse, Commands
  Wreqr.Channel = (function(Wreqr){
    "use strict";
  
    var Channel = function(channelName) {
      this.vent        = new Backbone.Wreqr.EventAggregator();
      this.reqres      = new Backbone.Wreqr.RequestResponse();
      this.commands    = new Backbone.Wreqr.Commands();
      this.channelName = channelName;
    };
  
    _.extend(Channel.prototype, {
  
      // Remove all handlers from the messaging systems of this channel
      reset: function() {
        this.vent.off();
        this.vent.stopListening();
        this.reqres.removeAllHandlers();
        this.commands.removeAllHandlers();
        return this;
      },
  
      // Connect a hash of events; one for each messaging system
      connectEvents: function(hash, context) {
        this._connect('vent', hash, context);
        return this;
      },
  
      connectCommands: function(hash, context) {
        this._connect('commands', hash, context);
        return this;
      },
  
      connectRequests: function(hash, context) {
        this._connect('reqres', hash, context);
        return this;
      },
  
      // Attach the handlers to a given message system `type`
      _connect: function(type, hash, context) {
        if (!hash) {
          return;
        }
  
        context = context || this;
        var method = (type === 'vent') ? 'on' : 'setHandler';
  
        _.each(hash, _.bind(function(fn, eventName) {
          this[type][method](eventName, _.bind(fn, context));
        }, this));
      }
    });
  
  
    return Channel;
  })(Wreqr);
  
  // Wreqr.Radio
  // --------------
  //
  // An object that lets you communicate with many channels.
  Wreqr.radio = (function(Wreqr, _){
    "use strict";
  
    var Radio = function() {
      this._channels = {};
      this.vent = {};
      this.commands = {};
      this.reqres = {};
      this._proxyMethods();
    };
  
    _.extend(Radio.prototype, {
  
      channel: function(channelName) {
        if (!channelName) {
          throw new Error('Channel must receive a name');
        }
  
        return this._getChannel( channelName );
      },
  
      _getChannel: function(channelName) {
        var channel = this._channels[channelName];
  
        if(!channel) {
          channel = new Wreqr.Channel(channelName);
          this._channels[channelName] = channel;
        }
  
        return channel;
      },
  
      _proxyMethods: function() {
        _.each(['vent', 'commands', 'reqres'], _.bind(function(system) {
          _.each( messageSystems[system], _.bind(function(method) {
            this[system][method] = proxyMethod(this, system, method);
          }, this));
        }, this));
      }
    });
  
  
    var messageSystems = {
      vent: [
        'on',
        'off',
        'trigger',
        'once',
        'stopListening',
        'listenTo',
        'listenToOnce'
      ],
  
      commands: [
        'execute',
        'setHandler',
        'setHandlers',
        'removeHandler',
        'removeAllHandlers'
      ],
  
      reqres: [
        'request',
        'setHandler',
        'setHandlers',
        'removeHandler',
        'removeAllHandlers'
      ]
    };
  
    var proxyMethod = function(radio, system, method) {
      return function(channelName) {
        var messageSystem = radio._getChannel(channelName)[system];
  
        return messageSystem[method].apply(messageSystem, _.rest(arguments));
      };
    };
  
    return new Radio();
  
  })(Wreqr, _);
  

  return Backbone.Wreqr;

}));

},{"backbone":5,"underscore":104}],5:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

},{"underscore":104}],6:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],7:[function(require,module,exports){

},{}],8:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],9:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)
},{"base64-js":6,"buffer":10,"ieee754":16}],11:[function(require,module,exports){
module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}

},{}],12:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../insert-module-globals/node_modules/is-buffer/index.js")})
},{"../../insert-module-globals/node_modules/is-buffer/index.js":18}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
(function() {
  var Google, Q;

  Q = require('q');

  Google = (function() {
    function Google() {}

    Google.URL = 'https://maps.googleapis.com/maps/api/js?sensor=false';

    Google.KEY = null;

    Google.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';

    Google.google = null;

    Google.loading = false;

    Google.promises = [];

    Google.load = function() {
      var deferred, script, url,
        _this = this;
      deferred = Q.defer();
      if (this.google === null) {
        if (this.loading === true) {
          this.promises.push(deferred);
        } else {
          this.loading = true;
          window[this.WINDOW_CALLBACK_NAME] = function() {
            return _this._ready(deferred);
          };
          url = this.URL;
          if (this.KEY !== null) {
            url += "&key=" + this.KEY;
          }
          url += "&callback=" + this.WINDOW_CALLBACK_NAME;
          script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          document.body.appendChild(script);
        }
      } else {
        deferred.resolve(this.google);
      }
      return deferred.promise;
    };

    Google._ready = function(deferred) {
      var def, _i, _len, _ref;
      Google.loading = false;
      if (Google.google === null) {
        Google.google = window.google;
      }
      deferred.resolve(Google.google);
      _ref = Google.promises;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        def = _ref[_i];
        def.resolve(Google.google);
      }
      return Google.promises = [];
    };

    return Google;

  }).call(this);

  module.exports = Google;

}).call(this);

},{"q":61}],15:[function(require,module,exports){
var http = require('http')
var url = require('url')

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}

},{"http":83,"url":105}],16:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],17:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],18:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],19:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

;(function(root) {
'use strict';

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
  nptable: noop,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  table: noop,
  lheading: /^([^\n]+)\n {0,3}(=|-){2,} *(?:\n+|$)/,
  paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d{1,9}\.)/;
block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?-->/;
block.html = edit(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit(block.paragraph)
  .replace('hr', block.hr)
  .replace('heading', block.heading)
  .replace('lheading', block.lheading)
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ {0,3}(`{3,}|~{3,})([^`\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = edit(block.paragraph)
  .replace('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  .getRegex();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
  table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
});

/**
 * Pedantic grammar
 */

block.pedantic = merge({}, block.normal, {
  html: edit(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = Object.create(null);
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.pedantic) {
    this.rules = block.pedantic;
  } else if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      listStart,
      listItems,
      t,
      space,
      i,
      tag,
      l,
      isordered,
      istask,
      ischecked;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      var lastToken = this.tokens[this.tokens.length - 1];
      src = src.substring(cap[0].length);
      // An indented code block cannot interrupt a paragraph.
      if (lastToken && lastToken.type === 'paragraph') {
        lastToken.text += '\n' + cap[0].trimRight();
      } else {
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          codeBlockStyle: 'indented',
          text: !this.options.pedantic
            ? rtrim(cap, '\n')
            : cap
        });
      }
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2] ? cap[2].trim() : cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (cap = this.rules.nptable.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(item.cells[i], item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      listStart = {
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : '',
        loose: false
      };

      this.tokens.push(listStart);

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      listItems = [];
      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) */, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull.length > 1 ? b.length === 1
            : (b.length > 1 || (this.options.smartLists && b !== bull))) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        if (loose) {
          listStart.loose = true;
        }

        // Check for task list items
        istask = /^\[[ xX]\] /.test(item);
        ischecked = undefined;
        if (istask) {
          ischecked = item[1] !== ' ';
          item = item.replace(/^\[[ xX]\] +/, '');
        }

        t = {
          type: 'list_item_start',
          task: istask,
          checked: ischecked,
          loose: loose
        };

        listItems.push(t);
        this.tokens.push(t);

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      if (listStart.loose) {
        l = listItems.length;
        i = 0;
        for (; i < l; i++) {
          listItems[i].loose = true;
        }
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (cap = this.rules.table.exec(src)) {
      item = {
        type: 'table',
        header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        src = src.substring(cap[0].length);

        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = splitCells(
            item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
            item.header.length);
        }

        this.tokens.push(item);

        continue;
      }
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
  strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
  em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noop,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
};

// list of punctuation marks from common mark spec
// without ` and ] to workaround Rule 17 (inline code blocks/links)
inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit(inline.tag)
  .replace('comment', block._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|`(?!`)|[^\[\]\\`])*?/;
inline._href = /\s*(<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*)/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~+(?=\S)([\s\S]*?\S)~+/,
  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
});

inline.gfm.url = edit(inline.gfm.url, 'i')
  .replace('email', inline.gfm._extended_email)
  .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text)
    .replace('\\b_', '\\b_| {2,}\\n')
    .replace(/\{2,\}/g, '*')
    .getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.pedantic) {
    this.rules = inline.pedantic;
  } else if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      title,
      cap,
      prevCapZero;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[1]);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = true;
      } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.inRawBlock = false;
      }

      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      var lastParenIndex = findClosingBracket(cap[2], '()');
      if (lastParenIndex > -1) {
        var linkLen = cap[0].length - (cap[2].length - lastParenIndex) - (cap[3] || '').length;
        cap[2] = cap[2].substring(0, lastParenIndex);
        cap[0] = cap[0].substring(0, linkLen).trim();
        cap[3] = '';
      }
      src = src.substring(cap[0].length);
      this.inLink = true;
      href = cap[2];
      if (this.options.pedantic) {
        link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) {
          href = link[1];
          title = link[3];
        } else {
          title = '';
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
      out += this.outputLink(cap, {
        href: InlineLexer.escapes(href),
        title: InlineLexer.escapes(title)
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      src = src.substring(cap[0].length);
      out += this.renderer.link(href, null, text);
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      if (this.inRawBlock) {
        out += this.renderer.text(cap[0]);
      } else {
        out += this.renderer.text(escape(this.smartypants(cap[0])));
      }
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

InlineLexer.escapes = function(text) {
  return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = link.href,
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || marked.defaults;
}

Renderer.prototype.code = function(code, infostring, escaped) {
  var lang = (infostring || '').match(/\S*/)[0];
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw, slugger) {
  if (this.options.headerIds) {
    return '<h'
      + level
      + ' id="'
      + this.options.headerPrefix
      + slugger.slug(raw)
      + '">'
      + text
      + '</h'
      + level
      + '>\n';
  }
  // ignore IDs
  return '<h' + level + '>' + text + '</h' + level + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.checkbox = function(checked) {
  return '<input '
    + (checked ? 'checked="" ' : '')
    + 'disabled="" type="checkbox"'
    + (this.options.xhtml ? ' /' : '')
    + '> ';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  if (body) body = '<tbody>' + body + '</tbody>';

  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + body
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' align="' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }
  var out = '<a href="' + escape(href) + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
  if (href === null) {
    return text;
  }

  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function(text) {
  return text;
};

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
};

TextRenderer.prototype.br = function() {
  return '';
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
  this.slugger = new Slugger();
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, { renderer: new TextRenderer() })
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  this.token = this.tokens.pop();
  return this.token;
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)),
        this.slugger);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';
      var loose = this.token.loose;
      var checked = this.token.checked;
      var task = this.token.task;

      if (this.token.task) {
        body += this.renderer.checkbox(checked);
      }

      while (this.next().type !== 'list_item_end') {
        body += !loose && this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }
      return this.renderer.listitem(body, task, checked);
    }
    case 'html': {
      // TODO parse inline content if parameter markdown=1
      return this.renderer.html(this.token.text);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
    default: {
      var errMsg = 'Token with "' + this.token.type + '" type was not found.';
      if (this.options.silent) {
        console.log(errMsg);
      } else {
        throw new Error(errMsg);
      }
    }
  }
};

/**
 * Slugger generates header id
 */

function Slugger() {
  this.seen = {};
}

/**
 * Convert string to unique id
 */

Slugger.prototype.slug = function(value) {
  var slug = value
    .toLowerCase()
    .trim()
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
    .replace(/\s/g, '-');

  if (this.seen.hasOwnProperty(slug)) {
    var originalSlug = slug;
    do {
      this.seen[originalSlug]++;
      slug = originalSlug + '-' + this.seen[originalSlug];
    } while (this.seen.hasOwnProperty(slug));
  }
  this.seen[slug] = 0;

  return slug;
};

/**
 * Helpers
 */

function escape(html, encode) {
  if (encode) {
    if (escape.escapeTest.test(html)) {
      return html.replace(escape.escapeReplace, function(ch) { return escape.replacements[ch]; });
    }
  } else {
    if (escape.escapeTestNoEncode.test(html)) {
      return html.replace(escape.escapeReplaceNoEncode, function(ch) { return escape.replacements[ch]; });
    }
  }

  return html;
}

escape.escapeTest = /[&<>"']/;
escape.escapeReplace = /[&<>"']/g;
escape.replacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};

escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  var row = tableRow.replace(/\|/g, function(match, offset, str) {
        var escaped = false,
            curr = offset;
        while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
        if (escaped) {
          // odd number of slashes means | is escaped
          // so we leave it alone
          return '|';
        } else {
          // add space before unescaped |
          return ' |';
        }
      }),
      cells = row.split(/ \|/),
      i = 0;

  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push('');
  }

  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
// /c*$/ is vulnerable to REDOS.
// invert: Remove suffix of non-c chars instead. Default falsey.
function rtrim(str, c, invert) {
  if (str.length === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  var suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < str.length) {
    var currChar = str.charAt(str.length - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }

  return str.substr(0, str.length - suffLen);
}

function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  var level = 0;
  for (var i = 0; i < str.length; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.getDefaults = function() {
  return {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tables: true,
    xhtml: false
  };
};

marked.defaults = marked.getDefaults();

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.Slugger = Slugger;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  root.marked = marked;
}
})(this || (typeof window !== 'undefined' ? window : global));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],20:[function(require,module,exports){
(function (process,__dirname){
var path = require('path');
var fs = require('fs');

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];

    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts]) {
        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {

  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Load local copy of
// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
mime.load(path.join(__dirname, 'types/mime.types'));

// Load additional types from node.js community
mime.load(path.join(__dirname, 'types/node.types'));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;

}).call(this,require('_process'),"/node_modules/mime")
},{"_process":23,"fs":8,"path":21}],21:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":23}],22:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":23}],23:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],24:[function(require,module,exports){
(function (Buffer){
var util = require('util');
var Stream = require('stream').Stream;
var DelayedStream = require('delayed-stream');

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

}).call(this,{"isBuffer":require("../../../../insert-module-globals/node_modules/is-buffer/index.js")})
},{"../../../../insert-module-globals/node_modules/is-buffer/index.js":18,"delayed-stream":25,"stream":82,"util":110}],25:[function(require,module,exports){
var Stream = require('stream').Stream;
var util = require('util');

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

DelayedStream.prototype.__defineGetter__('readable', function() {
  return this.source.readable;
});

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};

},{"stream":82,"util":110}],26:[function(require,module,exports){
(function (process,Buffer){
var CombinedStream = require('combined-stream');
var util = require('util');
var path = require('path');
var http = require('http');
var https = require('https');
var parseUrl = require('url').parse;
var fs = require('fs');
var mime = require('mime');
var async = require('async');

module.exports = FormData;
function FormData() {
  this._overheadLength = 0;
  this._valueLength = 0;
  this._lengthRetrievers = [];

  CombinedStream.call(this);
}
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';

FormData.prototype.append = function(field, value, options) {
  options = options || {};

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') value = ''+value;

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter(field, value, options);

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength)
  this._lengthRetrievers.push(function(next) {

    if (value.hasOwnProperty('fd')) {

      // take read range into a account
      // `end` = Infinity –> read file till the end
      //
      // TODO: Looks like there is bug in Node fs.createReadStream
      // it doesn't respect `end` options without `start` options
      // Fix it when node fixes it.
      // https://github.com/joyent/node/issues/7819
      if (value.end != undefined && value.end != Infinity && value.start != undefined) {

        // when end specified
        // no need to calculate range
        // inclusive, starts with 0
        next(null, value.end+1 - (value.start ? value.start : 0));

      // not that fast snoopy
      } else {
        // still need to fetch file size from fs
        fs.stat(value.path, function(err, stat) {

          var fileSize;

          if (err) {
            next(err);
            return;
          }

          // update final size based on the range options
          fileSize = stat.size - (value.start ? value.start : 0);
          next(null, fileSize);
        });
      }

    // or http response
    } else if (value.hasOwnProperty('httpVersion')) {
      next(null, +value.headers['content-length']);

    // or request stream http://github.com/mikeal/request
    } else if (value.hasOwnProperty('httpModule')) {
      // wait till response come back
      value.on('response', function(response) {
        value.pause();
        next(null, +response.headers['content-length']);
      });
      value.resume();

    // something else
    } else {
      next('Unknown stream');
    }
  });
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  var boundary = this.getBoundary();
  var header = '';

  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (options.header != null) {
    header = options.header;
  } else {
    header += '--' + boundary + FormData.LINE_BREAK +
      'Content-Disposition: form-data; name="' + field + '"';

    // fs- and request- streams have path property
    // or use custom filename and/or contentType
    // TODO: Use request's response mime-type
    if (options.filename || value.path) {
      header +=
        '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));

    // http response has not
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
      header +=
        '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' + value.headers['content-type'];
    }

    header += FormData.LINE_BREAK + FormData.LINE_BREAK;
  }

  return header;
};

FormData.prototype._multiPartFooter = function(field, value, options) {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--';
};

FormData.prototype.getHeaders = function(userHeaders) {
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (var header in userHeaders) {
    formHeaders[header.toLowerCase()] = userHeaders[header];
  }

  return formHeaders;
}

FormData.prototype.getCustomHeaders = function(contentType) {
    contentType = contentType ? contentType : 'multipart/form-data';

    var formHeaders = {
        'content-type': contentType + '; boundary=' + this.getBoundary(),
        'content-length': this.getLengthSync()
    };

    return formHeaders;
}

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function(debug) {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/felixge/node-form-data/issues/40
  if (this._lengthRetrievers.length) {
    // Some async length retrivers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._lengthRetrievers.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  async.parallel(this._lengthRetrievers, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {

  var request
    , options
    , defaults = {
        method : 'post'
    };

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {
    params = parseUrl(params);

    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname
    }, defaults);
  }
  else // use custom params
  {
    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (params.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {

    // TODO: Add chunked encoding when no length (if err)

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (this.error) return;

  this.error = err;
  this.pause();
  this.emit('error', err);
};

/*
 * Santa's little helpers
 */

// populates missing values
function populate(dst, src) {
  for (var prop in src) {
    if (!dst[prop]) dst[prop] = src[prop];
  }
  return dst;
}

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":23,"async":1,"buffer":10,"combined-stream":24,"fs":8,"http":83,"https":15,"mime":20,"path":21,"url":105,"util":110}],27:[function(require,module,exports){
/*! Socket.IO.js build:0.9.17, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */

var io = ('undefined' === typeof module ? {} : module.exports);
(function() {

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * IO namespace.
   *
   * @namespace
   */

  var io = exports;

  /**
   * Socket.IO version
   *
   * @api public
   */

  io.version = '0.9.17';

  /**
   * Protocol implemented.
   *
   * @api public
   */

  io.protocol = 1;

  /**
   * Available transports, these will be populated with the available transports
   *
   * @api public
   */

  io.transports = [];

  /**
   * Keep track of jsonp callbacks.
   *
   * @api private
   */

  io.j = [];

  /**
   * Keep track of our io.Sockets
   *
   * @api private
   */
  io.sockets = {};


  /**
   * Manages connections to hosts.
   *
   * @param {String} uri
   * @Param {Boolean} force creation of new socket (defaults to false)
   * @api public
   */

  io.connect = function (host, details) {
    var uri = io.util.parseUri(host)
      , uuri
      , socket;

    if (global && global.location) {
      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);
      uri.host = uri.host || (global.document
        ? global.document.domain : global.location.hostname);
      uri.port = uri.port || global.location.port;
    }

    uuri = io.util.uniqueUri(uri);

    var options = {
        host: uri.host
      , secure: 'https' == uri.protocol
      , port: uri.port || ('https' == uri.protocol ? 443 : 80)
      , query: uri.query || ''
    };

    io.util.merge(options, details);

    if (options['force new connection'] || !io.sockets[uuri]) {
      socket = new io.Socket(options);
    }

    if (!options['force new connection'] && socket) {
      io.sockets[uuri] = socket;
    }

    socket = socket || io.sockets[uuri];

    // if path is different from '' or /
    return socket.of(uri.path.length > 1 ? uri.path : '');
  };

})('object' === typeof module ? module.exports : (this.io = {}), this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, global) {

  /**
   * Utilities namespace.
   *
   * @namespace
   */

  var util = exports.util = {};

  /**
   * Parses an URI
   *
   * @author Steven Levithan <stevenlevithan.com> (MIT license)
   * @api public
   */

  var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',
               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',
               'anchor'];

  util.parseUri = function (str) {
    var m = re.exec(str || '')
      , uri = {}
      , i = 14;

    while (i--) {
      uri[parts[i]] = m[i] || '';
    }

    return uri;
  };

  /**
   * Produces a unique url that identifies a Socket.IO connection.
   *
   * @param {Object} uri
   * @api public
   */

  util.uniqueUri = function (uri) {
    var protocol = uri.protocol
      , host = uri.host
      , port = uri.port;

    if ('document' in global) {
      host = host || document.domain;
      port = port || (protocol == 'https'
        && document.location.protocol !== 'https:' ? 443 : document.location.port);
    } else {
      host = host || 'localhost';

      if (!port && protocol == 'https') {
        port = 443;
      }
    }

    return (protocol || 'http') + '://' + host + ':' + (port || 80);
  };

  /**
   * Mergest 2 query strings in to once unique query string
   *
   * @param {String} base
   * @param {String} addition
   * @api public
   */

  util.query = function (base, addition) {
    var query = util.chunkQuery(base || '')
      , components = [];

    util.merge(query, util.chunkQuery(addition || ''));
    for (var part in query) {
      if (query.hasOwnProperty(part)) {
        components.push(part + '=' + query[part]);
      }
    }

    return components.length ? '?' + components.join('&') : '';
  };

  /**
   * Transforms a querystring in to an object
   *
   * @param {String} qs
   * @api public
   */

  util.chunkQuery = function (qs) {
    var query = {}
      , params = qs.split('&')
      , i = 0
      , l = params.length
      , kv;

    for (; i < l; ++i) {
      kv = params[i].split('=');
      if (kv[0]) {
        query[kv[0]] = kv[1];
      }
    }

    return query;
  };

  /**
   * Executes the given function when the page is loaded.
   *
   *     io.util.load(function () { console.log('page loaded'); });
   *
   * @param {Function} fn
   * @api public
   */

  var pageLoaded = false;

  util.load = function (fn) {
    if ('document' in global && document.readyState === 'complete' || pageLoaded) {
      return fn();
    }

    util.on(global, 'load', fn, false);
  };

  /**
   * Adds an event.
   *
   * @api private
   */

  util.on = function (element, event, fn, capture) {
    if (element.attachEvent) {
      element.attachEvent('on' + event, fn);
    } else if (element.addEventListener) {
      element.addEventListener(event, fn, capture);
    }
  };

  /**
   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
   *
   * @param {Boolean} [xdomain] Create a request that can be used cross domain.
   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
   * @api private
   */

  util.request = function (xdomain) {

    if (xdomain && 'undefined' != typeof XDomainRequest && !util.ua.hasCORS) {
      return new XDomainRequest();
    }

    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {
      return new XMLHttpRequest();
    }

    if (!xdomain) {
      try {
        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');
      } catch(e) { }
    }

    return null;
  };

  /**
   * XHR based transport constructor.
   *
   * @constructor
   * @api public
   */

  /**
   * Change the internal pageLoaded value.
   */

  if ('undefined' != typeof window) {
    util.load(function () {
      pageLoaded = true;
    });
  }

  /**
   * Defers a function to ensure a spinner is not displayed by the browser
   *
   * @param {Function} fn
   * @api public
   */

  util.defer = function (fn) {
    if (!util.ua.webkit || 'undefined' != typeof importScripts) {
      return fn();
    }

    util.load(function () {
      setTimeout(fn, 100);
    });
  };

  /**
   * Merges two objects.
   *
   * @api public
   */

  util.merge = function merge (target, additional, deep, lastseen) {
    var seen = lastseen || []
      , depth = typeof deep == 'undefined' ? 2 : deep
      , prop;

    for (prop in additional) {
      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {
        if (typeof target[prop] !== 'object' || !depth) {
          target[prop] = additional[prop];
          seen.push(additional[prop]);
        } else {
          util.merge(target[prop], additional[prop], depth - 1, seen);
        }
      }
    }

    return target;
  };

  /**
   * Merges prototypes from objects
   *
   * @api public
   */

  util.mixin = function (ctor, ctor2) {
    util.merge(ctor.prototype, ctor2.prototype);
  };

  /**
   * Shortcut for prototypical and static inheritance.
   *
   * @api private
   */

  util.inherit = function (ctor, ctor2) {
    function f() {};
    f.prototype = ctor2.prototype;
    ctor.prototype = new f;
  };

  /**
   * Checks if the given object is an Array.
   *
   *     io.util.isArray([]); // true
   *     io.util.isArray({}); // false
   *
   * @param Object obj
   * @api public
   */

  util.isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  /**
   * Intersects values of two arrays into a third
   *
   * @api public
   */

  util.intersect = function (arr, arr2) {
    var ret = []
      , longest = arr.length > arr2.length ? arr : arr2
      , shortest = arr.length > arr2.length ? arr2 : arr;

    for (var i = 0, l = shortest.length; i < l; i++) {
      if (~util.indexOf(longest, shortest[i]))
        ret.push(shortest[i]);
    }

    return ret;
  };

  /**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */

  util.indexOf = function (arr, o, i) {

    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0;
         i < j && arr[i] !== o; i++) {}

    return j <= i ? -1 : i;
  };

  /**
   * Converts enumerables to array.
   *
   * @api public
   */

  util.toArray = function (enu) {
    var arr = [];

    for (var i = 0, l = enu.length; i < l; i++)
      arr.push(enu[i]);

    return arr;
  };

  /**
   * UA / engines detection namespace.
   *
   * @namespace
   */

  util.ua = {};

  /**
   * Whether the UA supports CORS for XHR.
   *
   * @api public
   */

  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {
    try {
      var a = new XMLHttpRequest();
    } catch (e) {
      return false;
    }

    return a.withCredentials != undefined;
  })();

  /**
   * Detect webkit.
   *
   * @api public
   */

  util.ua.webkit = 'undefined' != typeof navigator
    && /webkit/i.test(navigator.userAgent);

   /**
   * Detect iPad/iPhone/iPod.
   *
   * @api public
   */

  util.ua.iDevice = 'undefined' != typeof navigator
      && /iPad|iPhone|iPod/i.test(navigator.userAgent);

})('undefined' != typeof io ? io : module.exports, this);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.EventEmitter = EventEmitter;

  /**
   * Event emitter constructor.
   *
   * @api public.
   */

  function EventEmitter () {};

  /**
   * Adds a listener
   *
   * @api public
   */

  EventEmitter.prototype.on = function (name, fn) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = fn;
    } else if (io.util.isArray(this.$events[name])) {
      this.$events[name].push(fn);
    } else {
      this.$events[name] = [this.$events[name], fn];
    }

    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  /**
   * Adds a volatile listener.
   *
   * @api public
   */

  EventEmitter.prototype.once = function (name, fn) {
    var self = this;

    function on () {
      self.removeListener(name, on);
      fn.apply(this, arguments);
    };

    on.listener = fn;
    this.on(name, on);

    return this;
  };

  /**
   * Removes a listener.
   *
   * @api public
   */

  EventEmitter.prototype.removeListener = function (name, fn) {
    if (this.$events && this.$events[name]) {
      var list = this.$events[name];

      if (io.util.isArray(list)) {
        var pos = -1;

        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {
            pos = i;
            break;
          }
        }

        if (pos < 0) {
          return this;
        }

        list.splice(pos, 1);

        if (!list.length) {
          delete this.$events[name];
        }
      } else if (list === fn || (list.listener && list.listener === fn)) {
        delete this.$events[name];
      }
    }

    return this;
  };

  /**
   * Removes all listeners for an event.
   *
   * @api public
   */

  EventEmitter.prototype.removeAllListeners = function (name) {
    if (name === undefined) {
      this.$events = {};
      return this;
    }

    if (this.$events && this.$events[name]) {
      this.$events[name] = null;
    }

    return this;
  };

  /**
   * Gets all listeners for a certain event.
   *
   * @api publci
   */

  EventEmitter.prototype.listeners = function (name) {
    if (!this.$events) {
      this.$events = {};
    }

    if (!this.$events[name]) {
      this.$events[name] = [];
    }

    if (!io.util.isArray(this.$events[name])) {
      this.$events[name] = [this.$events[name]];
    }

    return this.$events[name];
  };

  /**
   * Emits an event.
   *
   * @api public
   */

  EventEmitter.prototype.emit = function (name) {
    if (!this.$events) {
      return false;
    }

    var handler = this.$events[name];

    if (!handler) {
      return false;
    }

    var args = Array.prototype.slice.call(arguments, 1);

    if ('function' == typeof handler) {
      handler.apply(this, args);
    } else if (io.util.isArray(handler)) {
      var listeners = handler.slice();

      for (var i = 0, l = listeners.length; i < l; i++) {
        listeners[i].apply(this, args);
      }
    } else {
      return false;
    }

    return true;
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Based on JSON2 (http://www.JSON.org/js.html).
 */

(function (exports, nativeJSON) {
  "use strict";

  // use native JSON if it's available
  if (nativeJSON && nativeJSON.parse){
    return exports.JSON = {
      parse: nativeJSON.parse
    , stringify: nativeJSON.stringify
    };
  }

  var JSON = exports.JSON = {};

  function f(n) {
      // Format integers to have at least two digits.
      return n < 10 ? '0' + n : n;
  }

  function date(d, key) {
    return isFinite(d.valueOf()) ?
        d.getUTCFullYear()     + '-' +
        f(d.getUTCMonth() + 1) + '-' +
        f(d.getUTCDate())      + 'T' +
        f(d.getUTCHours())     + ':' +
        f(d.getUTCMinutes())   + ':' +
        f(d.getUTCSeconds())   + 'Z' : null;
  };

  var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
      gap,
      indent,
      meta = {    // table of character substitutions
          '\b': '\\b',
          '\t': '\\t',
          '\n': '\\n',
          '\f': '\\f',
          '\r': '\\r',
          '"' : '\\"',
          '\\': '\\\\'
      },
      rep;


  function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
          var c = meta[a];
          return typeof c === 'string' ? c :
              '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
  }


  function str(key, holder) {

// Produce a string from holder[key].

      var i,          // The loop counter.
          k,          // The member key.
          v,          // The member value.
          length,
          mind = gap,
          partial,
          value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

      if (value instanceof Date) {
          value = date(key);
      }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

      if (typeof rep === 'function') {
          value = rep.call(holder, key, value);
      }

// What happens next depends on the value's type.

      switch (typeof value) {
      case 'string':
          return quote(value);

      case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

          return isFinite(value) ? String(value) : 'null';

      case 'boolean':
      case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

          return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

      case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

          if (!value) {
              return 'null';
          }

// Make an array to hold the partial results of stringifying this object value.

          gap += indent;
          partial = [];

// Is the value an array?

          if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

              length = value.length;
              for (i = 0; i < length; i += 1) {
                  partial[i] = str(i, value) || 'null';
              }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

              v = partial.length === 0 ? '[]' : gap ?
                  '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                  '[' + partial.join(',') + ']';
              gap = mind;
              return v;
          }

// If the replacer is an array, use it to select the members to be stringified.

          if (rep && typeof rep === 'object') {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                  if (typeof rep[i] === 'string') {
                      k = rep[i];
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          } else {

// Otherwise, iterate through all of the keys in the object.

              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = str(k, value);
                      if (v) {
                          partial.push(quote(k) + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

          v = partial.length === 0 ? '{}' : gap ?
              '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
              '{' + partial.join(',') + '}';
          gap = mind;
          return v;
      }
  }

// If the JSON object does not yet have a stringify method, give it one.

  JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

      var i;
      gap = '';
      indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

      if (typeof space === 'number') {
          for (i = 0; i < space; i += 1) {
              indent += ' ';
          }

// If the space parameter is a string, it will be used as the indent string.

      } else if (typeof space === 'string') {
          indent = space;
      }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

      rep = replacer;
      if (replacer && typeof replacer !== 'function' &&
              (typeof replacer !== 'object' ||
              typeof replacer.length !== 'number')) {
          throw new Error('JSON.stringify');
      }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

      return str('', {'': value});
  };

// If the JSON object does not yet have a parse method, give it one.

  JSON.parse = function (text, reviver) {
  // The parse method takes a text and an optional reviver function, and returns
  // a JavaScript value if the text is a valid JSON text.

      var j;

      function walk(holder, key) {

  // The walk method is used to recursively walk the resulting structure so
  // that modifications can be made.

          var k, v, value = holder[key];
          if (value && typeof value === 'object') {
              for (k in value) {
                  if (Object.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      if (v !== undefined) {
                          value[k] = v;
                      } else {
                          delete value[k];
                      }
                  }
              }
          }
          return reviver.call(holder, key, value);
      }


  // Parsing happens in four stages. In the first stage, we replace certain
  // Unicode characters with escape sequences. JavaScript handles many characters
  // incorrectly, either silently deleting them, or treating them as line endings.

      text = String(text);
      cx.lastIndex = 0;
      if (cx.test(text)) {
          text = text.replace(cx, function (a) {
              return '\\u' +
                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
          });
      }

  // In the second stage, we run the text against regular expressions that look
  // for non-JSON patterns. We are especially concerned with '()' and 'new'
  // because they can cause invocation, and '=' because it can cause mutation.
  // But just to be safe, we want to reject all unexpected forms.

  // We split the second stage into 4 regexp operations in order to work around
  // crippling inefficiencies in IE's and Safari's regexp engines. First we
  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
  // replace all simple value tokens with ']' characters. Third, we delete all
  // open brackets that follow a colon or comma or that begin the text. Finally,
  // we look to see that the remaining characters are only whitespace or ']' or
  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

      if (/^[\],:{}\s]*$/
              .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                  .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                  .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

  // In the third stage we use the eval function to compile the text into a
  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
  // in JavaScript: it can begin a block or an object literal. We wrap the text
  // in parens to eliminate the ambiguity.

          j = eval('(' + text + ')');

  // In the optional fourth stage, we recursively walk the new structure, passing
  // each name/value pair to a reviver function for possible transformation.

          return typeof reviver === 'function' ?
              walk({'': j}, '') : j;
      }

  // If the text is not JSON parseable, then a SyntaxError is thrown.

      throw new SyntaxError('JSON.parse');
  };

})(
    'undefined' != typeof io ? io : module.exports
  , typeof JSON !== 'undefined' ? JSON : undefined
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Parser namespace.
   *
   * @namespace
   */

  var parser = exports.parser = {};

  /**
   * Packet types.
   */

  var packets = parser.packets = [
      'disconnect'
    , 'connect'
    , 'heartbeat'
    , 'message'
    , 'json'
    , 'event'
    , 'ack'
    , 'error'
    , 'noop'
  ];

  /**
   * Errors reasons.
   */

  var reasons = parser.reasons = [
      'transport not supported'
    , 'client not handshaken'
    , 'unauthorized'
  ];

  /**
   * Errors advice.
   */

  var advice = parser.advice = [
      'reconnect'
  ];

  /**
   * Shortcuts.
   */

  var JSON = io.JSON
    , indexOf = io.util.indexOf;

  /**
   * Encodes a packet.
   *
   * @api private
   */

  parser.encodePacket = function (packet) {
    var type = indexOf(packets, packet.type)
      , id = packet.id || ''
      , endpoint = packet.endpoint || ''
      , ack = packet.ack
      , data = null;

    switch (packet.type) {
      case 'error':
        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''
          , adv = packet.advice ? indexOf(advice, packet.advice) : '';

        if (reason !== '' || adv !== '')
          data = reason + (adv !== '' ? ('+' + adv) : '');

        break;

      case 'message':
        if (packet.data !== '')
          data = packet.data;
        break;

      case 'event':
        var ev = { name: packet.name };

        if (packet.args && packet.args.length) {
          ev.args = packet.args;
        }

        data = JSON.stringify(ev);
        break;

      case 'json':
        data = JSON.stringify(packet.data);
        break;

      case 'connect':
        if (packet.qs)
          data = packet.qs;
        break;

      case 'ack':
        data = packet.ackId
          + (packet.args && packet.args.length
              ? '+' + JSON.stringify(packet.args) : '');
        break;
    }

    // construct packet with required fragments
    var encoded = [
        type
      , id + (ack == 'data' ? '+' : '')
      , endpoint
    ];

    // data fragment is optional
    if (data !== null && data !== undefined)
      encoded.push(data);

    return encoded.join(':');
  };

  /**
   * Encodes multiple messages (payload).
   *
   * @param {Array} messages
   * @api private
   */

  parser.encodePayload = function (packets) {
    var decoded = '';

    if (packets.length == 1)
      return packets[0];

    for (var i = 0, l = packets.length; i < l; i++) {
      var packet = packets[i];
      decoded += '\ufffd' + packet.length + '\ufffd' + packets[i];
    }

    return decoded;
  };

  /**
   * Decodes a packet
   *
   * @api private
   */

  var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;

  parser.decodePacket = function (data) {
    var pieces = data.match(regexp);

    if (!pieces) return {};

    var id = pieces[2] || ''
      , data = pieces[5] || ''
      , packet = {
            type: packets[pieces[1]]
          , endpoint: pieces[4] || ''
        };

    // whether we need to acknowledge the packet
    if (id) {
      packet.id = id;
      if (pieces[3])
        packet.ack = 'data';
      else
        packet.ack = true;
    }

    // handle different packet types
    switch (packet.type) {
      case 'error':
        var pieces = data.split('+');
        packet.reason = reasons[pieces[0]] || '';
        packet.advice = advice[pieces[1]] || '';
        break;

      case 'message':
        packet.data = data || '';
        break;

      case 'event':
        try {
          var opts = JSON.parse(data);
          packet.name = opts.name;
          packet.args = opts.args;
        } catch (e) { }

        packet.args = packet.args || [];
        break;

      case 'json':
        try {
          packet.data = JSON.parse(data);
        } catch (e) { }
        break;

      case 'connect':
        packet.qs = data || '';
        break;

      case 'ack':
        var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
        if (pieces) {
          packet.ackId = pieces[1];
          packet.args = [];

          if (pieces[3]) {
            try {
              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
            } catch (e) { }
          }
        }
        break;

      case 'disconnect':
      case 'heartbeat':
        break;
    };

    return packet;
  };

  /**
   * Decodes data payload. Detects multiple messages
   *
   * @return {Array} messages
   * @api public
   */

  parser.decodePayload = function (data) {
    // IE doesn't like data[i] for unicode chars, charAt works fine
    if (data.charAt(0) == '\ufffd') {
      var ret = [];

      for (var i = 1, length = ''; i < data.length; i++) {
        if (data.charAt(i) == '\ufffd') {
          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));
          i += Number(length) + 1;
          length = '';
        } else {
          length += data.charAt(i);
        }
      }

      return ret;
    } else {
      return [parser.decodePacket(data)];
    }
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.Transport = Transport;

  /**
   * This is the transport template for all supported transport methods.
   *
   * @constructor
   * @api public
   */

  function Transport (socket, sessid) {
    this.socket = socket;
    this.sessid = sessid;
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Transport, io.EventEmitter);


  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  Transport.prototype.heartbeats = function () {
    return true;
  };

  /**
   * Handles the response from the server. When a new response is received
   * it will automatically update the timeout, decode the message and
   * forwards the response to the onMessage function for further processing.
   *
   * @param {String} data Response from the server.
   * @api private
   */

  Transport.prototype.onData = function (data) {
    this.clearCloseTimeout();

    // If the connection in currently open (or in a reopening state) reset the close
    // timeout since we have just received data. This check is necessary so
    // that we don't reset the timeout on an explicitly disconnected connection.
    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {
      this.setCloseTimeout();
    }

    if (data !== '') {
      // todo: we should only do decodePayload for xhr transports
      var msgs = io.parser.decodePayload(data);

      if (msgs && msgs.length) {
        for (var i = 0, l = msgs.length; i < l; i++) {
          this.onPacket(msgs[i]);
        }
      }
    }

    return this;
  };

  /**
   * Handles packets.
   *
   * @api private
   */

  Transport.prototype.onPacket = function (packet) {
    this.socket.setHeartbeatTimeout();

    if (packet.type == 'heartbeat') {
      return this.onHeartbeat();
    }

    if (packet.type == 'connect' && packet.endpoint == '') {
      this.onConnect();
    }

    if (packet.type == 'error' && packet.advice == 'reconnect') {
      this.isOpen = false;
    }

    this.socket.onPacket(packet);

    return this;
  };

  /**
   * Sets close timeout
   *
   * @api private
   */

  Transport.prototype.setCloseTimeout = function () {
    if (!this.closeTimeout) {
      var self = this;

      this.closeTimeout = setTimeout(function () {
        self.onDisconnect();
      }, this.socket.closeTimeout);
    }
  };

  /**
   * Called when transport disconnects.
   *
   * @api private
   */

  Transport.prototype.onDisconnect = function () {
    if (this.isOpen) this.close();
    this.clearTimeouts();
    this.socket.onDisconnect();
    return this;
  };

  /**
   * Called when transport connects
   *
   * @api private
   */

  Transport.prototype.onConnect = function () {
    this.socket.onConnect();
    return this;
  };

  /**
   * Clears close timeout
   *
   * @api private
   */

  Transport.prototype.clearCloseTimeout = function () {
    if (this.closeTimeout) {
      clearTimeout(this.closeTimeout);
      this.closeTimeout = null;
    }
  };

  /**
   * Clear timeouts
   *
   * @api private
   */

  Transport.prototype.clearTimeouts = function () {
    this.clearCloseTimeout();

    if (this.reopenTimeout) {
      clearTimeout(this.reopenTimeout);
    }
  };

  /**
   * Sends a packet
   *
   * @param {Object} packet object.
   * @api private
   */

  Transport.prototype.packet = function (packet) {
    this.send(io.parser.encodePacket(packet));
  };

  /**
   * Send the received heartbeat message back to server. So the server
   * knows we are still connected.
   *
   * @param {String} heartbeat Heartbeat response from the server.
   * @api private
   */

  Transport.prototype.onHeartbeat = function (heartbeat) {
    this.packet({ type: 'heartbeat' });
  };

  /**
   * Called when the transport opens.
   *
   * @api private
   */

  Transport.prototype.onOpen = function () {
    this.isOpen = true;
    this.clearCloseTimeout();
    this.socket.onOpen();
  };

  /**
   * Notifies the base when the connection with the Socket.IO server
   * has been disconnected.
   *
   * @api private
   */

  Transport.prototype.onClose = function () {
    var self = this;

    /* FIXME: reopen delay causing a infinit loop
    this.reopenTimeout = setTimeout(function () {
      self.open();
    }, this.socket.options['reopen delay']);*/

    this.isOpen = false;
    this.socket.onClose();
    this.onDisconnect();
  };

  /**
   * Generates a connection url based on the Socket.IO URL Protocol.
   * See <https://github.com/learnboost/socket.io-node/> for more details.
   *
   * @returns {String} Connection url
   * @api private
   */

  Transport.prototype.prepareUrl = function () {
    var options = this.socket.options;

    return this.scheme() + '://'
      + options.host + ':' + options.port + '/'
      + options.resource + '/' + io.protocol
      + '/' + this.name + '/' + this.sessid;
  };

  /**
   * Checks if the transport is ready to start a connection.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Transport.prototype.ready = function (socket, fn) {
    fn.call(this);
  };
})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.Socket = Socket;

  /**
   * Create a new `Socket.IO client` which can establish a persistent
   * connection with a Socket.IO enabled server.
   *
   * @api public
   */

  function Socket (options) {
    this.options = {
        port: 80
      , secure: false
      , document: 'document' in global ? document : false
      , resource: 'socket.io'
      , transports: io.transports
      , 'connect timeout': 10000
      , 'try multiple transports': true
      , 'reconnect': true
      , 'reconnection delay': 500
      , 'reconnection limit': Infinity
      , 'reopen delay': 3000
      , 'max reconnection attempts': 10
      , 'sync disconnect on unload': false
      , 'auto connect': true
      , 'flash policy port': 10843
      , 'manualFlush': false
    };

    io.util.merge(this.options, options);

    this.connected = false;
    this.open = false;
    this.connecting = false;
    this.reconnecting = false;
    this.namespaces = {};
    this.buffer = [];
    this.doBuffer = false;

    if (this.options['sync disconnect on unload'] &&
        (!this.isXDomain() || io.util.ua.hasCORS)) {
      var self = this;
      io.util.on(global, 'beforeunload', function () {
        self.disconnectSync();
      }, false);
    }

    if (this.options['auto connect']) {
      this.connect();
    }
};

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(Socket, io.EventEmitter);

  /**
   * Returns a namespace listener/emitter for this socket
   *
   * @api public
   */

  Socket.prototype.of = function (name) {
    if (!this.namespaces[name]) {
      this.namespaces[name] = new io.SocketNamespace(this, name);

      if (name !== '') {
        this.namespaces[name].packet({ type: 'connect' });
      }
    }

    return this.namespaces[name];
  };

  /**
   * Emits the given event to the Socket and all namespaces
   *
   * @api private
   */

  Socket.prototype.publish = function () {
    this.emit.apply(this, arguments);

    var nsp;

    for (var i in this.namespaces) {
      if (this.namespaces.hasOwnProperty(i)) {
        nsp = this.of(i);
        nsp.$emit.apply(nsp, arguments);
      }
    }
  };

  /**
   * Performs the handshake
   *
   * @api private
   */

  function empty () { };

  Socket.prototype.handshake = function (fn) {
    var self = this
      , options = this.options;

    function complete (data) {
      if (data instanceof Error) {
        self.connecting = false;
        self.onError(data.message);
      } else {
        fn.apply(null, data.split(':'));
      }
    };

    var url = [
          'http' + (options.secure ? 's' : '') + ':/'
        , options.host + ':' + options.port
        , options.resource
        , io.protocol
        , io.util.query(this.options.query, 't=' + +new Date)
      ].join('/');

    if (this.isXDomain() && !io.util.ua.hasCORS) {
      var insertAt = document.getElementsByTagName('script')[0]
        , script = document.createElement('script');

      script.src = url + '&jsonp=' + io.j.length;
      insertAt.parentNode.insertBefore(script, insertAt);

      io.j.push(function (data) {
        complete(data);
        script.parentNode.removeChild(script);
      });
    } else {
      var xhr = io.util.request();

      xhr.open('GET', url, true);
      if (this.isXDomain()) {
        xhr.withCredentials = true;
      }
      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          xhr.onreadystatechange = empty;

          if (xhr.status == 200) {
            complete(xhr.responseText);
          } else if (xhr.status == 403) {
            self.onError(xhr.responseText);
          } else {
            self.connecting = false;            
            !self.reconnecting && self.onError(xhr.responseText);
          }
        }
      };
      xhr.send(null);
    }
  };

  /**
   * Find an available transport based on the options supplied in the constructor.
   *
   * @api private
   */

  Socket.prototype.getTransport = function (override) {
    var transports = override || this.transports, match;

    for (var i = 0, transport; transport = transports[i]; i++) {
      if (io.Transport[transport]
        && io.Transport[transport].check(this)
        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {
        return new io.Transport[transport](this, this.sessionid);
      }
    }

    return null;
  };

  /**
   * Connects to the server.
   *
   * @param {Function} [fn] Callback.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.connect = function (fn) {
    if (this.connecting) {
      return this;
    }

    var self = this;
    self.connecting = true;
    
    this.handshake(function (sid, heartbeat, close, transports) {
      self.sessionid = sid;
      self.closeTimeout = close * 1000;
      self.heartbeatTimeout = heartbeat * 1000;
      if(!self.transports)
          self.transports = self.origTransports = (transports ? io.util.intersect(
              transports.split(',')
            , self.options.transports
          ) : self.options.transports);

      self.setHeartbeatTimeout();

      function connect (transports){
        if (self.transport) self.transport.clearTimeouts();

        self.transport = self.getTransport(transports);
        if (!self.transport) return self.publish('connect_failed');

        // once the transport is ready
        self.transport.ready(self, function () {
          self.connecting = true;
          self.publish('connecting', self.transport.name);
          self.transport.open();

          if (self.options['connect timeout']) {
            self.connectTimeoutTimer = setTimeout(function () {
              if (!self.connected) {
                self.connecting = false;

                if (self.options['try multiple transports']) {
                  var remaining = self.transports;

                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=
                         self.transport.name) {}

                    if (remaining.length){
                      connect(remaining);
                    } else {
                      self.publish('connect_failed');
                    }
                }
              }
            }, self.options['connect timeout']);
          }
        });
      }

      connect(self.transports);

      self.once('connect', function (){
        clearTimeout(self.connectTimeoutTimer);

        fn && typeof fn == 'function' && fn();
      });
    });

    return this;
  };

  /**
   * Clears and sets a new heartbeat timeout using the value given by the
   * server during the handshake.
   *
   * @api private
   */

  Socket.prototype.setHeartbeatTimeout = function () {
    clearTimeout(this.heartbeatTimeoutTimer);
    if(this.transport && !this.transport.heartbeats()) return;

    var self = this;
    this.heartbeatTimeoutTimer = setTimeout(function () {
      self.transport.onClose();
    }, this.heartbeatTimeout);
  };

  /**
   * Sends a message.
   *
   * @param {Object} data packet.
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.packet = function (data) {
    if (this.connected && !this.doBuffer) {
      this.transport.packet(data);
    } else {
      this.buffer.push(data);
    }

    return this;
  };

  /**
   * Sets buffer state
   *
   * @api private
   */

  Socket.prototype.setBuffer = function (v) {
    this.doBuffer = v;

    if (!v && this.connected && this.buffer.length) {
      if (!this.options['manualFlush']) {
        this.flushBuffer();
      }
    }
  };

  /**
   * Flushes the buffer data over the wire.
   * To be invoked manually when 'manualFlush' is set to true.
   *
   * @api public
   */

  Socket.prototype.flushBuffer = function() {
    this.transport.payload(this.buffer);
    this.buffer = [];
  };
  

  /**
   * Disconnect the established connect.
   *
   * @returns {io.Socket}
   * @api public
   */

  Socket.prototype.disconnect = function () {
    if (this.connected || this.connecting) {
      if (this.open) {
        this.of('').packet({ type: 'disconnect' });
      }

      // handle disconnection immediately
      this.onDisconnect('booted');
    }

    return this;
  };

  /**
   * Disconnects the socket with a sync XHR.
   *
   * @api private
   */

  Socket.prototype.disconnectSync = function () {
    // ensure disconnection
    var xhr = io.util.request();
    var uri = [
        'http' + (this.options.secure ? 's' : '') + ':/'
      , this.options.host + ':' + this.options.port
      , this.options.resource
      , io.protocol
      , ''
      , this.sessionid
    ].join('/') + '/?disconnect=1';

    xhr.open('GET', uri, false);
    xhr.send(null);

    // handle disconnection immediately
    this.onDisconnect('booted');
  };

  /**
   * Check if we need to use cross domain enabled transports. Cross domain would
   * be a different port or different domain name.
   *
   * @returns {Boolean}
   * @api private
   */

  Socket.prototype.isXDomain = function () {

    var port = global.location.port ||
      ('https:' == global.location.protocol ? 443 : 80);

    return this.options.host !== global.location.hostname 
      || this.options.port != port;
  };

  /**
   * Called upon handshake.
   *
   * @api private
   */

  Socket.prototype.onConnect = function () {
    if (!this.connected) {
      this.connected = true;
      this.connecting = false;
      if (!this.doBuffer) {
        // make sure to flush the buffer
        this.setBuffer(false);
      }
      this.emit('connect');
    }
  };

  /**
   * Called when the transport opens
   *
   * @api private
   */

  Socket.prototype.onOpen = function () {
    this.open = true;
  };

  /**
   * Called when the transport closes.
   *
   * @api private
   */

  Socket.prototype.onClose = function () {
    this.open = false;
    clearTimeout(this.heartbeatTimeoutTimer);
  };

  /**
   * Called when the transport first opens a connection
   *
   * @param text
   */

  Socket.prototype.onPacket = function (packet) {
    this.of(packet.endpoint).onPacket(packet);
  };

  /**
   * Handles an error.
   *
   * @api private
   */

  Socket.prototype.onError = function (err) {
    if (err && err.advice) {
      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {
        this.disconnect();
        if (this.options.reconnect) {
          this.reconnect();
        }
      }
    }

    this.publish('error', err && err.reason ? err.reason : err);
  };

  /**
   * Called when the transport disconnects.
   *
   * @api private
   */

  Socket.prototype.onDisconnect = function (reason) {
    var wasConnected = this.connected
      , wasConnecting = this.connecting;

    this.connected = false;
    this.connecting = false;
    this.open = false;

    if (wasConnected || wasConnecting) {
      this.transport.close();
      this.transport.clearTimeouts();
      if (wasConnected) {
        this.publish('disconnect', reason);

        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {
          this.reconnect();
        }
      }
    }
  };

  /**
   * Called upon reconnection.
   *
   * @api private
   */

  Socket.prototype.reconnect = function () {
    this.reconnecting = true;
    this.reconnectionAttempts = 0;
    this.reconnectionDelay = this.options['reconnection delay'];

    var self = this
      , maxAttempts = this.options['max reconnection attempts']
      , tryMultiple = this.options['try multiple transports']
      , limit = this.options['reconnection limit'];

    function reset () {
      if (self.connected) {
        for (var i in self.namespaces) {
          if (self.namespaces.hasOwnProperty(i) && '' !== i) {
              self.namespaces[i].packet({ type: 'connect' });
          }
        }
        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);
      }

      clearTimeout(self.reconnectionTimer);

      self.removeListener('connect_failed', maybeReconnect);
      self.removeListener('connect', maybeReconnect);

      self.reconnecting = false;

      delete self.reconnectionAttempts;
      delete self.reconnectionDelay;
      delete self.reconnectionTimer;
      delete self.redoTransports;

      self.options['try multiple transports'] = tryMultiple;
    };

    function maybeReconnect () {
      if (!self.reconnecting) {
        return;
      }

      if (self.connected) {
        return reset();
      };

      if (self.connecting && self.reconnecting) {
        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);
      }

      if (self.reconnectionAttempts++ >= maxAttempts) {
        if (!self.redoTransports) {
          self.on('connect_failed', maybeReconnect);
          self.options['try multiple transports'] = true;
          self.transports = self.origTransports;
          self.transport = self.getTransport();
          self.redoTransports = true;
          self.connect();
        } else {
          self.publish('reconnect_failed');
          reset();
        }
      } else {
        if (self.reconnectionDelay < limit) {
          self.reconnectionDelay *= 2; // exponential back off
        }

        self.connect();
        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);
        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
      }
    };

    this.options['try multiple transports'] = false;
    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);

    this.on('connect', maybeReconnect);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.SocketNamespace = SocketNamespace;

  /**
   * Socket namespace constructor.
   *
   * @constructor
   * @api public
   */

  function SocketNamespace (socket, name) {
    this.socket = socket;
    this.name = name || '';
    this.flags = {};
    this.json = new Flag(this, 'json');
    this.ackPackets = 0;
    this.acks = {};
  };

  /**
   * Apply EventEmitter mixin.
   */

  io.util.mixin(SocketNamespace, io.EventEmitter);

  /**
   * Copies emit since we override it
   *
   * @api private
   */

  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

  /**
   * Creates a new namespace, by proxying the request to the socket. This
   * allows us to use the synax as we do on the server.
   *
   * @api public
   */

  SocketNamespace.prototype.of = function () {
    return this.socket.of.apply(this.socket, arguments);
  };

  /**
   * Sends a packet.
   *
   * @api private
   */

  SocketNamespace.prototype.packet = function (packet) {
    packet.endpoint = this.name;
    this.socket.packet(packet);
    this.flags = {};
    return this;
  };

  /**
   * Sends a message
   *
   * @api public
   */

  SocketNamespace.prototype.send = function (data, fn) {
    var packet = {
        type: this.flags.json ? 'json' : 'message'
      , data: data
    };

    if ('function' == typeof fn) {
      packet.id = ++this.ackPackets;
      packet.ack = true;
      this.acks[packet.id] = fn;
    }

    return this.packet(packet);
  };

  /**
   * Emits an event
   *
   * @api public
   */
  
  SocketNamespace.prototype.emit = function (name) {
    var args = Array.prototype.slice.call(arguments, 1)
      , lastArg = args[args.length - 1]
      , packet = {
            type: 'event'
          , name: name
        };

    if ('function' == typeof lastArg) {
      packet.id = ++this.ackPackets;
      packet.ack = 'data';
      this.acks[packet.id] = lastArg;
      args = args.slice(0, args.length - 1);
    }

    packet.args = args;

    return this.packet(packet);
  };

  /**
   * Disconnects the namespace
   *
   * @api private
   */

  SocketNamespace.prototype.disconnect = function () {
    if (this.name === '') {
      this.socket.disconnect();
    } else {
      this.packet({ type: 'disconnect' });
      this.$emit('disconnect');
    }

    return this;
  };

  /**
   * Handles a packet
   *
   * @api private
   */

  SocketNamespace.prototype.onPacket = function (packet) {
    var self = this;

    function ack () {
      self.packet({
          type: 'ack'
        , args: io.util.toArray(arguments)
        , ackId: packet.id
      });
    };

    switch (packet.type) {
      case 'connect':
        this.$emit('connect');
        break;

      case 'disconnect':
        if (this.name === '') {
          this.socket.onDisconnect(packet.reason || 'booted');
        } else {
          this.$emit('disconnect', packet.reason);
        }
        break;

      case 'message':
      case 'json':
        var params = ['message', packet.data];

        if (packet.ack == 'data') {
          params.push(ack);
        } else if (packet.ack) {
          this.packet({ type: 'ack', ackId: packet.id });
        }

        this.$emit.apply(this, params);
        break;

      case 'event':
        var params = [packet.name].concat(packet.args);

        if (packet.ack == 'data')
          params.push(ack);

        this.$emit.apply(this, params);
        break;

      case 'ack':
        if (this.acks[packet.ackId]) {
          this.acks[packet.ackId].apply(this, packet.args);
          delete this.acks[packet.ackId];
        }
        break;

      case 'error':
        if (packet.advice){
          this.socket.onError(packet);
        } else {
          if (packet.reason == 'unauthorized') {
            this.$emit('connect_failed', packet.reason);
          } else {
            this.$emit('error', packet.reason);
          }
        }
        break;
    }
  };

  /**
   * Flag interface.
   *
   * @api private
   */

  function Flag (nsp, name) {
    this.namespace = nsp;
    this.name = name;
  };

  /**
   * Send a message
   *
   * @api public
   */

  Flag.prototype.send = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.send.apply(this.namespace, arguments);
  };

  /**
   * Emit an event
   *
   * @api public
   */

  Flag.prototype.emit = function () {
    this.namespace.flags[this.name] = true;
    this.namespace.emit.apply(this.namespace, arguments);
  };

})(
    'undefined' != typeof io ? io : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports.websocket = WS;

  /**
   * The WebSocket transport uses the HTML5 WebSocket API to establish an
   * persistent connection with the Socket.IO server. This transport will also
   * be inherited by the FlashSocket fallback as it provides a API compatible
   * polyfill for the WebSockets.
   *
   * @constructor
   * @extends {io.Transport}
   * @api public
   */

  function WS (socket) {
    io.Transport.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(WS, io.Transport);

  /**
   * Transport name
   *
   * @api public
   */

  WS.prototype.name = 'websocket';

  /**
   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
   * all the appropriate listeners to handle the responses from the server.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.open = function () {
    var query = io.util.query(this.socket.options.query)
      , self = this
      , Socket


    if (!Socket) {
      Socket = global.MozWebSocket || global.WebSocket;
    }

    this.websocket = new Socket(this.prepareUrl() + query);

    this.websocket.onopen = function () {
      self.onOpen();
      self.socket.setBuffer(false);
    };
    this.websocket.onmessage = function (ev) {
      self.onData(ev.data);
    };
    this.websocket.onclose = function () {
      self.onClose();
      self.socket.setBuffer(true);
    };
    this.websocket.onerror = function (e) {
      self.onError(e);
    };

    return this;
  };

  /**
   * Send a message to the Socket.IO server. The message will automatically be
   * encoded in the correct message format.
   *
   * @returns {Transport}
   * @api public
   */

  // Do to a bug in the current IDevices browser, we need to wrap the send in a 
  // setTimeout, when they resume from sleeping the browser will crash if 
  // we don't allow the browser time to detect the socket has been closed
  if (io.util.ua.iDevice) {
    WS.prototype.send = function (data) {
      var self = this;
      setTimeout(function() {
         self.websocket.send(data);
      },0);
      return this;
    };
  } else {
    WS.prototype.send = function (data) {
      this.websocket.send(data);
      return this;
    };
  }

  /**
   * Payload
   *
   * @api private
   */

  WS.prototype.payload = function (arr) {
    for (var i = 0, l = arr.length; i < l; i++) {
      this.packet(arr[i]);
    }
    return this;
  };

  /**
   * Disconnect the established `WebSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  WS.prototype.close = function () {
    this.websocket.close();
    return this;
  };

  /**
   * Handle the errors that `WebSocket` might be giving when we
   * are attempting to connect or send messages.
   *
   * @param {Error} e The error.
   * @api private
   */

  WS.prototype.onError = function (e) {
    this.socket.onError(e);
  };

  /**
   * Returns the appropriate scheme for the URI generation.
   *
   * @api private
   */
  WS.prototype.scheme = function () {
    return this.socket.options.secure ? 'wss' : 'ws';
  };

  /**
   * Checks if the browser has support for native `WebSockets` and that
   * it's not the polyfill created for the FlashSocket transport.
   *
   * @return {Boolean}
   * @api public
   */

  WS.check = function () {
    return ('WebSocket' in global && !('__addTask' in WebSocket))
          || 'MozWebSocket' in global;
  };

  /**
   * Check if the `WebSocket` transport support cross domain communications.
   *
   * @returns {Boolean}
   * @api public
   */

  WS.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('websocket');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.flashsocket = Flashsocket;

  /**
   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket
   * specification. It uses a .swf file to communicate with the server. If you want
   * to serve the .swf file from a other server than where the Socket.IO script is
   * coming from you need to use the insecure version of the .swf. More information
   * about this can be found on the github page.
   *
   * @constructor
   * @extends {io.Transport.websocket}
   * @api public
   */

  function Flashsocket () {
    io.Transport.websocket.apply(this, arguments);
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(Flashsocket, io.Transport.websocket);

  /**
   * Transport name
   *
   * @api public
   */

  Flashsocket.prototype.name = 'flashsocket';

  /**
   * Disconnect the established `FlashSocket` connection. This is done by adding a 
   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.open = function () {
    var self = this
      , args = arguments;

    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.open.apply(self, args);
    });
    return this;
  };
  
  /**
   * Sends a message to the Socket.IO server. This is done by adding a new
   * task to the FlashSocket. The rest will be handled off by the `WebSocket` 
   * transport.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.send = function () {
    var self = this, args = arguments;
    WebSocket.__addTask(function () {
      io.Transport.websocket.prototype.send.apply(self, args);
    });
    return this;
  };

  /**
   * Disconnects the established `FlashSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */

  Flashsocket.prototype.close = function () {
    WebSocket.__tasks.length = 0;
    io.Transport.websocket.prototype.close.call(this);
    return this;
  };

  /**
   * The WebSocket fall back needs to append the flash container to the body
   * element, so we need to make sure we have access to it. Or defer the call
   * until we are sure there is a body element.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  Flashsocket.prototype.ready = function (socket, fn) {
    function init () {
      var options = socket.options
        , port = options['flash policy port']
        , path = [
              'http' + (options.secure ? 's' : '') + ':/'
            , options.host + ':' + options.port
            , options.resource
            , 'static/flashsocket'
            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'
          ];

      // Only start downloading the swf file when the checked that this browser
      // actually supports it
      if (!Flashsocket.loaded) {
        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {
          // Set the correct file based on the XDomain settings
          WEB_SOCKET_SWF_LOCATION = path.join('/');
        }

        if (port !== 843) {
          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);
        }

        WebSocket.__initialize();
        Flashsocket.loaded = true;
      }

      fn.call(self);
    }

    var self = this;
    if (document.body) return init();

    io.util.load(init);
  };

  /**
   * Check if the FlashSocket transport is supported as it requires that the Adobe
   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if
   * the polyfill is correctly loaded.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.check = function () {
    if (
        typeof WebSocket == 'undefined'
      || !('__initialize' in WebSocket) || !swfobject
    ) return false;

    return swfobject.getFlashPlayerVersion().major >= 10;
  };

  /**
   * Check if the FlashSocket transport can be used as cross domain / cross origin 
   * transport. Because we can't see which type (secure or insecure) of .swf is used
   * we will just return true.
   *
   * @returns {Boolean}
   * @api public
   */

  Flashsocket.xdomainCheck = function () {
    return true;
  };

  /**
   * Disable AUTO_INITIALIZATION
   */

  if (typeof window != 'undefined') {
    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;
  }

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('flashsocket');
})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);
/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
if ('undefined' != typeof window) {
var swfobject=function(){var D="undefined",r="object",S="Shockwave Flash",W="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",R="SWFObjectExprInst",x="onreadystatechange",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,X=!+"\v1",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\s+(\S+\s+\S+$)/,"$1");ag[0]=parseInt(ab.replace(/^(.*)\..*$/,"$1"),10);ag[1]=parseInt(ab.replace(/^.*\.(.*)\s.*$/,"$1"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable("$version");if(ab){X=true;ab=ab.split(" ")[1].split(",");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState=="complete")||(typeof j.readyState==D&&(j.getElementsByTagName("body")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener("DOMContentLoaded",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState=="complete"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll("left")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName("body")[0].appendChild(C("span"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener("load",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener("load",Y,false)}else{if(typeof O.attachEvent!=D){i(O,"onload",Y)}else{if(typeof O.onload=="function"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName("body")[0];var aa=C(r);aa.setAttribute("type",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable("$version");if(ab){ab=ab.split(" ")[1].split(",");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute("width")||"0";ai.height=ae.getAttribute("height")||"0";if(ae.getAttribute("class")){ai.styleclass=ae.getAttribute("class")}if(ae.getAttribute("align")){ai.align=ae.getAttribute("align")}var ah={};var X=ae.getElementsByTagName("param");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute("name").toLowerCase()!="movie"){ah[X[ad].getAttribute("name")]=X[ad].getAttribute("value")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName=="OBJECT"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F("6.0.65")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName=="OBJECT"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width="310"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height="137"}j.title=j.title.slice(0,47)+" - Flash Player Installation";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):"PlugIn",ac="MMredirectURL="+O.location.toString().replace(/&/g,"%26")+"&MMplayerType="+ad+"&MMdoctitle="+j.title;if(typeof ab.flashvars!=D){ab.flashvars+="&"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C("div");X+="SWFObjectNew";Y.setAttribute("id",X);ae.parentNode.insertBefore(Y,ae);ae.style.display="none";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C("div");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display="none";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C("div");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName=="PARAM")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah="";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()=="data"){ag.movie=ai[ae]}else{if(ae.toLowerCase()=="styleclass"){ah+=' class="'+ai[ae]+'"'}else{if(ae.toLowerCase()!="classid"){ah+=" "+ae+'="'+ai[ae]+'"'}}}}}var af="";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name="'+ad+'" value="'+ag[ad]+'" />'}}aa.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+ah+">"+af+"</object>";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute("type",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()=="styleclass"){Z.setAttribute("class",ai[ac])}else{if(ac.toLowerCase()!="classid"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!="movie"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C("param");aa.setAttribute("name",X);aa.setAttribute("value",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName=="OBJECT"){if(M.ie&&M.win){X.style.display="none";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]=="function"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(".");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName("head")[0];if(!aa){return}var X=(ad&&typeof ad=="string")?ad:"screen";if(ab){n=null;G=null}if(!n||G!=X){var Z=C("style");Z.setAttribute("type","text/css");Z.setAttribute("media",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+" {"+Y+"}"))}}}function w(Z,X){if(!m){return}var Y=X?"visible":"hidden";if(J&&c(Z)){c(Z).style.visibility=Y}else{v("#"+Z,"visibility:"+Y)}}function L(Y){var Z=/[\\\"<>\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent("onunload",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+="";ag+="";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+="&"+ai+"="+Z[ai]}else{am.flashvars=ai+"="+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\?/.test(Z)){Z=Z.split("?")[1]}if(aa==null){return L(Z)}var Y=Z.split("&");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf("="))==aa){return L(Y[X].substring((Y[X].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display="block"}}if(E){E(B)}}a=false}}}}();
}
// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>
// License: New BSD License
// Reference: http://dev.w3.org/html5/websockets/
// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol

(function() {
  
  if ('undefined' == typeof window || window.WebSocket) return;

  var console = window.console;
  if (!console || !console.log || !console.error) {
    console = {log: function(){ }, error: function(){ }};
  }
  
  if (!swfobject.hasFlashPlayerVersion("10.0.0")) {
    console.error("Flash Player >= 10.0.0 is required.");
    return;
  }
  if (location.protocol == "file:") {
    console.error(
      "WARNING: web-socket-js doesn't work in file:///... URL " +
      "unless you set Flash Security Settings properly. " +
      "Open the page via Web server i.e. http://...");
  }

  /**
   * This class represents a faux web socket.
   * @param {string} url
   * @param {array or string} protocols
   * @param {string} proxyHost
   * @param {int} proxyPort
   * @param {string} headers
   */
  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
    var self = this;
    self.__id = WebSocket.__nextId++;
    WebSocket.__instances[self.__id] = self;
    self.readyState = WebSocket.CONNECTING;
    self.bufferedAmount = 0;
    self.__events = {};
    if (!protocols) {
      protocols = [];
    } else if (typeof protocols == "string") {
      protocols = [protocols];
    }
    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.
    // Otherwise, when onopen fires immediately, onopen is called before it is set.
    setTimeout(function() {
      WebSocket.__addTask(function() {
        WebSocket.__flash.create(
            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
      });
    }, 0);
  };

  /**
   * Send data to the web socket.
   * @param {string} data  The data to send to the socket.
   * @return {boolean}  True for success, false for failure.
   */
  WebSocket.prototype.send = function(data) {
    if (this.readyState == WebSocket.CONNECTING) {
      throw "INVALID_STATE_ERR: Web Socket connection has not been established";
    }
    // We use encodeURIComponent() here, because FABridge doesn't work if
    // the argument includes some characters. We don't use escape() here
    // because of this:
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions
    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't
    // preserve all Unicode characters either e.g. "\uffff" in Firefox.
    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require
    // additional testing.
    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
    if (result < 0) { // success
      return true;
    } else {
      this.bufferedAmount += result;
      return false;
    }
  };

  /**
   * Close this web socket gracefully.
   */
  WebSocket.prototype.close = function() {
    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {
      return;
    }
    this.readyState = WebSocket.CLOSING;
    WebSocket.__flash.close(this.__id);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) {
      this.__events[type] = [];
    }
    this.__events[type].push(listener);
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {string} type
   * @param {function} listener
   * @param {boolean} useCapture
   * @return void
   */
  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
    if (!(type in this.__events)) return;
    var events = this.__events[type];
    for (var i = events.length - 1; i >= 0; --i) {
      if (events[i] === listener) {
        events.splice(i, 1);
        break;
      }
    }
  };

  /**
   * Implementation of {@link <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration">DOM 2 EventTarget Interface</a>}
   *
   * @param {Event} event
   * @return void
   */
  WebSocket.prototype.dispatchEvent = function(event) {
    var events = this.__events[event.type] || [];
    for (var i = 0; i < events.length; ++i) {
      events[i](event);
    }
    var handler = this["on" + event.type];
    if (handler) handler(event);
  };

  /**
   * Handles an event from Flash.
   * @param {Object} flashEvent
   */
  WebSocket.prototype.__handleEvent = function(flashEvent) {
    if ("readyState" in flashEvent) {
      this.readyState = flashEvent.readyState;
    }
    if ("protocol" in flashEvent) {
      this.protocol = flashEvent.protocol;
    }
    
    var jsEvent;
    if (flashEvent.type == "open" || flashEvent.type == "error") {
      jsEvent = this.__createSimpleEvent(flashEvent.type);
    } else if (flashEvent.type == "close") {
      // TODO implement jsEvent.wasClean
      jsEvent = this.__createSimpleEvent("close");
    } else if (flashEvent.type == "message") {
      var data = decodeURIComponent(flashEvent.message);
      jsEvent = this.__createMessageEvent("message", data);
    } else {
      throw "unknown event type: " + flashEvent.type;
    }
    
    this.dispatchEvent(jsEvent);
  };
  
  WebSocket.prototype.__createSimpleEvent = function(type) {
    if (document.createEvent && window.Event) {
      var event = document.createEvent("Event");
      event.initEvent(type, false, false);
      return event;
    } else {
      return {type: type, bubbles: false, cancelable: false};
    }
  };
  
  WebSocket.prototype.__createMessageEvent = function(type, data) {
    if (document.createEvent && window.MessageEvent && !window.opera) {
      var event = document.createEvent("MessageEvent");
      event.initMessageEvent("message", false, false, data, null, null, window, null);
      return event;
    } else {
      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.
      return {type: type, data: data, bubbles: false, cancelable: false};
    }
  };
  
  /**
   * Define the WebSocket readyState enumeration.
   */
  WebSocket.CONNECTING = 0;
  WebSocket.OPEN = 1;
  WebSocket.CLOSING = 2;
  WebSocket.CLOSED = 3;

  WebSocket.__flash = null;
  WebSocket.__instances = {};
  WebSocket.__tasks = [];
  WebSocket.__nextId = 0;
  
  /**
   * Load a new flash security policy file.
   * @param {string} url
   */
  WebSocket.loadFlashPolicyFile = function(url){
    WebSocket.__addTask(function() {
      WebSocket.__flash.loadManualPolicyFile(url);
    });
  };

  /**
   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.
   */
  WebSocket.__initialize = function() {
    if (WebSocket.__flash) return;
    
    if (WebSocket.__swfLocation) {
      // For backword compatibility.
      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;
    }
    if (!window.WEB_SOCKET_SWF_LOCATION) {
      console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
      return;
    }
    var container = document.createElement("div");
    container.id = "webSocketContainer";
    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents
    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).
    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash
    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is
    // the best we can do as far as we know now.
    container.style.position = "absolute";
    if (WebSocket.__isFlashLite()) {
      container.style.left = "0px";
      container.style.top = "0px";
    } else {
      container.style.left = "-100px";
      container.style.top = "-100px";
    }
    var holder = document.createElement("div");
    holder.id = "webSocketFlash";
    container.appendChild(holder);
    document.body.appendChild(container);
    // See this article for hasPriority:
    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html
    swfobject.embedSWF(
      WEB_SOCKET_SWF_LOCATION,
      "webSocketFlash",
      "1" /* width */,
      "1" /* height */,
      "10.0.0" /* SWF version */,
      null,
      null,
      {hasPriority: true, swliveconnect : true, allowScriptAccess: "always"},
      null,
      function(e) {
        if (!e.success) {
          console.error("[WebSocket] swfobject.embedSWF failed");
        }
      });
  };
  
  /**
   * Called by Flash to notify JS that it's fully loaded and ready
   * for communication.
   */
  WebSocket.__onFlashInitialized = function() {
    // We need to set a timeout here to avoid round-trip calls
    // to flash during the initialization process.
    setTimeout(function() {
      WebSocket.__flash = document.getElementById("webSocketFlash");
      WebSocket.__flash.setCallerUrl(location.href);
      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
      for (var i = 0; i < WebSocket.__tasks.length; ++i) {
        WebSocket.__tasks[i]();
      }
      WebSocket.__tasks = [];
    }, 0);
  };
  
  /**
   * Called by Flash to notify WebSockets events are fired.
   */
  WebSocket.__onFlashEvent = function() {
    setTimeout(function() {
      try {
        // Gets events using receiveEvents() instead of getting it from event object
        // of Flash event. This is to make sure to keep message order.
        // It seems sometimes Flash events don't arrive in the same order as they are sent.
        var events = WebSocket.__flash.receiveEvents();
        for (var i = 0; i < events.length; ++i) {
          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
        }
      } catch (e) {
        console.error(e);
      }
    }, 0);
    return true;
  };
  
  // Called by Flash.
  WebSocket.__log = function(message) {
    console.log(decodeURIComponent(message));
  };
  
  // Called by Flash.
  WebSocket.__error = function(message) {
    console.error(decodeURIComponent(message));
  };
  
  WebSocket.__addTask = function(task) {
    if (WebSocket.__flash) {
      task();
    } else {
      WebSocket.__tasks.push(task);
    }
  };
  
  /**
   * Test if the browser is running flash lite.
   * @return {boolean} True if flash lite is running, false otherwise.
   */
  WebSocket.__isFlashLite = function() {
    if (!window.navigator || !window.navigator.mimeTypes) {
      return false;
    }
    var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {
      return false;
    }
    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;
  };
  
  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {
    if (window.addEventListener) {
      window.addEventListener("load", function(){
        WebSocket.__initialize();
      }, false);
    } else {
      window.attachEvent("onload", function(){
        WebSocket.__initialize();
      });
    }
  }
  
})();

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   *
   * @api public
   */

  exports.XHR = XHR;

  /**
   * XHR constructor
   *
   * @costructor
   * @api public
   */

  function XHR (socket) {
    if (!socket) return;

    io.Transport.apply(this, arguments);
    this.sendBuffer = [];
  };

  /**
   * Inherits from Transport.
   */

  io.util.inherit(XHR, io.Transport);

  /**
   * Establish a connection
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.open = function () {
    this.socket.setBuffer(false);
    this.onOpen();
    this.get();

    // we need to make sure the request succeeds since we have no indication
    // whether the request opened or not until it succeeded.
    this.setCloseTimeout();

    return this;
  };

  /**
   * Check if we need to send data to the Socket.IO server, if we have data in our
   * buffer we encode it and forward it to the `post` method.
   *
   * @api private
   */

  XHR.prototype.payload = function (payload) {
    var msgs = [];

    for (var i = 0, l = payload.length; i < l; i++) {
      msgs.push(io.parser.encodePacket(payload[i]));
    }

    this.send(io.parser.encodePayload(msgs));
  };

  /**
   * Send data to the Socket.IO server.
   *
   * @param data The message
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.send = function (data) {
    this.post(data);
    return this;
  };

  /**
   * Posts a encoded message to the Socket.IO server.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  function empty () { };

  XHR.prototype.post = function (data) {
    var self = this;
    this.socket.setBuffer(true);

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;
        self.posting = false;

        if (this.status == 200){
          self.socket.setBuffer(false);
        } else {
          self.onClose();
        }
      }
    }

    function onload () {
      this.onload = empty;
      self.socket.setBuffer(false);
    };

    this.sendXHR = this.request('POST');

    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {
      this.sendXHR.onload = this.sendXHR.onerror = onload;
    } else {
      this.sendXHR.onreadystatechange = stateChange;
    }

    this.sendXHR.send(data);
  };

  /**
   * Disconnects the established `XHR` connection.
   *
   * @returns {Transport}
   * @api public
   */

  XHR.prototype.close = function () {
    this.onClose();
    return this;
  };

  /**
   * Generates a configured XHR request
   *
   * @param {String} url The url that needs to be requested.
   * @param {String} method The method the request should use.
   * @returns {XMLHttpRequest}
   * @api private
   */

  XHR.prototype.request = function (method) {
    var req = io.util.request(this.socket.isXDomain())
      , query = io.util.query(this.socket.options.query, 't=' + +new Date);

    req.open(method || 'GET', this.prepareUrl() + query, true);

    if (method == 'POST') {
      try {
        if (req.setRequestHeader) {
          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        } else {
          // XDomainRequest
          req.contentType = 'text/plain';
        }
      } catch (e) {}
    }

    return req;
  };

  /**
   * Returns the scheme to use for the transport URLs.
   *
   * @api private
   */

  XHR.prototype.scheme = function () {
    return this.socket.options.secure ? 'https' : 'http';
  };

  /**
   * Check if the XHR transports are supported
   *
   * @param {Boolean} xdomain Check if we support cross domain requests.
   * @returns {Boolean}
   * @api public
   */

  XHR.check = function (socket, xdomain) {
    try {
      var request = io.util.request(xdomain),
          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),
          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),
          isXProtocol = (global.location && socketProtocol != global.location.protocol);
      if (request && !(usesXDomReq && isXProtocol)) {
        return true;
      }
    } catch(e) {}

    return false;
  };

  /**
   * Check if the XHR transport supports cross domain requests.
   *
   * @returns {Boolean}
   * @api public
   */

  XHR.xdomainCheck = function (socket) {
    return XHR.check(socket, true);
  };

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);
/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io) {

  /**
   * Expose constructor.
   */

  exports.htmlfile = HTMLFile;

  /**
   * The HTMLFile transport creates a `forever iframe` based transport
   * for Internet Explorer. Regular forever iframe implementations will 
   * continuously trigger the browsers buzy indicators. If the forever iframe
   * is created inside a `htmlfile` these indicators will not be trigged.
   *
   * @constructor
   * @extends {io.Transport.XHR}
   * @api public
   */

  function HTMLFile (socket) {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(HTMLFile, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  HTMLFile.prototype.name = 'htmlfile';

  /**
   * Creates a new Ac...eX `htmlfile` with a forever loading iframe
   * that can be used to listen to messages. Inside the generated
   * `htmlfile` a reference will be made to the HTMLFile transport.
   *
   * @api private
   */

  HTMLFile.prototype.get = function () {
    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
    this.doc.open();
    this.doc.write('<html></html>');
    this.doc.close();
    this.doc.parentWindow.s = this;

    var iframeC = this.doc.createElement('div');
    iframeC.className = 'socketio';

    this.doc.body.appendChild(iframeC);
    this.iframe = this.doc.createElement('iframe');

    iframeC.appendChild(this.iframe);

    var self = this
      , query = io.util.query(this.socket.options.query, 't='+ +new Date);

    this.iframe.src = this.prepareUrl() + query;

    io.util.on(window, 'unload', function () {
      self.destroy();
    });
  };

  /**
   * The Socket.IO server will write script tags inside the forever
   * iframe, this function will be used as callback for the incoming
   * information.
   *
   * @param {String} data The message
   * @param {document} doc Reference to the context
   * @api private
   */

  HTMLFile.prototype._ = function (data, doc) {
    // unescape all forward slashes. see GH-1251
    data = data.replace(/\\\//g, '/');
    this.onData(data);
    try {
      var script = doc.getElementsByTagName('script')[0];
      script.parentNode.removeChild(script);
    } catch (e) { }
  };

  /**
   * Destroy the established connection, iframe and `htmlfile`.
   * And calls the `CollectGarbage` function of Internet Explorer
   * to release the memory.
   *
   * @api private
   */

  HTMLFile.prototype.destroy = function () {
    if (this.iframe){
      try {
        this.iframe.src = 'about:blank';
      } catch(e){}

      this.doc = null;
      this.iframe.parentNode.removeChild(this.iframe);
      this.iframe = null;

      CollectGarbage();
    }
  };

  /**
   * Disconnects the established connection.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  HTMLFile.prototype.close = function () {
    this.destroy();
    return io.Transport.XHR.prototype.close.call(this);
  };

  /**
   * Checks if the browser supports this transport. The browser
   * must have an `Ac...eXObject` implementation.
   *
   * @return {Boolean}
   * @api public
   */

  HTMLFile.check = function (socket) {
    if (typeof window != "undefined" && (['Active'].concat('Object').join('X')) in window){
      try {
        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');
        return a && io.Transport.XHR.check(socket);
      } catch(e){}
    }
    return false;
  };

  /**
   * Check if cross domain requests are supported.
   *
   * @returns {Boolean}
   * @api public
   */

  HTMLFile.xdomainCheck = function () {
    // we can probably do handling for sub-domains, we should
    // test that it's cross domain but a subdomain here
    return false;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('htmlfile');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {

  /**
   * Expose constructor.
   */

  exports['xhr-polling'] = XHRPolling;

  /**
   * The XHR-polling transport uses long polling XHR requests to create a
   * "persistent" connection with the server.
   *
   * @constructor
   * @api public
   */

  function XHRPolling () {
    io.Transport.XHR.apply(this, arguments);
  };

  /**
   * Inherits from XHR transport.
   */

  io.util.inherit(XHRPolling, io.Transport.XHR);

  /**
   * Merge the properties from XHR transport
   */

  io.util.merge(XHRPolling, io.Transport.XHR);

  /**
   * Transport name
   *
   * @api public
   */

  XHRPolling.prototype.name = 'xhr-polling';

  /**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */

  XHRPolling.prototype.heartbeats = function () {
    return false;
  };

  /** 
   * Establish a connection, for iPhone and Android this will be done once the page
   * is loaded.
   *
   * @returns {Transport} Chaining.
   * @api public
   */

  XHRPolling.prototype.open = function () {
    var self = this;

    io.Transport.XHR.prototype.open.call(self);
    return false;
  };

  /**
   * Starts a XHR request to wait for incoming messages.
   *
   * @api private
   */

  function empty () {};

  XHRPolling.prototype.get = function () {
    if (!this.isOpen) return;

    var self = this;

    function stateChange () {
      if (this.readyState == 4) {
        this.onreadystatechange = empty;

        if (this.status == 200) {
          self.onData(this.responseText);
          self.get();
        } else {
          self.onClose();
        }
      }
    };

    function onload () {
      this.onload = empty;
      this.onerror = empty;
      self.retryCounter = 1;
      self.onData(this.responseText);
      self.get();
    };

    function onerror () {
      self.retryCounter ++;
      if(!self.retryCounter || self.retryCounter > 3) {
        self.onClose();  
      } else {
        self.get();
      }
    };

    this.xhr = this.request();

    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {
      this.xhr.onload = onload;
      this.xhr.onerror = onerror;
    } else {
      this.xhr.onreadystatechange = stateChange;
    }

    this.xhr.send(null);
  };

  /**
   * Handle the unclean close behavior.
   *
   * @api private
   */

  XHRPolling.prototype.onClose = function () {
    io.Transport.XHR.prototype.onClose.call(this);

    if (this.xhr) {
      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
      try {
        this.xhr.abort();
      } catch(e){}
      this.xhr = null;
    }
  };

  /**
   * Webkit based browsers show a infinit spinner when you start a XHR request
   * before the browsers onload event is called so we need to defer opening of
   * the transport until the onload event is called. Wrapping the cb in our
   * defer method solve this.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  XHRPolling.prototype.ready = function (socket, fn) {
    var self = this;

    io.util.defer(function () {
      fn.call(self);
    });
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('xhr-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

/**
 * socket.io
 * Copyright(c) 2011 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

(function (exports, io, global) {
  /**
   * There is a way to hide the loading indicator in Firefox. If you create and
   * remove a iframe it will stop showing the current loading indicator.
   * Unfortunately we can't feature detect that and UA sniffing is evil.
   *
   * @api private
   */

  var indicator = global.document && "MozAppearance" in
    global.document.documentElement.style;

  /**
   * Expose constructor.
   */

  exports['jsonp-polling'] = JSONPPolling;

  /**
   * The JSONP transport creates an persistent connection by dynamically
   * inserting a script tag in the page. This script tag will receive the
   * information of the Socket.IO server. When new information is received
   * it creates a new script tag for the new data stream.
   *
   * @constructor
   * @extends {io.Transport.xhr-polling}
   * @api public
   */

  function JSONPPolling (socket) {
    io.Transport['xhr-polling'].apply(this, arguments);

    this.index = io.j.length;

    var self = this;

    io.j.push(function (msg) {
      self._(msg);
    });
  };

  /**
   * Inherits from XHR polling transport.
   */

  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);

  /**
   * Transport name
   *
   * @api public
   */

  JSONPPolling.prototype.name = 'jsonp-polling';

  /**
   * Posts a encoded message to the Socket.IO server using an iframe.
   * The iframe is used because script tags can create POST based requests.
   * The iframe is positioned outside of the view so the user does not
   * notice it's existence.
   *
   * @param {String} data A encoded message.
   * @api private
   */

  JSONPPolling.prototype.post = function (data) {
    var self = this
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (!this.form) {
      var form = document.createElement('form')
        , area = document.createElement('textarea')
        , id = this.iframeId = 'socketio_iframe_' + this.index
        , iframe;

      form.className = 'socketio';
      form.style.position = 'absolute';
      form.style.top = '0px';
      form.style.left = '0px';
      form.style.display = 'none';
      form.target = id;
      form.method = 'POST';
      form.setAttribute('accept-charset', 'utf-8');
      area.name = 'd';
      form.appendChild(area);
      document.body.appendChild(form);

      this.form = form;
      this.area = area;
    }

    this.form.action = this.prepareUrl() + query;

    function complete () {
      initIframe();
      self.socket.setBuffer(false);
    };

    function initIframe () {
      if (self.iframe) {
        self.form.removeChild(self.iframe);
      }

      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = document.createElement('<iframe name="'+ self.iframeId +'">');
      } catch (e) {
        iframe = document.createElement('iframe');
        iframe.name = self.iframeId;
      }

      iframe.id = self.iframeId;

      self.form.appendChild(iframe);
      self.iframe = iframe;
    };

    initIframe();

    // we temporarily stringify until we figure out how to prevent
    // browsers from turning `\n` into `\r\n` in form inputs
    this.area.value = io.JSON.stringify(data);

    try {
      this.form.submit();
    } catch(e) {}

    if (this.iframe.attachEvent) {
      iframe.onreadystatechange = function () {
        if (self.iframe.readyState == 'complete') {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }

    this.socket.setBuffer(true);
  };

  /**
   * Creates a new JSONP poll that can be used to listen
   * for messages from the Socket.IO server.
   *
   * @api private
   */

  JSONPPolling.prototype.get = function () {
    var self = this
      , script = document.createElement('script')
      , query = io.util.query(
             this.socket.options.query
          , 't='+ (+new Date) + '&i=' + this.index
        );

    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }

    script.async = true;
    script.src = this.prepareUrl() + query;
    script.onerror = function () {
      self.onClose();
    };

    var insertAt = document.getElementsByTagName('script')[0];
    insertAt.parentNode.insertBefore(script, insertAt);
    this.script = script;

    if (indicator) {
      setTimeout(function () {
        var iframe = document.createElement('iframe');
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  };

  /**
   * Callback function for the incoming message stream from the Socket.IO server.
   *
   * @param {String} data The message
   * @api private
   */

  JSONPPolling.prototype._ = function (msg) {
    this.onData(msg);
    if (this.isOpen) {
      this.get();
    }
    return this;
  };

  /**
   * The indicator hack only works after onload
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */

  JSONPPolling.prototype.ready = function (socket, fn) {
    var self = this;
    if (!indicator) return fn.call(this);

    io.util.load(function () {
      fn.call(self);
    });
  };

  /**
   * Checks if browser supports this transport.
   *
   * @return {Boolean}
   * @api public
   */

  JSONPPolling.check = function () {
    return 'document' in global;
  };

  /**
   * Check if cross domain requests are supported
   *
   * @returns {Boolean}
   * @api public
   */

  JSONPPolling.xdomainCheck = function () {
    return true;
  };

  /**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */

  io.transports.push('jsonp-polling');

})(
    'undefined' != typeof io ? io.Transport : module.exports
  , 'undefined' != typeof io ? io : module.parent.exports
  , this
);

if (typeof define === "function" && define.amd) {
  define([], function () { return io; });
}
})();
},{}],28:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],29:[function(require,module,exports){
var utility = require('./utility/utility.js'),
    ConnectionEvents = require('./connection/ConnectionEvents.js'),
    ConnectionStreams = require('./connection/ConnectionStreams.js'),
    ConnectionProfile = require('./connection/ConnectionProfile.js'),
    ConnectionBookmarks = require('./connection/ConnectionBookmarks.js'),
    ConnectionAccesses = require('./connection/ConnectionAccesses.js'),
    ConnectionMonitors = require('./connection/ConnectionMonitors.js'),
    ConnectionAccount = require('./connection/ConnectionAccount.js'),
    CC = require('./connection/ConnectionConstants.js'),
    Datastore = require('./Datastore.js'),
    _ = require('underscore');

/**
 * @class Connection
 * Create an instance of Connection to Pryv API.
 * The connection will be opened on
 * http[s]://&lt;username>.&lt;domain>:&lt;port>/&lt;extraPath>?auth=&lt;auth>
 *
 * @example
 * // create a connection for the user 'pryvtest' with the token 'TTZycvBTiq'
 * var conn = new pryv.Connection({username: 'pryvtest', auth: 'TTZycvBTiq'});
 *
 * @constructor
 * @this {Connection}
 * @param {Object} [settings]
 * @param {string} settings.username
 * @param {string} settings.auth - the authorization token for this username
 * @param {number} [settings.port = 443]
 * @param {string} [settings.domain = 'pryv.me'] change the domain.
 * @param {boolean} [settings.ssl = true] Use ssl (https) or no
 * @param {string} [settings.extraPath = ''] append to the connections. Must start with a '/'
 */
module.exports = Connection;
function Connection() {
  var settings;
  if (!arguments[0] || typeof arguments[0] === 'string') {
    console.warn('new Connection(username, auth, settings) is deprecated.',
      'Please use new Connection(settings)', arguments);
    this.username = arguments[0];
    this.auth = arguments[1];
    settings = arguments[2];
  } else {
    settings = arguments[0];
    this.username = settings.username;
    this.auth = settings.auth;
    if (settings.url) {
      var urlInfo = utility.urls.parseServerURL(settings.url);
      this.username = urlInfo.username;
      settings.hostname = urlInfo.hostname;
      settings.domain = urlInfo.domain;
      settings.port = urlInfo.port;
      settings.extraPath = urlInfo.path === '/' ? '' : urlInfo.path;
      settings.ssl = urlInfo.isSSL();
    }
  }
  this._serialId = Connection._serialCounter++;

  this.settings = _.extend({
    port: 443,
    ssl: true,
    extraPath: '',
    staging: false
  }, settings);

  this.settings.domain = settings.domain ?
      settings.domain : utility.urls.defaultDomain;

  this.serverInfos = {
    // nowLocalTime - nowServerTime
    deltaTime: null,
    apiVersion: null,
    lastSeenLT: null,
    lastSeenST: null,
  };

  this._accessInfo = null;
  this._privateProfile = null;

  this._streamSerialCounter = 0;
  this._eventSerialCounter = 0;

  /**
   * Manipulate events for this connection
   * @type {ConnectionEvents}
   */
  this.events = new ConnectionEvents(this);
  /**
   * Manipulate streams for this connection
   * @type {ConnectionStreams}
   */
  this.streams = new ConnectionStreams(this);
  /**
  * Manipulate app profile for this connection
  * @type {ConnectionProfile}
  */
  this.profile = new ConnectionProfile(this);
  /**
  * Manipulate bookmarks for this connection
  * @type {ConnectionProfile}
  */
  this.bookmarks = new ConnectionBookmarks(this, Connection);
  /**
  * Manipulate accesses for this connection
  * @type {ConnectionProfile}
  */
  this.accesses = new ConnectionAccesses(this);
  /**
   * Manipulate this connection monitors
   */
  this.monitors = new ConnectionMonitors(this);

  this.account = new ConnectionAccount(this);
  this.datastore = null;

}

Connection._serialCounter = 0;


/**
 * In order to access some properties such as event.stream and get a {Stream} object, you
 * need to fetch the structure at least once. For now, there is now way to be sure that the
 * structure is up to date. Soon we will implement an optional parameter "keepItUpToDate", that
 * will do that for you.
 *
 * TODO implements "keepItUpToDate" logic.
 * @param {Streams~getCallback} callback - array of "root" Streams
 * @returns {Connection} this
 */
Connection.prototype.fetchStructure = function (callback /*, keepItUpToDate*/) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (this.datastore) { return this.datastore.init(callback); }
  this.datastore = new Datastore(this);
  this.accessInfo(function (error) {
    if (error) { return callback(error); }
    this.datastore.init(callback);
  }.bind(this));
  return this;
};


/**
 * Set username / auth to this Connection
 * @param credentials key / value map containing username and token fields
 * @param callback
 */
Connection.prototype.attachCredentials = function (credentials, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (!credentials.username || !credentials.auth) {
    callback('error: incorrect input parameters');
  } else {
    this.username = credentials.username;
    this.auth = credentials.auth;
    callback(null, this);
  }
};

/**
 * Get access information related this connection. This is also the best way to test
 * that the combination username/token is valid.
 * @param {Connection~accessInfoCallback} callback
 * @returns {Connection} this
 */
Connection.prototype.accessInfo = function (callback) {
  if (this._accessInfo) {
    return this._accessInfo;
  }
  this.request({
    method: 'GET',
    path: '/access-info',
    callback: function (error, result) {
      if (!error) {
        this._accessInfo = result;
      }
      if (typeof(callback) === 'function') {
        return callback(error, result);
      }
    }.bind(this)
  });
  return this;
};

/**
 * Get the private profile related this connection.
 * @param {Connection~privateProfileCallback} callback
 * @returns {Connection} this
 */
Connection.prototype.privateProfile = function (callback) {
  if (this._privateProfile) {
    return this._privateProfile;
  }
  this.profile.getPrivate(null, function (error, result) {
    if (result && result.message) {
      error = result;
    }
    if (!error) {
      this._privateProfile = result;
    }
    if (typeof(callback) === 'function') {
      return callback(error, result);
    }
  }.bind(this));
  return this;
};

/**
 * Translate this timestamp (server dimension) to local system dimension
 * This could have been named to "translate2LocalTime"
 * @param {number} serverTime timestamp  (server dimension)
 * @returns {number} timestamp (local dimension) same time space as (new Date()).getTime();
 */
Connection.prototype.getLocalTime = function (serverTime) {
  return (serverTime + this.serverInfos.deltaTime) * 1000;
};

/**
 * Translate this timestamp (local system dimension) to server dimension
 * This could have been named to "translate2ServerTime"
 * @param {number} localTime timestamp  (local dimension) same time space as (new Date()).getTime();
 * @returns {number} timestamp (server dimension)
 */
Connection.prototype.getServerTime = function (localTime) {
  if (typeof localTime === 'undefined') { localTime = new Date().getTime(); }
  return (localTime / 1000) - this.serverInfos.deltaTime;
};


// ------------- monitor this connection --------//

/**
 * Start monitoring this Connection. Any change that occurs on the connection (add, delete, change)
 * will trigger an event. Changes to the filter will also trigger events if they have an impact on
 * the monitored data.
 * @param {Filter} filter - changes to this filter will be monitored.
 * @returns {Monitor}
 */
Connection.prototype.monitor = function (filter) {
  return this.monitors.create(filter);
};

// ------------- start / stop Monitoring is called by Monitor constructor / destructor -----//



/**
 * Do a direct request to Pryv's API.
 * Even if exposed there must be an abstraction for every API call in this library.
 * @param {Object} params object with
 * @param {string} params.method - GET | POST | PUT | DELETE
 * @param {string} params.path - to resource, starting with '/' like '/events'
 * @param {Object} params.jsonData - data to POST or PUT
 * @param {Boolean} params.isFile indicates if the data is a binary file.
 * @params {string} [params.parseResult = 'json'] - 'json|binary'
 * @param {Connection~requestCallback} params.callback called when the request is finished
 * @param {Connection~requestCallback} params.progressCallback called when the request gives
 * progress updates
 */
Connection.prototype.request = function (params) {

  if (arguments.length > 1) {
    console.warn('Connection.request(method, path, callback, jsonData, isFile, progressCallback)' +
    ' is deprecated. Please use Connection.request(params).', arguments);
    params = {};
    params.method = arguments[0];
    params.path = arguments[1];
    params.callback = arguments[2];
    params.jsonData = arguments[3];
    params.isFile = arguments[4];
    params.progressCallback = arguments[5];
  }

  if (typeof(params.callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  var headers =  { 'authorization': this.auth };
  var withoutCredentials = false;
  var payload = JSON.stringify({});
  if (params.jsonData && !params.isFile) {
    payload = JSON.stringify(params.jsonData);
    headers['Content-Type'] = 'application/json; charset=utf-8';
  }
  if (params.isFile) {
    payload = params.jsonData;
    headers['Content-Type'] = 'multipart/form-data';
    headers['X-Requested-With'] = 'XMLHttpRequest';
    withoutCredentials = true;
  }

  var request = utility.request({
    method : params.method,
    host : getHostname(this),
    port : this.settings.port,
    ssl : this.settings.ssl,
    path : this.settings.extraPath + params.path,
    headers : headers,
    payload : payload,
    progressCallback: params.progressCallback,
    //TODO: decide what callback convention to use (Node or jQuery)
    success : onSuccess.bind(this),
    error : onError.bind(this),
    withoutCredentials: withoutCredentials,
    parseResult: params.parseResult
  });

  /**
   * @this {Connection}
   */
  function onSuccess(data, responseInfo) {

    var apiVersion = responseInfo.headers['API-Version'] ||
      responseInfo.headers[CC.Api.Headers.ApiVersion];

    // test if API is reached or if we headed into something else
    if (!apiVersion) {
      var error = {
        id: CC.Errors.API_UNREACHEABLE,
        message: 'Cannot find API-Version',
        details: 'Response code: ' + responseInfo.code +
        ' Headers: ' + JSON.stringify(responseInfo.headers)
      };
      return params.callback(error, null, responseInfo);
    } else if (data.error) {
      return params.callback(data.error, null, responseInfo);
    }
    this.serverInfos.lastSeenLT = (new Date()).getTime();
    this.serverInfos.apiVersion = apiVersion || this.serverInfos.apiVersion;
    if (_.has(responseInfo.headers, CC.Api.Headers.ServerTime)) {
      this.serverInfos.deltaTime = (this.serverInfos.lastSeenLT / 1000) -
      responseInfo.headers[CC.Api.Headers.ServerTime];
      this.serverInfos.lastSeenST = CC.Api.Headers.ServerTime;
    }


    if (data && data.meta) {
      responseInfo.meta = data.meta;
    }


    params.callback(null, data, responseInfo);
  }

  function onError(error, responseInfo) {
    var errorTemp = {
      id : CC.Errors.API_UNREACHEABLE,
      message: 'Error on request ',
      details: 'ERROR: ' + error
    };
    params.callback(errorTemp, null, responseInfo);
  }
  return request;
};



/**
 * @property {string} Connection.id an unique id that contains all needed information to access
 * this Pryv data source. http[s]://<username>.<domain>:<port>[/extraPath]/?auth=<auth token>
 */
Object.defineProperty(Connection.prototype, 'id', {
  get: function () {
    var id = this.settings.ssl ? 'https://' : 'http://';
    id += getHostname(this) + ':' +
        this.settings.port + this.settings.extraPath + '/?auth=' + this.auth;
    return id;
  },
  set: function () { throw new Error('ConnectionNode.id property is read only'); }
});

/**
 * @property {string} Connection.displayId an id easily readable <username>:<access name>
 */
Object.defineProperty(Connection.prototype, 'displayId', {
  get: function () {
    if (! this._accessInfo) {
      throw new Error('connection must have been initialized to use displayId. ' +
        ' You can call accessInfo() for this');
    }
    var id = this.username + ':' + this._accessInfo.name;
    return id;
  },
  set: function () { throw new Error('Connection.displayId property is read only'); }
});

/**
 * @property {String} Connection.serialId A locally-unique id for the connection; can also be
 *                                        used as a client-side id
 */
Object.defineProperty(Connection.prototype, 'serialId', {
  get: function () { return 'C' + this._serialId; }
});
/**
 * Called with the desired Streams as result.
 * @callback Connection~accessInfoCallback
 * @param {Object} error - eventual error
 * @param {AccessInfo} result
 */

/**
 * @typedef AccessInfo
 * @see http://api.pryv.com/reference.html#data-structure-access
 */

/**
 * Called with the result of the request
 * @callback Connection~requestCallback
 * @param {Object} error - eventual error
 * @param {Object} result - jSonEncoded result
 * @param {Object} resultInfo
 * @param {Number} resultInfo.code - HTTP result code
 * @param {Object} resultInfo.headers - HTTP result headers by key
 */

// --------- login


/**
 * static method to login, returns a connection object in the callback if the username/password
 * pair is valid for the provided appId.
 *
 * @param params key / value map containing username, password and appId fields and optional
 * domain and origin fields
 * @param callback
 */
Connection.login = function (params, callback) {

  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }

  var headers = {
    'Content-Type': 'application/json'
  };

  if (!utility.isBrowser()) {
    var origin = 'https://sw.';
    origin = params.origin ? origin + params.origin :
    origin + utility.urls.domains.client.production;
    _.extend(headers, {Origin: origin});
  }

  var domain = params.domain || utility.urls.domains.client.production;

  var pack = {
    method: 'POST',
    headers: headers,
    ssl: true,
    host: params.username + '.' + domain,
    path: '/auth/login/',
    payload: JSON.stringify({
      appId: params.appId,
      username: params.username,
      password: params.password
    }),

    success: function (data, responseInfo) {
      if (data.error) {
        return callback(data.error, null, responseInfo);
      }
      var settings = {
        username: params.username,
        auth: data.token,
        domain: domain
        // TODO: set staging if in this mode
      };
      return callback(null, new Connection(settings), responseInfo);
    },

    error: function (error, responseInfo) {
      callback(error, null, responseInfo);
    }
  };

  utility.request(pack);
};


// --------- batch call

/**
 * address multiple methods to the API in a single batch call
 *
 * @example
 * // make a batch call to create an event and update a stream
 *  connection.batchCall(
 *  [
 *    { method: 'events.create',
 *      params: {
 *        streamId: 'diary',
 *        type: 'note/txt',
 *        content: 'hello'
 *     }
 *    },
 *    { method: 'streams.update',
 *      params: {
 *        id': 'diary',
 *        params: {
 *          update: { name: 'new diary' }
 *    }
 *  ], function (err, results) {
 *    if (err) {
 *      return console.log(err);
 *    }
 *    results.forEach(function (result) {
 *      console.log(result);
 *    }
 *  });
 * @param {Array} methodsData - array of methods to execute on the API,
 * @param {Function} callback - callback
 */
Connection.prototype.batchCall = function(methodsData, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (!_.isArray(methodsData)) { methodsData = [methodsData]; }

  this.request({
    method: 'POST',
    path: '/',
    jsonData: methodsData,
    callback: function (err, res) {

      if (err) {
        return callback(err);
      }
      callback(null, res.results);
    }.bind(this)
  });
};


// --------- private utils

function getHostname(connection) {
  return connection.settings.hostname ||
      connection.username ?
      connection.username + '.' + connection.settings.domain : connection.settings.domain;
}

},{"./Datastore.js":30,"./connection/ConnectionAccesses.js":38,"./connection/ConnectionAccount.js":39,"./connection/ConnectionBookmarks.js":40,"./connection/ConnectionConstants.js":41,"./connection/ConnectionEvents.js":42,"./connection/ConnectionMonitors.js":43,"./connection/ConnectionProfile.js":44,"./connection/ConnectionStreams.js":45,"./utility/utility.js":60,"underscore":28}],30:[function(require,module,exports){
/**
 * DataStore handles in memory caching of objects.
 * @private
 */

var _ = require('underscore');
var Event = require('./Event');
var Stream = require('./Stream');

function Datastore(connection) {
  this.connection = connection;
  this.streamsIndex = {}; // streams are linked to their object representation
  this.eventIndex = {}; // events are store by their id
  this.rootStreams = [];
  this.rootStreamsAll = []; // including trashed streams
}

module.exports = Datastore;

Datastore.prototype.init = function (callback) {
  this.connection.streams._getObjects({state: 'all'}, function (error, result) {
    if (error) { return callback('Datastore faild to init - '  + error); }
    if (result) {
      this._rebuildStreamIndex(result); // maybe done transparently
    }
    callback(null, result);
  }.bind(this));

  // TODO activate monitoring
};

Datastore.prototype._rebuildStreamIndex = function (streamArray) {
  this.streamsIndex = {};
  this.rootStreams = [];
  this.rootStreamsAll = [];
  this._indexStreamArray(streamArray);
};

Datastore.prototype._indexStreamArray = function (streamArray) {
  _.each(streamArray, function (stream) {
    this.indexStream(stream);
  }.bind(this));
};

Datastore.prototype.indexStream = function (stream) {
  this.streamsIndex[stream.id] = stream;
  if (! stream.parentId) {
    this.rootStreamsAll.push(stream);
    if (! stream.trashed) {
      this.rootStreams.push(stream);
    }
  }
  this._indexStreamArray(stream._children);
  delete stream._children; // cleanup when in datastore mode
  delete stream._parent;
};

/**
 *
 * @param all True to get all root streams including trashed one
 * @returns Stream or null if not found
 */
Datastore.prototype.getStreams = function (all) {
  if (all) { return this.rootStreamsAll; }
  return this.rootStreams;
};


/**
 *
 * @param streamId
 * @param test (do no throw error if Stream is not found
 * @returns Stream or null if not found
 */
Datastore.prototype.getStreamById = function (streamId) {
  var result = this.streamsIndex[streamId];
  return result;
};

//-------------------------

/**
 * @param serialId
 * @returns Event or null if not found
 */
Datastore.prototype.getEventBySerialId = function (serialId) {
  var result = null;
  _.each(this.eventIndex, function (event /*,eventId*/) {
    if (event.serialId === serialId) { result = event; }
    // TODO optimize and break
  }.bind(this));
  return result;
};

/**
 * @param eventID
 * @returns Event or null if not found
 */
Datastore.prototype.getEventById = function (eventId) {
  return this.eventIndex[eventId];

};

/**
 * @returns allEvents
 */
Datastore.prototype.getEventsMatchingFilter = function (filter) {
  var result = [];
  _.each(this.eventIndex, function (event /*,eventId*/) {
    if (filter.matchEvent(event)) { result.push(event); }
  }.bind(this));
  return result;
};


/**
 * @returns allEvents
 */
Datastore.prototype.getAllEvents = function () {
  return _.value(this.eventIndex);
};

/**
 * @param event
 */
Datastore.prototype.addEvent = function (event) {
  if (! event.id) {
    throw new Error('Datastore.addEvent cannot add event with unkown id', event);
  }
  this.eventIndex[event.id] = event;
};



/**
 * @param {Object} data to map
 * @return {Event} event
 */
Datastore.prototype.createOrReuseEvent = function (data) {
  if (! data.id) {
    throw new Error('Datastore.createOrReuseEvent cannot create event with ' +
      ' unkown id' + require('util').inspect(data));
  }

  var result = this.getEventById(data.id);
  if (result) {  // found event
    _.extend(result, data);
    return result;
  }
  // create an event and register it
  result = new Event(this.connection, data);
  this.addEvent(result);

  return result;
};


/**
 * @param {Object} data to map
 * @return {Event} event
 */
Datastore.prototype.createOrReuseStream = function (data) {
    if (! data.id) {
        throw new Error('Datastore.createOrReuseStream cannot create stream with ' +
            ' unkown id' + require('util').inspect(data));
    }

    var result = this.getStreamById(data.id);
    if (result) {  // found event
        _.extend(result, data);
        return result;
    }
    // create an stream and register it
    result = new Stream(this.connection, data);
    this.indexStream(result);

    return result;
};



},{"./Event":31,"./Stream":34,"underscore":28,"util":110}],31:[function(require,module,exports){

var _ = require('underscore');

var RW_PROPERTIES =
  ['streamId', 'time', 'duration', 'type', 'content', 'tags', 'description',
    'clientData', 'state', 'modified', 'trashed'];


var escapeHtml = function (obj) {
  _.each(obj, function (value, key) {
    if (_.isString(value)) {
      obj[key] = _.escape(value);
    } else if ((key === 'content' && _.isObject(value)) || (key === 'tags' && _.isArray(value))) {
      escapeHtml(value);
    }
  });
};
/**
 *
 * @type {Function}
 * @constructor
 */
var Event = module.exports = function Event(connection, data) {
  if (! connection) {
    throw new Error('Cannot create connection less events');
  }
  this.connection = connection;
  this.trashed = false;
  this.serialId = this.connection.serialId + '>E' + this.connection._eventSerialCounter++;
  _.extend(this, data);
};

/**
 * get Json object ready to be posted on the API
 */
Event.prototype.getData = function () {
  var data = {};
  _.each(RW_PROPERTIES, function (key) { // only set non null values
    if (_.has(this, key)) { data[key] = this[key]; }
  }.bind(this));
  return data;
};
/**
 *
 * @param {Connection~requestCallback} callback
 */
Event.prototype.update = function (callback) {
  this.connection.events.update(this, callback);
};
/**
 *
 * @param {Connection~requestCallback} callback
 */
Event.prototype.addAttachment = function (file, callback) {
  this.connection.events.addAttachment(this.id, file, callback);
};
/**
 *
 * @param {Connection~requestCallback} callback
 */
Event.prototype.removeAttachment = function (fileName, callback) {
  this.connection.events.removeAttachment(this.id, fileName, callback);
};
/**
 * TODO create an attachment Class that contains such logic
 * @param {attachment} attachment
 */
Event.prototype.attachmentUrl = function (attachment) {
  var url =  this.connection.settings.ssl ? 'https://' : 'http://';
  url += this.connection.username + '.' + this.connection.settings.domain + '/events/' +
    this.id + '/' + attachment.id + '?readToken=' + attachment.readToken;
  return url;
};
/**
 *
 * @param {Connection~requestCallback} callback
 */
Event.prototype.delete = Event.prototype.trash = function (callback) {
  this.connection.events.trash(this, callback);
};
/**
 * TODO document and rename to getPicturePreviewUrl
 * @param width
 * @param height
 * @returns {string}
 */
Event.prototype.getPicturePreview = function (width, height) {
  width = width ? '&w=' + width : '';
  height = height ? '&h=' + height : '';
  var url = this.connection.settings.ssl ? 'https://' : 'http://';
  url += this.connection.username + '.' + this.connection.settings.domain + '/previews/events/' +
    this.id + '?auth=' + this.connection.auth + width + height;
  return url;
};

Event.prototype.isRunning = function () {
  return !!('duration' in this && !this.duration && this.duration !== 0);
};
/**
 * TODO document
 */
Object.defineProperty(Event.prototype, 'timeLT', {
  get: function () {
    return this.connection.getLocalTime(this.time);
  },
  set: function (newValue) {
    this.time = this.connection.getServerTime(newValue);
  }
});



/**
 * TODO document
 */
Object.defineProperty(Event.prototype, 'stream', {
  get: function () {
    if (! this.connection.datastore) {
      throw new Error('call connection.fetchStructure before to get automatic stream mapping.' +
        ' Or use StreamId');
    }
    return this.connection.datastore.getStreamById(this.streamId);
  },
  set: function () { throw new Error('Event.stream property is read only'); }
});

/**
 * TODO document
 */
Object.defineProperty(Event.prototype, 'url', {
  get: function () {
    var url = this.connection.settings.ssl ? 'https://' : 'http://';
    url += this.connection.username + '.' + this.connection.settings.domain + '/events/' + this.id;
    return url;
  },
  set: function () { throw new Error('Event.url property is read only'); }
});


/**
 * An newly created Event (no id, not synched with API)
 * or an object with sufficient properties to be considered as an Event.
 * @typedef {(Event|Object)} NewEventLike
 * @property {String} streamId
 * @property {String} type
 * @property {number} [time]
 */

},{"underscore":28}],32:[function(require,module,exports){
var _ = require('underscore'),
    SignalEmitter = require('./utility/SignalEmitter.js');

/**
 * TODO Filter is badly missing a correct documentation
 * @constructor
 */
var Filter = module.exports = function Filter(settings) {
  SignalEmitter.extend(this, Messages, 'Filter');

  this._settings = _.extend({
    //TODO: set default values
    streams: null, //ids
    tags: null,
    fromTime: null,  // serverTime
    toTime: null,  // serverTime
    limit: null,
    skip: null,
    types: null,
    modifiedSince: null,
    state: null
  }, settings);
};

var Messages = Filter.Messages = {
  /**
   * generic change event called on any change
   * content: {filter, signal, content}
   **/
  ON_CHANGE : 'changed',
  /**
   * called on streams changes
   * content: streams
   */
  STREAMS_CHANGE : 'streamsChanged',

  /**
   * called on streams structure changes
   * content: changes
   */
  STRUCTURE_CHANGE : 'structureChange',

  /*
   * called on date changes
   * content: streams
   */
  DATE_CHANGE : 'timeFrameChanged',

  /*
   * called on state changes
   * content: {state: value}
   */
  STATE_CHANGE : 'stateChanged'
};

// TODO
// redundant with get
function _normalizeTimeFrameST(filterData) {
  var result = [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY];
  if (filterData.fromTime || filterData.fromTime === 0) {
    result[0] = filterData.fromTime;
  }
  if (filterData.toTime || filterData.toTime === 0) {
    result[1] = filterData.toTime;
  }
  return result;
}



/**
 * TODO write doc
 * TODO complete with tags and state and modified and..
 * check if this event is in this filter
 */
Filter.prototype.matchEvent = function (event) {
  if (event.time > this.toTimeSTNormalized) { return false; }
  if (event.time < this.fromTimeSTNormalized) { return false; }


  if (this._settings.state !== 'all') {
    if (event.trashed) { return false; }
  }

  if (this._settings.streams) {

    if (this._settings.streams.length === 0) { return false; }

    if (this._settings.streams.indexOf(event.streamId) < 0) {
      var found = false;
      if (!event.stream) {
        return false;
      }
      event.stream.ancestors.forEach(function (ancestor) {
        if (this._settings.streams.indexOf(ancestor.id) >= 0) {
          if (this._settings.state !== 'all') {
            if (ancestor.trashed) { return false; }
          }
          found = true;
        }
      }.bind(this));
      if (!found) {
        return false;
      }
    }
  }



  // TODO complete test
  return true;
};

/**
 * Compare this filter with data form another filter
 * @param {Object} filterDataTest data got with filter.getData
 * @returns keymap \{ timeFrame : -1, 0 , 1 \}
 * (1 = more than test, -1 = less data than test, 0 == no changes)
 */
Filter.prototype.compareToFilterData = function (filterDataTest) {
  var result = { timeFrame : 0, streams : 0 };


  // timeFrame
  var myTimeFrameST = [this.fromTimeSTNormalized, this.toTimeSTNormalized];
  var testTimeFrameST = _normalizeTimeFrameST(filterDataTest);
  console.log(myTimeFrameST);
  console.log(testTimeFrameST);

  if (myTimeFrameST[0] < testTimeFrameST[0]) {
    result.timeFrame = 1;
  } else if (myTimeFrameST[0] > testTimeFrameST[0]) {
    result.timeFrame = -1;
  }
  if (result.timeFrame <= 0) {
    if (myTimeFrameST[1] > testTimeFrameST[1]) {
      result.timeFrame = 1;
    } else  if (myTimeFrameST[1] < testTimeFrameST[1]) {
      result.timeFrame = -1;
    }
  }

  // streams
  //TODO look if this processing can be optimized

  var nullStream = 0;
  if (! this._settings.streams) {
    if (filterDataTest.streams) {
      result.streams = 1;
    }
    nullStream = 1;
  }
  if (! filterDataTest.streams) {
    if (this._settings.streams) {
      result.streams = -1;
    }
    nullStream = 1;
  }

  if (! nullStream) {
    var notinTest = _.difference(this._settings.streams, filterDataTest.streams);
    if (notinTest.length > 0) {
      result.streams = 1;
    } else {
      var notinLocal = _.difference(filterDataTest.streams, this._settings.streams);
      if (notinLocal.length > 0) {
        result.streams = -1;
      }
    }
  }

  return result;
};

/**
 * Create a clone of this filter and changes some properties
 * @param properties
 * @returns pryv.Filter
 */
Filter.prototype.cloneWithDelta = function (properties) {
  var newProps = _.clone(this._settings);
  _.extend(newProps, properties);
  return new Filter(newProps);
};

/**
 * returns a dictionary containing all the settings of this filter.
 * @param ignoreNulls (optional) boolean
 * @param withDelta (optional) adds this differences on the data
 * @returns {*}
 */
Filter.prototype.getData = function (ignoreNulls, withDelta) {
  ignoreNulls = ignoreNulls || false;
  var result = _.clone(this._settings);
  if (withDelta)  {
    _.extend(result, withDelta);
  }
  if (ignoreNulls) {
    _.each(_.keys(result), function (key) {
      if ((result[key] === null)) {
        delete result[key];
      }
    });
  }
  return result;
};

/**
 * @private
 */
Filter.prototype._fireFilterChange = function (signal, content, batch) {
  // generic
  this._fireEvent(Messages.ON_CHANGE, {filter: this, signal: signal, content: content}, batch);
  // specific
  this._fireEvent(signal, content, batch);
};

/**
 * TODO review documentation and add example
 * Change several values of the filter in batch.. this wil group all events behind a batch id
 * @param keyValueMap {Object}
 * @param batch {SignalEmitter~Batch}
 */
Filter.prototype.set = function (keyValueMap, batch) {
  batch = this.startBatch('set', batch);

  _.each(keyValueMap, function (value, key) {
    this._setValue(key, value, batch);
  }.bind(this));

  batch.done('set');
};

/**
 * Internal that take in charge of changing values
 * @param keyValueMap
 * @param batch
 * @private
 */
Filter.prototype._setValue = function (key, newValue, batch) {
  batch = this.startBatch('setValue:' + key, batch);

  if (key === 'limit') {
    this._settings.limit = newValue;

    // TODO handle changes
    return;
  }


  if (key === 'state') {
    if (this._settings.state !== newValue) {
      this._settings.state = newValue;
      this._fireFilterChange(Messages.STATE_CHANGE, {state: newValue}, batch);
    }
    batch.done('setValue:' + key);
    return;
  }

  if (key === 'timeFrameST') {
    if (! _.isArray(newValue) || newValue.length !== 2) {
      throw new Error('Filter.timeFrameST is an Array of two timestamps [fromTime, toTime]');
    }
    if (this._settings.fromTime !== newValue[0] || this._settings.toTime !== newValue[1]) {
      this._settings.fromTime = newValue[0];
      this._settings.toTime = newValue[1];
      this._fireFilterChange(Messages.DATE_CHANGE, this.timeFrameST, batch);
    }
    batch.done('setValue:' + key);
    return;
  }

  if (key === 'streamsIds') {

    if (newValue === null || typeof newValue === 'undefined') {
      if (this._settings.streams === null) {

        return;
      }
      newValue = null;
    } else if (! _.isArray(newValue)) {
      newValue = [newValue];
    }

    // TODO check that this stream is valid
    this._settings.streams = newValue;
    this._fireFilterChange(Messages.STREAMS_CHANGE, this.streams, batch);
    batch.done('setValue:' + key);
    return;
  }

  batch.done('setValue:' + key);
  throw new Error('Filter has no property : ' + key);
};

/**
 * get toTime, return Number.POSITIVE_INFINITY if null
 */
Object.defineProperty(Filter.prototype, 'toTimeSTNormalized', {
  get: function () {
    if (this._settings.toTime || this._settings.toTime === 0) {
      return this._settings.toTime;
    }
    return Number.POSITIVE_INFINITY;
  }
});

/**
 * get fromTime, return Number.POSITIVE_INFINITY if null
 */
Object.defineProperty(Filter.prototype, 'fromTimeSTNormalized', {
  get: function () {
    if (this._settings.fromTime || this._settings.fromTime === 0) {
      return this._settings.fromTime;
    }
    return Number.NEGATIVE_INFINITY;
  }
});



/**
 * timeFrameChange ..  [fromTime, toTime]
 * setting them to "null" => ALL
 */
Object.defineProperty(Filter.prototype, 'timeFrameST', {
  get: function () {
    return [this._settings.toTime, this._settings.fromTime];
  },
  set: function (newValue) {
    this._setValue('timeFrameST', newValue);
    return this.timeFrameST;
  }
});


/**
 * StreamIds ..
 * setting them to "null" => ALL and to "[]" => NONE
 */
Object.defineProperty(Filter.prototype, 'streamsIds', {
  get: function () {
    return this._settings.streams;
  },
  set: function (newValue) {
    this._setValue('streamsIds', newValue);
    return this._settings.streams;
  }
});


/**
 * return true if context (stream is on a single stream)
 * This is usefull to check when creating and event in a context.
 * This way, no need to ask the user for a stream specification.
 * TODO determine if this should stay in the lib.. or handle by apps
 */
Filter.prototype.focusedOnSingleStream = function () {
  if (_.isArray(this._settings.streams) && this._settings.streams.length === 1) {
    return this._settings.streams[0];
  }
  return null;
};

/**
 * An pryv Filter or an object corresponding at what we can get with Filter.getData().
 * @typedef {(Filter|Object)} FilterLike
 * @property {String[]} [streams]
 * @property {String[]} [tags]
 * @property {number} [fromTime] -- serverTime
 * @property {number} [toTime] -- serverTime
 * @property {number} [modifiedSince] -- serverTime
 * @property {number} [limit] -- response to 'n' events
 * @property {number} [skip] -- skip the first 'n' events of he response
 */


},{"./utility/SignalEmitter.js":51,"underscore":28}],33:[function(require,module,exports){
var _ = require('underscore'),
  SignalEmitter = require('./utility/SignalEmitter.js'),
  Filter = require('./Filter.js');

var EXTRA_ALL_EVENTS = {state : 'all', modifiedSince : -100000000 };
var REALLY_ALL_EVENTS =  EXTRA_ALL_EVENTS;
REALLY_ALL_EVENTS.fromTime = -1000000000;
REALLY_ALL_EVENTS.toTime = 10000000000;

var GETEVENT_MIN_REFRESH_RATE = 2000;

/**
 * Monitoring
 * @type {Function}
 * @constructor
 */
function Monitor(connection, filter) {
  SignalEmitter.extend(this, Messages, 'Monitor');
  this.connection = connection;
  this.id = 'M' + Monitor.serial++;

  this.filter = filter;

  this._lastUsedFilterData = filter.getData();

  if (this.filter.state) {
    throw new Error('Monitors only work for default state, not trashed or all');
  }

  this.filter.addEventListener(Filter.Messages.ON_CHANGE, this._onFilterChange.bind(this));
  this._events = null;


  // -- optimization & caching
  this.useCacheForEventsGetAllAndCompare = true;  // will look into cache before online
  this.ensureFullCache = true; // will fill the cache with ALL pryv content
  this.initWithPrefetch = 100; // prefetch some events before ensuringFullCache
}

Monitor.serial = 0;

var Messages = Monitor.Messages = {
  /** content: events **/
  ON_LOAD : 'started',
  /** content: error **/
  ON_ERROR : 'error',
  /** content: { enter: [], leave: [], change } **/
  ON_EVENT_CHANGE : 'eventsChanged',
  /** content: streams **/
  ON_STRUCTURE_CHANGE : 'streamsChanged',
  /** content: ? **/
  ON_FILTER_CHANGE : 'filterChanged'
};

// ----------- prototype  public ------------//

Monitor.prototype.start = function (done) {
  done = done || function () {};
  var batch = this.startBatch('Monitor:start');
  batch.addOnDoneListener('Monitor:startCompletion', function () {
    //TODO move this logic to ConnectionMonitors ??
    this.connection.monitors._monitors[this.id] = this;
    this.connection.monitors._startMonitoring(done);
  }.bind(this));


  this.lastSynchedST = -1000000000000;
  this._initEvents(batch);
  batch.done('Monitor:start');


};


Monitor.prototype.destroy = function () {
  //TODO move this logic to ConnectionMonitors ??
  delete this.connection.monitors._monitors[this.id];
  if (_.keys(this.connection.monitors._monitors).length === 0) {
    this.connection.monitors._stopMonitoring();
  }
};

Monitor.prototype.getEvents = function () {
  if (! this._events || ! this._events.active) {return []; }
  return _.toArray(this._events.active);
};

// ------------ private ----------//

// ----------- iOSocket ------//
Monitor.prototype._onIoConnect = function () {
  console.log('Monitor onConnect');
};
Monitor.prototype._onIoError = function (error) {
  console.log('Monitor _onIoError' + error);
};
Monitor.prototype._onIoEventsChanged = function () {
  var batch = this.startBatch('IoEventChanged');
  this._connectionEventsGetChanges(batch);
  batch.done('IoEventChanged');
};
Monitor.prototype._onIoStreamsChanged = function () {
  console.log('SOCKETIO', '_onIoStreamsChanged');
  var batch = this.startBatch('IoStreamsChanged');
  this._connectionStreamsGetChanges(batch);
  batch.done('IoStreamsChanged');
};



// -----------  filter changes ----------- //


Monitor.prototype._saveLastUsedFilter = function () {
  this._lastUsedFilterData = this.filter.getData();
};


Monitor.prototype._onFilterChange = function (signal, batch) {


  var changes = this.filter.compareToFilterData(this._lastUsedFilterData);

  var processLocalyOnly = 0;
  var foundsignal = 0;
  if (signal.signal === Filter.Messages.DATE_CHANGE) {  // only load events if date is wider
    foundsignal = 1;
    console.log('** DATE CHANGE ', changes.timeFrame);
    if (changes.timeFrame === 0) {
      return;
    }
    if (changes.timeFrame < 0) {  // new timeFrame contains more data
      processLocalyOnly = 1;
    }

  }

  if (signal.signal === Filter.Messages.STREAMS_CHANGE) {
    foundsignal = 1;
    console.log('** STREAMS_CHANGE', changes.streams);
    if (changes.streams === 0) {
      return;
    }
    if (changes.streams < 0) {  // new timeFrame contains more data
      processLocalyOnly = 1;
    }
  }

  if (signal.signal === Filter.Messages.STREAMS_CHANGE) {
    foundsignal = 1;
    console.log('** STREAMS_CHANGE', changes.streams);
    if (changes.streams === 0) {
      return;
    }
    if (changes.streams < 0) {  // new timeFrame contains more data
      processLocalyOnly = 1;
    }
  }

  if (signal.signal === Filter.Messages.STRUCTURE_CHANGE) {
    foundsignal = 1;
    // force full refresh
  }


  if (! foundsignal) {
    throw new Error('Signal not found :' + signal.signal);
  }

  this._saveLastUsedFilter();



  if (processLocalyOnly) {
    this._refilterLocaly(Messages.ON_FILTER_CHANGE, {filterInfos: signal}, batch);
  } else {
    this._connectionEventsGetAllAndCompare(Messages.ON_FILTER_CHANGE, {filterInfos: signal}, batch);
  }
};

// ----------- internal ----------------- //

/**
 * Process events locally
 */
Monitor.prototype._refilterLocaly = function (signal, extracontent, batch) {

  var result = { enter : [], leave : [] };
  _.extend(result, extracontent); // pass extracontent to receivers
  _.each(_.clone(this._events.active), function (event) {
    if (! this.filter.matchEvent(event)) {
      result.leave.push(event);
      delete this._events.active[event.id];
    }
  }.bind(this));
  this._fireEvent(signal, result, batch);
};


Monitor.prototype._initEvents = function (batch) {
  batch = this.startBatch('Monitor:initEvents', batch);
  this._events = { active : {}};


  var filterWith = this.filter.getData(true, EXTRA_ALL_EVENTS);

  if (this.initWithPrefetch) {
    filterWith.limit = this.initWithPrefetch;
  } else {
    if (this.ensureFullCache) {  filterWith = REALLY_ALL_EVENTS; }
  }


  this.connection.events.get(filterWith,
    function (error, events, extraInfos) {

      if (error) {
        this._fireEvent(Messages.ON_ERROR, error, batch);
        batch.done('Monitor:initEvents error');
        return;
      }


      if (! this.initWithPrefetch) {
        if (extraInfos && extraInfos.meta && extraInfos.meta.serverTime) {
          this.lastSynchedST = extraInfos.meta.serverTime;
        }
      }

      var result = [];

      _.each(events, function (event) {
        if (! this.ensureFullCache || this.filter.matchEvent(event)) {
          this._events.active[event.id] = event;
          result.push(event);
        }
      }.bind(this));


      this._fireEvent(Messages.ON_LOAD, result, batch);

      if (this.initWithPrefetch) {
        batch.waitForMeToFinish('delay');
        setTimeout(function () {
          this._connectionEventsGetChanges(batch);
          batch.done('delay');
        }.bind(this), 100);
      }
      batch.done('Monitor:initEvents finished');


    }.bind(this));
};





/**
 * @private
 */
Monitor.prototype._connectionEventsGetChanges = function (batch) {
  batch = this.startBatch('connectionEventsGetChanges', batch);
  if (this.eventsGetChangesInProgress) {
    this.eventsGetChangesNeeded = true;
    console.log('[WARNING] Skipping _connectionEventsGetChanges because one is in Progress');
    batch.done('connectionEventsGetChanges in Progress');
    return;
  }
  this.eventsGetChangesInProgress = true;
  this.eventsGetChangesNeeded = false;


  // var options = { modifiedSince : this.lastSynchedST};
  var options = { modifiedSince : this.lastSynchedST, state : 'all'};


  var filterWith = this.filter.getData(true, options);
  if (this.ensureFullCache) {
    filterWith = REALLY_ALL_EVENTS;
    filterWith = _.extend(filterWith, options);
  }
  //this.lastSynchedST = this.connection.getServerTime();

  var result = { created : [], trashed : [], modified: []};

  this.connection.events.get(filterWith,
    function (error, events, extraInfos) {
      if (extraInfos && extraInfos.meta && extraInfos.meta.serverTime) {
        this.lastSynchedST = extraInfos.meta.serverTime;
      }
      if (error) {
        this._fireEvent(Messages.ON_ERROR, error, batch);
        batch.done('connectionEventsGetChanges error');
        return;
      }

      _.each(events, function (event) {
        if (! this.ensureFullCache || this.filter.matchEvent(event)) {
          if (this._events.active[event.id]) {
            if (event.trashed && !this._events.active[event.id].trashed) { // trashed
              result.trashed.push(event);
              delete this._events.active[event.id];
            } else {
              result.modified.push(event);
              this._events.active[event.id] = event;
            }
          } else {
            if (this.ensureFullCache) { // can test streams  state (trashed)
              if (!event.trashed && event.stream && !event.stream.trashed) {
                result.created.push(event);
                this._events.active[event.id] = event;
              }
            } else {  // cannot test stream state
              if (!event.trashed) {
                result.created.push(event);
                this._events.active[event.id] = event;
              }
            }
          }
        }
      }.bind(this));

      this._fireEvent(Messages.ON_EVENT_CHANGE, result, batch);
      batch.done('connectionEventsGetChanges');

      // ---
      setTimeout(function () {
        this.eventsGetChangesInProgress = false;
        if (this.eventsGetChangesNeeded) {
          this._connectionEventsGetChanges();
        }
      }.bind(this), GETEVENT_MIN_REFRESH_RATE);

    }.bind(this));
};

/**
 * @private
 */
Monitor.prototype._connectionStreamsGetChanges = function (batch) {
  batch = this.startBatch('connectionStreamsGetChanges', batch);
  var previousStreamsData = {};
  var previousStreamsMap = {}; // !! only used to get back deleted streams..
  var created = [], modified = [], modifiedPreviousProperties = {}, trashed = [], deleted = [];

  var isStreamChanged = function (streamA, streamB) {
    return !_.isEqual(streamA, streamB);
  };


  // check if the stream has changed it.. and save it in the right message box
  var checkChangedStatus = function (stream) {


    if (! previousStreamsData[stream.id]) { // new stream
      created.push(stream);
    } else if (isStreamChanged(previousStreamsData[stream.id], stream.getData())) {

      if (previousStreamsData[stream.id].trashed !== stream.trashed) {
        if (!stream.trashed) {
          created.push(stream);
        } else {
          trashed.push(stream);
        }
      } else {
        modified.push(stream);
        modifiedPreviousProperties[stream.id] = previousStreamsData[stream.id];
      }
    }

    _.each(stream.children, function (child) {
      checkChangedStatus(child);
    });
    delete previousStreamsData[stream.id];
  };

  //-- get all current streams before matching with new ones --//
  var getFlatTree = function (stream) {
    previousStreamsData[stream.id] = stream.getData();
    previousStreamsMap[stream.id] = stream;

    _.each(stream.children, function (child) {
      getFlatTree(child);
    });
  };
  _.each(this.connection.datastore.getStreams(true), function (rootStream) {
    getFlatTree(rootStream);
  });

  this.connection.fetchStructure(function (error, result) {
    if (error) {
      batch.done('connectionStreamsGetChanges fetchStructure error');
      return;
    }
    _.each(result, function (rootStream) {
      checkChangedStatus(rootStream);
    });
    // each stream remaining in streams[] are deleted streams;
    _.each(previousStreamsData, function (streamData, streamId) {
      deleted.push(previousStreamsMap[streamId]);
    });

    this._fireEvent(Messages.ON_STRUCTURE_CHANGE,
      { created : created, trashed : trashed, modified: modified, deleted: deleted,
        modifiedPreviousProperties: modifiedPreviousProperties}, batch);

    this._onFilterChange({signal : Filter.Messages.STRUCTURE_CHANGE}, batch);
    batch.done('connectionStreamsGetChanges');
  }.bind(this));
};

/**
 * @private
 */
Monitor.prototype._connectionEventsGetAllAndCompare = function (signal, extracontent, batch) {
  //this.lastSynchedST = this.connection.getServerTime();


  if (this.useCacheForEventsGetAllAndCompare) {



    // POC code to look into in-memory events for matching events..
    // do not activate until cache handles DELETE
    var result1 = { enter : [], leave : []};
    _.extend(result1, extracontent);


    // first cleanup same as : this._refilterLocaly(signal, extracontent, batch);
    if (! this._events) {
      throw new Error('Not yet started!!!');
    }
    _.each(_.clone(this._events.active), function (event) {
      if (! this.filter.matchEvent(event)) {
        result1.leave.push(event);
        delete this._events.active[event.id];
      }
    }.bind(this));



    var cachedEvents = this.connection.datastore.getEventsMatchingFilter(this.filter);
    _.each(cachedEvents, function (event) {
      if (! this._events.active[event.id]) {  // we don't care for already known event
        this._events.active[event.id] = event; // store it
        result1.enter.push(event);
      }
    }.bind(this));



    this._fireEvent(signal, result1, batch);

    // remove all events not matching filter


  }

  // look online
  if (! this.ensureFullCache)  { // not needed when full cache is enabled
    var result = { enter : [] };
    _.extend(result, extracontent); // pass extracontent to receivers

    var toremove = _.clone(this._events.active);

    batch = this.startBatch('connectionEventsGetAllAndCompare:online', batch);
    this.connection.events.get(this.filter.getData(true, EXTRA_ALL_EVENTS),
      function (error, events, extraInfos) {
        if (extraInfos && extraInfos.meta && extraInfos.meta.serverTime) {
          this.lastSynchedST = extraInfos.meta.serverTime;
        }
        if (error) {
          this._fireEvent(Messages.ON_ERROR, error, batch);
          batch.done('connectionEventsGetAllAndCompare:online error');
          return;
        }
        _.each(events, function (event) {
          if (this._events.active[event.id]) {  // already known event we don't care
            delete toremove[event.id];
          } else {
            this._events.active[event.id] = event;
            result.enter.push(event);
          }
        }.bind(this));
        _.each(_.keys(toremove), function (streamid) {
          delete this._events.active[streamid]; // cleanup not found streams
        }.bind(this));
        result.leave = _.values(toremove); // unmatched events are to be removed
        this._fireEvent(signal, result, batch);
        batch.done('connectionEventsGetAllAndCompare:online');
      }.bind(this));
  }
};


/**
 * TODO write doc
 * return informations on events
 */
Monitor.prototype.stats = function (force, callback) {
  this.connection.profile.getTimeLimits(force, callback);
};

module.exports = Monitor;



},{"./Filter.js":32,"./utility/SignalEmitter.js":51,"underscore":28}],34:[function(require,module,exports){
var _ = require('underscore');



/**
 * TODO write documentation  with use cases.. !!
 * @type {Function}
 */
var Stream = module.exports = function Stream(connection, data) {
  this.connection = connection;

  this.serialId = this.connection.serialId + '>S' + this.connection._streamSerialCounter++;
  /** those are only used when no datastore **/
  this._parent = null;
  this.parentId = null;
  this.trashed = false;
  this._children = [];
  data.name = _.escape(data.name);
  _.extend(this, data);
};

Stream.RW_PROPERTIES =
  ['name', 'parentId', 'singleActivity', 'clientData', 'trashed'];

/**
 * get Json object ready to be posted on the API
 */
Stream.prototype.getData = function () {
  var data = {};
  _.each(Stream.RW_PROPERTIES, function (key) { // only set non null values
    if (_.has(this, key)) { data[key] = this[key]; }
  }.bind(this));
  return data;
};


/**
 * Set or erase clientData properties
 * @example // set x=25 and delete y
 * stream.setClientData({x : 25, y : null}, function(error) { console.log('done'); });
 *
 * @param {Object} keyValueMap
 * @param {Connection~requestCallback} callback
 */
Stream.prototype.setClientData = function (keyValueMap, callback) {
  return this.connection.streams.setClientData(this, keyValueMap, callback);
};

Object.defineProperty(Stream.prototype, 'parent', {
  get: function () {

    if (!this.parentId) {
      return null;
    }
    if (!this.connection.datastore) { // we use this._parent and this._children
      return this._parent;
    }

    return this.connection.datastore.getStreamById(this.parentId);
  },
  set: function (p) {
    if (p instanceof Stream) {
      p = p.id;
    }

    this.parentId = p;

    if (!this.connection.datastore) { // we use this._parent and this._children
      this._parent = p;
    }
    throw new Error('Stream.parent property is read only');
  }
});

/**
 * TODO write documentation
 * Does not return trashed childrens
 */
Object.defineProperty(Stream.prototype, 'children', {
  get: function () {
    if (!this.connection.datastore) { // we use this._parent and this._children
      return this._children;
    }
    var children = [];
    _.each(this.childrenIds, function (childrenId) {
      try {
        var child = this.connection.datastore.getStreamById(childrenId);
        if (child.parentId === this.id && ! child.trashed) { // exclude trashed childs
          children.push(child);
        }
      } catch (e) {
        console.warn('cannot find child', e);
      }
    }.bind(this));
    return children;
  },
  set: function () {
    throw new Error('Stream.children property is read only');
  }
});

// TODO write test
Object.defineProperty(Stream.prototype, 'ancestors', {
  get: function () {
    if (!this.parentId || this.parent === null) {
      return [];
    }
    var result = this.parent.ancestors;
    result.push(this.parent);
    return result;
  },
  set: function () {
    throw new Error('Stream.ancestors property is read only');
  }
});







},{"underscore":28}],35:[function(require,module,exports){
/* global confirm, document, navigator, location, window */

var utility = require('../utility/utility.js');
var Connection = require('../Connection.js');
var _ = require('underscore');


//--------------------- access ----------//
/**
 * @class Auth
 * */
var Auth = function () {
};


_.extend(Auth.prototype, {
  connection: null, // actual connection managed by Auth
  config: {
    // TODO: clean up this hard-coded mess and rely on the one and only Pryv URL domains reference
    registerURL: {ssl: true, host: 'reg.pryv.me'},
    sdkFullPath: 'https://api.pryv.com/lib-javascript/latest'
  },
  state: null,  // actual state
  window: null,  // popup window reference (if any)
  spanButton: null, // an element on the app web page that can be controlled
  buttonHTML: '',
  onClick: {}, // functions called when button is clicked
  settings: null,
  pollingID: false,
  pollingIsOn: true, //may be turned off if we can communicate between windows
  cookieEnabled: false,
  ignoreStateFromURL: false // turned to true in case of loggout
});

/**
 * Method to initialize the data required for authorization.
 * @method _init
 * @access private
 */
Auth._init = function () {
  utility.loadExternalFiles(
    Auth.prototype.config.sdkFullPath + '/assets/buttonSigninPryv.css', 'css');

  console.log('init done');
};


Auth._init();

//--------------------- UI Content -----------//


Auth.prototype.uiSupportedLanguages = ['en', 'fr'];

Auth.prototype.uiButton = function (onClick, buttonText) {
  if (utility.supportCSS3()) {
    return '<div id="pryv-access-btn" class="pryv-access-btn-signin" data-onclick-action="' +
      onClick + '">' +
      '<a class="pryv-access-btn pryv-access-btn-pryv-access-color" href="#">' +
      '<span class="logoSignin">Y</span></a>' +
      '<a class="pryv-access-btn pryv-access-btn-pryv-access-color"  href="#"><span>' +
      buttonText + '</span></a></div>';
  } else   {
    return '<a href="#" id ="pryv-access-btn" data-onclick-action="' + onClick +
      '" class="pryv-access-btn-signinImage" ' +
      'src="' + this.config.sdkFullPath + '/assets/btnSignIn.png" >' + buttonText + '</a>';
  }
};

Auth.prototype.uiErrorButton = function () {
  var strs = {
    'en': { 'msg': 'Error :(' },
    'fr': { 'msg': 'Erreur :('}
  }[this.settings.languageCode];
  this.onClick.Error = function () {
    this.logout();
    return false;
  }.bind(this);
  return this.uiButton('Error', strs.msg);
};

Auth.prototype.uiLoadingButton = function () {
  var strs = {
    'en': { 'msg': 'Loading...' },
    'fr': { 'msg': 'Chargement...'}
  }[this.settings.languageCode];
  this.onClick.Loading = function () {
    return false;
  };
  return this.uiButton('Loading', strs.msg);

};

Auth.prototype.uiSigninButton = function () {
  var strs = {
    'en': { 'msg': 'Sign in' },
    'fr': { 'msg': 'S\'identifier' }
  }[this.settings.languageCode];
  this.onClick.Signin = function () {
    this.popupLogin();
    return false;
  }.bind(this);
  return this.uiButton('Signin', strs.msg);

};

Auth.prototype.uiConfirmLogout = function () {
  var strs = {
    'en': { 'logout': 'Sign out?'},
    'fr': { 'logout': 'Se déconnecter?'}
  }[this.settings.languageCode];

  if (confirm(strs.logout)) {
    this.logout();
  }
};

Auth.prototype.uiInButton = function (username) {
  this.onClick.In = function () {
    this.uiConfirmLogout();
    return false;
  }.bind(this);
  return this.uiButton('In', username);
};

Auth.prototype.uiRefusedButton = function (message) {
  console.log('Pryv access [REFUSED]' + message);
  var strs = {
    'en': { 'msg': 'access refused'},
    'fr': { 'msg': 'Accès refusé'}
  }[this.settings.languageCode];
  this.onClick.Refused = function () {
    this.retry();
    return false;
  }.bind(this);
  return this.uiButton('Refused', strs.msg);

};

//--------------- end of UI ------------------//


Auth.prototype.updateButton = function (html) {
  this.buttonHTML = html;
  if (this.settings.spanButtonID) {
    utility.domReady(function () {
      if (!this.spanButton) {
        var element = document.getElementById(this.settings.spanButtonID);
        if (typeof(element) === 'undefined' || element === null) {
          throw new Error('access-SDK cannot find span ID: "' +
            this.settings.spanButtonID + '"');
        } else {
          this.spanButton = element;
        }
      }
      this.spanButton.innerHTML = this.buttonHTML;
      this.spanButton.onclick = function (e) {
        e.preventDefault();
        var element = document.getElementById('pryv-access-btn');
        console.log('onClick', this.spanButton,
          element.getAttribute('data-onclick-action'));
        this.onClick[element.getAttribute('data-onclick-action')]();
      }.bind(this);
    }.bind(this));
  }
};

Auth.prototype.internalError = function (message, jsonData) {
  this.stateChanged({id: 'INTERNAL_ERROR', message: message, data: jsonData});
};

//STATE HUB
Auth.prototype.stateChanged  = function (data) {

  if (data.id) { // error
    if (this.settings.callbacks.error) {
      this.settings.callbacks.error(data.id, data.message);
    }
    this.updateButton(this.uiErrorButton());
    console.log('Error: ' + JSON.stringify(data));
    // this.logout();   Why should I retry if it failed already once?
  }

  if(!(data.status === this.state.status ||
    data.status === 'LOADED' ||
    data.status === 'POPUPINIT')) {
    this.state = data;
    switch(this.state.status) {
      case 'NEED_SIGNIN':
        this.stateNeedSignin();
        break;
      case 'REFUSED':
        this.stateRefused();
        break;
      case 'ACCEPTED':
        this.stateAccepted();
    }
  }
};

//STATE 0 Init
Auth.prototype.stateInitialization = function () {
  this.state = {status : 'initialization'};
  this.updateButton(this.uiLoadingButton());
  if (this.settings.callbacks.initialization) {
    this.settings.callbacks.initialization();
  }
};

//STATE 1 Need Signin
Auth.prototype.stateNeedSignin = function () {
  this.updateButton(this.uiSigninButton());
  if (this.settings.callbacks.needSignin) {
    this.settings.callbacks.needSignin(this.state.url, this.state.poll,
      this.state.poll_rate_ms);
  }
};


//STATE 2 User logged in and authorized
Auth.prototype.stateAccepted = function () {
  if (this.cookieEnabled) {
    utility.docCookies.setItem('access_username' + this.settings.domain, this.state.username, 3600);
    utility.docCookies.setItem('access_token' + this.settings.domain, this.state.token, 3600);
  }
  this.updateButton(this.uiInButton(this.state.username));

  this.connection.username = this.state.username;
  this.connection.auth = this.state.token;
  this.connection.domain = this.settings.domain;
  if (this.settings.callbacks.accepted) {
    this.settings.callbacks.accepted(this.state.username, this.state.token, this.state.lang);
  }
  if (this.settings.callbacks.signedIn) {
    this.settings.callbacks.signedIn(this.connection, this.state.lang);
  }
};

//STATE 3 User refused
Auth.prototype.stateRefused = function () {
  this.updateButton(this.uiRefusedButton(this.state.message));
  if (this.settings.callbacks.refused) {
    this.settings.callbacks.refused('refused:' + this.state.message);
  }
};


/**
 * clear all references
 */
Auth.prototype.logout = function () {
  this.ignoreStateFromURL = true;
  if (this.cookieEnabled) {
    utility.docCookies.removeItem('access_username' + this.settings.domain);
    utility.docCookies.removeItem('access_token' + this.settings.domain);
  }
  this.state = null;
  if (this.settings.callbacks.accepted) {
    this.settings.callbacks.accepted(false, false, false);
  }
  if (this.settings.callbacks.signedOut) {
    this.settings.callbacks.signedOut(this.connection);
  }
  this.connection = null;
  this.setup(this.settings);
};

/**
 * clear references and try again
 */
Auth.prototype.retry = Auth.prototype.logout;




/* jshint -W101 */
// TODO: the 4 methods below belong elsewhere (e.g. static methods of Connection); original author please check with @sgoumaz

/**
 * TODO: discuss whether signature should be `(settings, callback)`
 * @param settings
 */
Auth.prototype.login = function (settings) {
  this._checkCookies();

  var defaultDomain = utility.urls.defaultDomain;
  this.settings = settings = _.defaults(settings, {
    ssl: true,
    domain: defaultDomain
  });

  this.connection = new Connection({
    ssl: settings.ssl,
    domain: settings.domain
  });

  var pack = {
    ssl: settings.ssl,
    host: settings.username + '.' + settings.domain,
    path: '/auth/login',
    params: {
      appId : settings.appId,
      username : settings.username,
      password : settings.password
    },
    success: function (data)  {
      if (data.token) {
        if (this.cookieEnabled && settings.rememberMe) {
          utility.docCookies.setItem('access_username' + this.settings.domain,
             settings.username, 3600);
          utility.docCookies.setItem('access_token' + this.settings.domain,
            data.token, 3600);
          utility.docCookies.setItem('access_preferredLanguage' + this.settings.domain,
            data.preferredLanguage, 3600);
        }
        console.log('set cookie', this.cookieEnabled, settings.rememberMe,
          utility.docCookies.getItem('access_username' + this.settings.domain),
          utility.docCookies.getItem('access_token' + this.settings.domain));
        this.connection.username = settings.username;
        this.connection.auth = data.token;
        if (typeof(this.settings.callbacks.signedIn)  === 'function') {
          this.settings.callbacks.signedIn(this.connection);
        }
      } else if (typeof(this.settings.callbacks.error) === 'function') {
        this.settings.callbacks.error(data);
      }
    }.bind(this),
    error: function (jsonError) {
      if (typeof(this.settings.callbacks.error) === 'function') {
        this.settings.callbacks.error(jsonError);
      }
    }.bind(this)
  };

  utility.request(pack);
};

// TODO: must be an instance member of Connection instead
Auth.prototype.trustedLogout = function () {
  if (this.connection) {
    this.connection.request({
      method: 'POST',
      path: '/auth/logout',
      callback: function (error) {
        if (error && typeof(this.settings.callbacks.error) === 'function') {
          return this.settings.callbacks.error(error);
        } else if (!error && typeof(this.settings.callbacks.signedOut) === 'function') {
          return this.settings.callbacks.signedOut(this.connection);
        }
      }.bind(this)
    });
  }
};

Auth.prototype.whoAmI = function (settings) {

  var defaultDomain = utility.urls.defaultDomain;
  this.settings = settings = _.defaults(settings, {
    ssl: true,
    domain: defaultDomain
  });

  this.connection = new Connection({
    ssl: settings.ssl,
    domain: settings.domain
  });

  var pack = {
    ssl: settings.ssl,
    host: settings.username + '.' + settings.domain,
    path :  '/auth/who-am-i',
    method: 'GET',
    success : function (data)  {
      if (data.token) {
        this.connection.username = data.username;
        this.connection.auth = data.token;
        var conn = new Connection(data.username, data.token, {
          ssl: settings.ssl,
          domain: settings.domain
        });
        console.log('before access info', this.connection);
        conn.accessInfo(function (error) {
          console.log('after access info', this.connection);
          if(error && (typeof(this.settings.callbacks.error) === 'function')) {
            this.settings.callbacks.error(error);
          } else if(!error && typeof(this.settings.callbacks.signedIn)  === 'function') {
            this.settings.callbacks.signedIn(this.connection);
          }
        }.bind(this));

      } else if (typeof(this.settings.callbacks.error) === 'function') {
        this.settings.callbacks.error(data);
      }
    }.bind(this),
    error : function (jsonError) {
      if (typeof(this.settings.callbacks.error) === 'function') {
        this.settings.callbacks.error(jsonError);
      }
    }.bind(this)
  };

  utility.request(pack);
};

Auth.prototype.loginWithCookie = function (settings) {

  var defaultDomain = utility.urls.defaultDomain;
  this.settings = settings = _.defaults(settings, {
    ssl: true,
    domain: defaultDomain
  });

  this.connection = new Connection({
    ssl: settings.ssl,
    domain: settings.domain
  });

  this._checkCookies();

  var cookieUserName = this.cookieEnabled ?
    utility.docCookies.getItem('access_username' + this.settings.domain) : false;
  var cookieToken = this.cookieEnabled ?
    utility.docCookies.getItem('access_token' + this.settings.domain) : false;

  console.log('get cookie', cookieUserName, this.settings.domain, cookieToken);

  if (cookieUserName && cookieToken) {
    this.connection.username = cookieUserName;
    this.connection.domain = this.settings.domain;
    this.connection.auth = cookieToken;

    if (typeof(this.settings.callbacks.signedIn) === 'function') {
      this.settings.callbacks.signedIn(this.connection);
    }

    return this.connection;
  }
  return false;
};

/**
 *
 * @param settings
 * @returns {Connection} the connection managed by Auth.. A new one is created each time setup is
 * called.
 */
Auth.prototype.setup = function (settings) {
  this.state = null;

  //--- check the browser capabilities

  this._checkCookies();

  //TODO check settings..

  settings.languageCode =
    utility.getPreferredLanguage(this.uiSupportedLanguages, settings.languageCode);

  //-- returnURL
  settings.returnURL = settings.returnURL || 'auto#';
  if (settings.returnURL) {
    // check the trailer
    var trailer = settings.returnURL.charAt(settings.returnURL.length - 1);
    if ('#&?'.indexOf(trailer) < 0) {
      throw new Error('Pryv access: Last character of --returnURL setting-- is not ' +
        '"?", "&" or "#": ' + settings.returnURL);
    }

    // set self as return url?
    if((settings.returnURL.indexOf('auto') === 0 && utility.browserIsMobileOrTablet()) ||
      (settings.returnURL.indexOf('self') === 0)) {
        var myParams = settings.returnURL.substring(4);
        // eventually clean-up current url from previous pryv returnURL
        settings.returnURL = this._cleanStatusFromURL() + myParams;
    } else if(settings.returnURL.indexOf('auto') === 0 && !utility.browserIsMobileOrTablet()) {
      settings.returnURL = false;
    }

    if (settings.returnURL && settings.returnURL.indexOf('http') < 0) {
        throw new Error('Pryv access: --returnURL setting-- does not start with http: ' +
          settings.returnURL);
    }
  }

  //  spanButtonID is checked only when possible
  this.settings = settings;


  // TODO: clean up this hard-coded mess and rely on the one and only Pryv URL domains reference
  var parts =  this.config.registerURL.host.split('.').reverse();
  this.settings.domain = parts[1] + '.' + parts[0];

  var params = {
    requestingAppId : settings.requestingAppId,
    requestedPermissions : settings.requestedPermissions,
    languageCode : settings.languageCode,
    returnURL : settings.returnURL
  };

  if (settings.oauthState) {
    params.oauthState = settings.oauthState;
  }

  if (this.config.reclaDevel) {
    // return url will be forced to https://se.rec.la + reclaDevel
    params.reclaDevel = this.config.reclaDevel;
  }

  this.stateInitialization();


  this.connection = new Connection(null, null, {ssl: true, domain: this.settings.domain});
  // look if we have a returning user (document.cookie)
  var cookieUserName = this.cookieEnabled ?
    utility.docCookies.getItem('access_username' + this.settings.domain) : false;
  var cookieToken = this.cookieEnabled ?
    utility.docCookies.getItem('access_token' + this.settings.domain) : false;

  // look in the URL if we are returning from a login process
  var stateFromURL =  this._getStatusFromURL();

  if (stateFromURL && (! this.ignoreStateFromURL)) {
    this.stateChanged(stateFromURL);
  } else if (cookieToken && cookieUserName) {
    this.stateChanged({status: 'ACCEPTED', username: cookieUserName,
      token: cookieToken, domain: this.settings.domain});
  } else { // launch process $

    var pack = {
      path :  '/access',
      params : params,
      success : function (data)  {
        if (data.status && data.status !== 'ERROR') {
          this.stateChanged(data);
        } else {
          // TODO call shouldn't failed
          this.internalError('/access Invalid data: ', data);
        }
      }.bind(this),
      error : function (jsonError) {
        this.internalError('/access ajax call failed: ', jsonError);
      }.bind(this)
    };

    utility.request(_.extend(pack, this.config.registerURL));


  }


  return this.connection;
};

//logout the user if

//read the polling
Auth.prototype.poll = function poll() {
  if (this.pollingIsOn && this.state.poll_rate_ms) {
    // remove eventually waiting poll..
    if (this.pollingID) { clearTimeout(this.pollingID); }


    var pack = {
      path :  '/access/' + this.state.key,
      method : 'GET',
      success : function (data)  {
        this.stateChanged(data);
      }.bind(this),
      error : function (jsonError) {
        this.internalError('poll failed: ', jsonError);
      }.bind(this)
    };

    utility.request(_.extend(pack, this.config.registerURL));


    this.pollingID = setTimeout(this.poll.bind(this), this.state.poll_rate_ms);
  } else {
    console.log('stopped polling: on=' + this.pollingIsOn + ' rate:' + this.state.poll_rate_ms);
  }
};


//messaging between browser window and window.opener
Auth.prototype.popupCallBack = function (event) {
  // Do not use 'this' here !
  if (!this.settings.forcePolling) {
    if (event.source !== this.window) {
      console.log('popupCallBack event.source does not match Auth.window');
      return false;
    }
    console.log('from popup >>> ' + JSON.stringify(event.data));
    this.pollingIsOn = false; // if we can receive messages we stop polling
    this.stateChanged(event.data);
  }
};



Auth.prototype.popupLogin = function popupLogin() {
  if (!this.state || !this.state.url) {
    throw new Error('Pryv Sign-In Error: NO SETUP. Please call Auth.setup() first.');
  }

  if (this.settings.returnURL) {
    location.href = this.state.url;
  } else {
    // start polling
    setTimeout(this.poll(), 1000);

    var screenX = typeof window.screenX !== 'undefined' ? window.screenX : window.screenLeft,
      screenY = typeof window.screenY !== 'undefined' ? window.screenY : window.screenTop,
      outerWidth = typeof window.outerWidth !== 'undefined' ?
        window.outerWidth : document.body.clientWidth,
      outerHeight = typeof window.outerHeight !== 'undefined' ?
        window.outerHeight : (document.body.clientHeight - 22),
      width    = 270,
      height   = 420,
      left     = parseInt(screenX + ((outerWidth - width) / 2), 10),
      top      = parseInt(screenY + ((outerHeight - height) / 2.5), 10),
      features = (
        'width=' + width +
        ',height=' + height +
        ',left=' + left +
        ',top=' + top +
        ',scrollbars=yes'
      );

    window.addEventListener('message', this.popupCallBack.bind(this), false);

    this.window = window.open(this.state.url, 'prYv Sign-in', features);

    if (!this.window) {
      // TODO try to fall back on access
      console.log('FAILED_TO_OPEN_WINDOW');
    } else if(window.focus) {
      this.window.focus();
    }

    return false;
  }
};

var statusRegexp = /[?#&]+prYv([^=&]+)=([^&]*)/gi;

//util to grab parameters from url query string
Auth.prototype._getStatusFromURL = function () {
  var vars = {};
  window.location.href.replace(statusRegexp,
    function (m, key, value) {
      vars[key] = value;
    });

  //TODO check validity of status

  return (vars.status) ? vars : false;
};

//util to grab parameters from url query string
Auth.prototype._cleanStatusFromURL = function () {
  return window.location.href.replace(statusRegexp, '');
};

Auth.prototype._checkCookies = function () {
  this.cookieEnabled = (navigator.cookieEnabled);
  if (typeof navigator.cookieEnabled === 'undefined' && !this.cookieEnabled) {  //if not IE4+ NS6+
    document.cookie = 'testcookie';
    this.cookieEnabled = (document.cookie.indexOf('testcookie') !== -1);
  }
};

//-------------------- UTILS ---------------------//

module.exports = new Auth();

},{"../Connection.js":29,"../utility/utility.js":60,"underscore":28}],36:[function(require,module,exports){

module.exports = {};
},{}],37:[function(require,module,exports){
var utility = require('../utility/utility.js');

module.exports =  utility.isBrowser() ?
    require('./Auth-browser.js') : require('./Auth-node.js');

},{"../utility/utility.js":60,"./Auth-browser.js":35,"./Auth-node.js":36}],38:[function(require,module,exports){
var apiPathAccesses = '/accesses';
var _ = require('underscore'),
  CC = require('./ConnectionConstants.js');

/**
 * @class Accesses
 * @link http://api.pryv.com/reference.html#methods-accesses
 * @link http://api.pryv.com/reference.html#data-structure-access
 * @param {Connection} connection
 * @constructor
 */
function Accesses(connection) {
  this.connection = connection;
}
/**
 * @param {Connection~requestCallback} callback
 */
Accesses.prototype.get = function (callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'GET',
    path: apiPathAccesses,
    callback: function (err, res) {
      if (err) {
        return callback(err);
      }
      var accesses = res.accesses || res.access;
      callback(null, accesses);
    }
  });
};

/**
 * TODO complete documentation
 * @param access
 * @param callback
 */
Accesses.prototype.create = function (access, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'POST',
    path: apiPathAccesses,
    callback: function (err, res) {
      if (err) {
        return callback(err);
      }
      callback(err, res.access);
    },
    jsonData: access
  });
};

/**
 * TODO complete documentation
 * @param access
 * @param callback
 */
Accesses.prototype.update = function (access, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (access.id) {
    this.connection.request({
      method: 'PUT',
      path: apiPathAccesses + '/' + access.id,
      jsonData: _.pick(access, 'name', 'deviceName', 'permissions'),
      callback: function (err, res) {
        if (err) {
          return callback(err);
        }
        callback(err, res.access);
      }
    });
  } else {
    return callback('No access id found');
  }
};

/**
 * TODO complete documentation
 * @param accessId
 * @param callback
 */
Accesses.prototype.delete = function (accessId, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'DELETE',
    path: apiPathAccesses + '/' + accessId,
    callback: function (err, result) {
      if (err) {
        return callback(err);
      }
      callback(null, result);
    }
  });
};
module.exports = Accesses;
},{"./ConnectionConstants.js":41,"underscore":28}],39:[function(require,module,exports){
var apiPathAccount = '/account';
var CC = require('./ConnectionConstants.js');

function Account(connection) {
  this.connection = connection;
}

Account.prototype.changePassword = function (oldPassword, newPassword, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'POST',
    path: apiPathAccount + '/change-password',
    jsonData: {'oldPassword': oldPassword, 'newPassword': newPassword},
    callback: function (err) {
      callback(err);
    }
  });
};
Account.prototype.getInfo = function (callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'GET',
    path: apiPathAccount,
    callback: function (error, result) {
      if (result && result.account) {
        result = result.account;
      }
      callback(error, result);
    }
  });
};

module.exports = Account;
},{"./ConnectionConstants.js":41}],40:[function(require,module,exports){
var apiPathBookmarks = '/followed-slices',
  Connection = require('../Connection.js'),
  _ = require('underscore'),
  CC = require('./ConnectionConstants.js');

/**
 * @class Bookmarks
 * @link http://api.pryv.com/reference.html#data-structure-subscriptions-aka-bookmarks
 * @param {Connection} connection
 * @constructor
 */
function Bookmarks(connection, Conn) {
  this.connection = connection;
  Connection = Conn;
}
/**
 * @param {Connection~requestCallback} callback
 */
Bookmarks.prototype.get = function (callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'GET',
    path: apiPathBookmarks,
    callback: function (error, res) {
      var result = [],
        bookmarks = res.followedSlices || res.followedSlice;
      _.each(bookmarks, function (bookmark) {
        var conn =  new Connection({
          auth: bookmark.accessToken,
          url: bookmark.url,
          name: bookmark.name,
          bookmarkId: bookmark.id
        });
        result.push(conn);
      });
      callback(error, result);
    }
  });
};

/**
 * TODO complete documentation
 * @param bookmark
 * @param callback
 * @returns {*}
 */
Bookmarks.prototype.create = function (bookmark, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (bookmark.name && bookmark.url && bookmark.accessToken) {
    this.connection.request({
      method: 'POST',
      path: apiPathBookmarks,
      jsonData: bookmark,
      callback: function (err, result) {
        var error = err;
        if (!error) {
          var conn =  new Connection({
            auth: bookmark.accessToken,
            url: bookmark.url,
            name: bookmark.name,
            bookmarkId: result.followedSlice.id
          });
          bookmark = conn;
        }
        callback(error, bookmark);
      }
    });
    return bookmark;
  }
};

/**
 * TODO complete documentation
 * @param bookmarkId
 * @param callback
 */
Bookmarks.prototype.delete = function (bookmarkId, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'DELETE',
    path: apiPathBookmarks + '/' + bookmarkId,
    callback: function (err, result) {
      var error = err;
      if (result && result.message) {
        error = result;
      }
      callback(error, result);
    }
  });
};

module.exports = Bookmarks;
},{"../Connection.js":29,"./ConnectionConstants.js":41,"underscore":28}],41:[function(require,module,exports){
exports.Errors = {
  API_UNREACHEABLE : 'API_UNREACHEABLE',
  INVALID_RESULT_CODE : 'INVALID_RESULT_CODE',
  CALLBACK_IS_NOT_A_FUNCTION: 'callback argument must be a function'
};

exports.Api = {
  Headers : {
    ServerTime : 'server-time',
    ApiVersion : 'api-version'
  }
};
},{}],42:[function(require,module,exports){
var utility = require('../utility/utility.js'),
  _ = require('underscore'),
  Filter = require('../Filter'),
  Event = require('../Event'),
  CC = require('./ConnectionConstants.js');

/**
 * @class ConnectionEvents
 *
 * Coverage of the API
 *  GET /events -- 100%
 *  POST /events -- only data (no object)
 *  POST /events/start -- 0%
 *  POST /events/stop -- 0%
 *  PUT /events/{event-id} -- 100%
 *  DELETE /events/{event-id} -- only data (no object)
 *  POST /events/batch -- only data (no object)
 *
 *  attached files manipulations are covered by Event
 *
 *
 * @param {Connection} connection
 * @constructor
 */
function ConnectionEvents(connection) {
  this.connection = connection;
}


/**
 * @example
 * // get events from the Diary stream
 * conn.events.get({streamId : 'diary'},
 *  function(events) {
 *    console.log('got ' + events.length + ' events)
 *  }
 * );
 * @param {FilterLike} filter
 * @param {ConnectionEvents~getCallback} doneCallback
 * @param {ConnectionEvents~partialResultCallback} partialResultCallback
 */
ConnectionEvents.prototype.get = function (filter, doneCallback, partialResultCallback) {
  if (typeof(doneCallback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  //TODO handle caching
  var result = [];
  filter = filter || {};
  this._get(filter, function (error, res, extraInfos) {
    if (error) {
      result = null;
    } else {
      var eventList = res.events || res.event;
      _.each(eventList, function (eventData) {

        var event = null;
        if (!this.connection.datastore) { // no datastore   break
          event = new Event(this.connection, eventData);
        } else {
          event = this.connection.datastore.createOrReuseEvent(eventData);
        }

        result.push(event);

      }.bind(this));
      if (res.eventDeletions) {
        result.eventDeletions = res.eventDeletions;
      }
    }

    doneCallback(error, result, extraInfos);

    if (partialResultCallback) { partialResultCallback(result); }
  }.bind(this));

};

/**
 * @param {Event} event
 * @param {Connection~requestCallback} callback
 */
ConnectionEvents.prototype.update = function (event, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this._updateWithIdAndData(event.id, event.getData(), callback);
};

/**
 * @param {Event | eventId} event
 * @param {Connection~requestCallback} callback
 */
ConnectionEvents.prototype.delete = ConnectionEvents.prototype.trash = function (event, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.trashWithId(event.id, callback);
};

/**
 * @param {String} eventId
 * @param {Connection~requestCallback} callback
 */
ConnectionEvents.prototype.trashWithId = function (eventId, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'DELETE',
    path: '/events/' + eventId,
    callback: function (error, result) {
      // assume there is only one event (no batch for now)
      if (result && result.event) {
        if (!this.connection.datastore) { // no datastore   break
          result = new Event(this.connection, result.event);
        } else {
          result = this.connection.datastore.createOrReuseEvent(result.event);
        }
      } else {
        result = null;
      }
      callback(error, result);

    }.bind(this)
  });
};

/**
 * This is the preferred method to create an event, or to create it on the API.
 * The function return the newly created object.. It will be updated when posted on the API.
 * @param {NewEventLike} event -- minimum {streamId, type } -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {Boolean} [start = false] if set to true will POST the event to /events/start
 * @return {Event} event
 */
ConnectionEvents.prototype.create = function (newEventlike, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  _create.call(this, newEventlike, callback, false);
};


/**
 * This is the preferred method to create and start an event, Starts a new period event.
 * This is equivalent to starting an event with a null duration. In singleActivity streams,
 * also stops the previously running period event if any.
 * @param {NewEventLike} event -- minimum {streamId, type } -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @return {Event} event
 */
ConnectionEvents.prototype.start = function (newEventlike, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  _create.call(this, newEventlike, callback, true);
};


// common call for create and start
function _create(newEventlike, callback, start) {
  var event = null;
  if (newEventlike instanceof Event) {
    if (newEventlike.connection !== this.connection) {
      return callback(new Error('event.connection does not match current connection'));
    }
    if (newEventlike.id) {
      return callback(new Error('cannot create an event already existing on the API'));
    }
    event = newEventlike;
  } else {
    event = new Event(this.connection, newEventlike);
  }

  var url = '/events';
  if (start) { url = '/events/start'; }


  this.connection.request({
    method: 'POST',
    path: url,
    jsonData: event.getData(),
    callback: function (err, result, resultInfo) {
      if (!err && resultInfo.code !== 201) {
        err = {id: CC.Errors.INVALID_RESULT_CODE};
      }

      /**
       * Change will happend with offline caching...
       *
       * An error may hapend 400.. or other if app is behind an non-opened gateway. Thus making
       * difficult to detect if the error is a real bad request.
       * The first step would be to consider only bad request if the response can be identified
       * as coming from a valid api-server. If not, we should cache the event for later synch
       * then remove the error and send the cached version of the event.
       *
       */
      // TODO if err === API_UNREACHABLE then save event in cache
      if (result && !err) {
        _.extend(event, result.event);
        if (this.connection.datastore) {  // if datastore is activated register new event
          this.connection.datastore.addEvent(event);
        }
      }
      callback(err, err ? null : event, err ? null : result.stoppedId);
    }.bind(this)
  });
  return event;
}




/**
 * Stop an event by it's Id
 * @param {EventLike} event -- minimum {id} -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {Date} [date = now] the date to set to stop the event
 * @param {ConnectionEvents~eventStoppedOnTheAPI} callback
 * @return {Event} event
 */
ConnectionEvents.prototype.stopEvent = function (eventlike, date, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }

  var data = {id: eventlike.id};
  if (date) {
    data.time = date.getTime() / 1000;
  }

  this.connection.request({
    method: 'POST',
    path: '/events/stop',
    jsonData: data,
    callback: function (err, result, resultInfo) {
      if (!err && resultInfo.code !== 200) {
        err = {id: CC.Errors.INVALID_RESULT_CODE};
      }

      // TODO if err === API_UNREACHABLE then save event in cache
      /*
       if (result && ! err) {
       if (this.connection.datastore) {  // if datastore is activated register new event

       }
       } */
      callback(err, err ? null : result.stoppedId);
    }.bind(this)
  });
};



/**
 * Stop any event in this stream
 * @param {StreamLike} stream -- minimum {id} -- if typeof Stream, must belong to
 * the same connection and not exists on the API.
 * @param {Date} [date = now] the date to set to stop the event
 * @param {String} [type = null] stop any matching eventType is this stream.
 * @param {ConnectionEvents~eventStoppedOnTheAPI} callback
 * @return {Event} event
 */
ConnectionEvents.prototype.stopStream = function (streamLike, date, type, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }

  var data = {streamId : streamLike.id };
  if (date) { data.time = date.getTime() / 1000; }
  if (type) { data.type = type; }


  this.connection.request({
    method: 'POST',
    path: '/events/stop',
    jsonData: data,
    callback: function (err, result, resultInfo) {
      if (!err && resultInfo.code !== 200) {
        err = {id: CC.Errors.INVALID_RESULT_CODE};
      }

      // TODO if err === API_UNREACHABLE then cache the stop instruction for later synch

      callback(err, err ? null : result.stoppedId);
    }.bind(this)
  });
};


/**
 * @param {NewEventLike} event -- minimum {streamId, type } -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {FormData} the formData to post for fileUpload. On node.js
 * refers to pryv.utility.forgeFormData
 * @return {Event} event
 */
ConnectionEvents.prototype.createWithAttachment =
  function (newEventLike, formData, callback, progressCallback) {
    if (typeof(callback) !== 'function') {
      throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
    }
    var event = null;
    if (newEventLike instanceof Event) {
      if (newEventLike.connection !== this.connection) {
        return callback(new Error('event.connection does not match current connection'));
      }
      if (newEventLike.id) {
        return callback(new Error('cannot create an event already existing on the API'));
      }
      event = newEventLike;
    } else {
      event = new Event(this.connection, newEventLike);
    }
    formData.append('event', JSON.stringify(event.getData()));
    this.connection.request({
      method: 'POST',
      path: '/events',
      jsonData: formData,
      isFile: true,
      progressCallback: progressCallback,
      callback: function (err, result) {
        if (result) {
          _.extend(event, result.event);

          if (this.connection.datastore) {  // if datastore is activated register new event
            this.connection.datastore.addEvent(event);
          }
        }
        callback(err, event);
      }.bind(this)
    });
  };

/**
 * @param {String} eventId
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {FormData} the formData to post for fileUpload. On node.js
 * refers to pryv.utility.forgeFormData
 * @return {Event} event
 */
ConnectionEvents.prototype.addAttachment =
  function (eventId, formData, callback, progressCallback) {
    if (typeof(callback) !== 'function') {
      throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
    }
  this.connection.request({
    method: 'POST',
    path: '/events/' + eventId,
    jsonData: formData,
    isFile: true,
    progressCallback: progressCallback,
    callback: function (err, result) {
      if (err) {
        return callback(err);
      }
      callback(null, result.event);
    }
  });
};

/**
 * @param {String} eventId
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {FormData} the formData to post for fileUpload. On node.js
 * refers to pryv.utility.forgeFormData
 * @return {Event} event
 */
ConnectionEvents.prototype.getAttachment =
  function (params, callback, progressCallback) {
    if (typeof(callback) !== 'function') {
      throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
    }
    this.connection.request({
      method: 'GET',
      path: '/events/' + params.eventId + '/' + params.fileId,
      progressCallback: progressCallback,
      parseResult: 'binary',
      callback: function (err, result) {
        if (err) {
          return callback(err);
        }
        callback(null, result);
      }
    });
  };

/**
 * @param {String} eventId
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {String} fileName
 * @return {Event} event
 */
ConnectionEvents.prototype.removeAttachment = function (eventId, fileName, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this.connection.request({
    method: 'DELETE',
    path: '/events/' + eventId + '/' + fileName,
    callback: callback
  });
};
/**
 * //TODO rename to batch
 * //TODO make it NewEventLike compatible
 * //TODO once it support an array of mixed values Event and EventLike, the, no need for
 *  callBackWithEventsBeforeRequest at it will. A dev who want Event object just have to create
 *  them before
 * This is the prefered method to create events in batch
 * @param {Object[]} eventsData -- minimum {streamId, type }
 * @param {ConnectionEvents~eventBatchCreatedOnTheAPI}
 * @param {function} [callBackWithEventsBeforeRequest] mostly for testing purposes
 * @return {Event[]} events
 */
ConnectionEvents.prototype.batchWithData =
  function (eventsData, callback, callBackWithEventsBeforeRequest) {
    if (typeof(callback) !== 'function') {
      throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
    }
    if (!_.isArray(eventsData)) { eventsData = [eventsData]; }

    var createdEvents = [];
    var eventMap = {};

    // use the serialId as a temporary Id for the batch
    _.each(eventsData, function (eventData, i) {

      var event =  new Event(this.connection, eventData);

      createdEvents.push(event);
      eventMap[i] = event;
    }.bind(this));

    if (callBackWithEventsBeforeRequest) {
      callBackWithEventsBeforeRequest(createdEvents);
    }

    var mapBeforePush = function (evs) {
      return _.map(evs, function (e) {
        return {
          method: 'events.create',
          params: e
        };
      });
    };

    this.connection.request({
      method: 'POST',
      path: '/',
      jsonData: mapBeforePush(eventsData),
      callback: function (err, result) {
        if (!err && result) {
          _.each(result.results, function (eventData, i) {
            _.extend(eventMap[i], eventData.event); // add the data to the event

            if (this.connection.datastore) {  // if datastore is activated register new event
              this.connection.datastore.addEvent(eventMap[i]);
            }


          }.bind(this));
        }
        callback(err, createdEvents);
      }.bind(this)
    });

    return createdEvents;
  };

// --- raw access to the API

/**
 * TODO anonymise by renaming to function _get(..
 * @param {FilterLike} filter
 * @param {Connection~requestCallback} callback
 * @private
 */
ConnectionEvents.prototype._get = function (filter, callback) {
  var tParams = filter;
  if (filter instanceof Filter) { tParams = filter.getData(true); }
  if (_.has(tParams, 'streams') && tParams.streams.length === 0) { // dead end filter..
    return callback(null, [], {});
  }
  this.connection.request({
    method: 'GET',
    path: '/events?' + utility.getQueryParametersString(tParams),
    callback: callback
  });
};


/**
 * TODO anonymise by renaming to function _xx(..
 * @param {String} eventId
 * @param {Object} data
 * @param  {Connection~requestCallback} callback
 * @private
 */
ConnectionEvents.prototype._updateWithIdAndData = function (eventId, data, callback) {
  this.connection.request({
    method: 'PUT',
    path: '/events/' + eventId,
    jsonData: data,
    callback: function (error, result) {
      if (!error && result && result.event) {
        if (!this.connection.datastore) {
          result = new Event(this.connection, result.event);
        } else {
          result = this.connection.datastore.createOrReuseEvent(result.event);
        }
      } else {
        result = null;
      }
      callback(error, result);
    }.bind(this)
  });
};


/**
 * @private
 * @param {Event} event
 * @param {Object} the data to map
 */
ConnectionEvents.prototype._registerNewEvent = function (event, data) {


  if (! event.connection.datastore) { // no datastore   break
    _.extend(event, data);
    return event;
  }

  return event.connection.datastore.createOrReuseEvent(this, data);
};

module.exports = ConnectionEvents;

/**
 * Called with the desired Events as result.
 * @callback ConnectionEvents~getCallback
 * @param {Object} error - eventual error
 * @param {Event[]} result
 */


/**
 * Called each time a "part" of the result is received
 * @callback ConnectionEvents~partialResultCallback
 * @param {Event[]} result
 */


/**
 * Called when an event is created on the API
 * @callback ConnectionEvents~eventCreatedOnTheAPI
 * @param {Object} error - eventual error
 * @param {Event} event
 */

/**
 * Called when an event is created on the API
 * @callback ConnectionEvents~eventStoppedOnTheAPI
 * @param {Object} error - eventual error
 * @param {String} stoppedEventId or null if event not found
 */

/**
 * Called when batch create an array of events on the API
 * @callback ConnectionEvents~eventBatchCreatedOnTheAPI
 * @param {Object} error - eventual error
 * @param {Event[]} events
 */

},{"../Event":31,"../Filter":32,"../utility/utility.js":60,"./ConnectionConstants.js":41,"underscore":28}],43:[function(require,module,exports){
var _ = require('underscore'),
    utility = require('../utility/utility'),
    Monitor = require('../Monitor');

/**
 * @class ConnectionMonitors
 * @private
 *
 * @param {Connection} connection
 * @constructor
 */
function ConnectionMonitors(connection) {
  this.connection = connection;
  this._monitors = {};
  this.ioSocket = null;
}

/**
 * Start monitoring this Connection. Any change that occurs on the connection (add, delete, change)
 * will trigger an event. Changes to the filter will also trigger events if they have an impact on
 * the monitored data.
 * @param {Filter} filter - changes to this filter will be monitored.
 * @returns {Monitor}
 */
ConnectionMonitors.prototype.create = function (filter) {
  if (!this.connection.username) {
    console.error('Cannot create a monitor for a connection without username:', this.connection);
    return null;
  }
  return new Monitor(this.connection, filter);
};



/**
 * TODO
 * @private
 */
ConnectionMonitors.prototype._stopMonitoring = function (/*callback*/) {

};

/**
 * Internal for Connection.Monitor
 * Maybe moved in Monitor by the way
 * @param callback
 * @private
 * @return {Object} XHR or Node http request
 */
ConnectionMonitors.prototype._startMonitoring = function (callback) {
  if (!this.connection.username) {
    console.error('Cannot start monitoring for a connection without username:', this.connection);
    return callback(true);
  }
  if (this.ioSocket) { return callback(null/*, ioSocket*/); }

  var settings = {
    host : this.connection.username + '.' + this.connection.settings.domain,
    port : this.connection.settings.port,
    ssl : this.connection.settings.ssl,
    path : this.connection.settings.extraPath + '/' + this.connection.username,
    namespace : '/' + this.connection.username,
    auth : this.connection.auth
  };

  this.ioSocket = utility.ioConnect(settings);

  this.ioSocket.on('connect', function () {
    _.each(this._monitors, function (monitor) { monitor._onIoConnect(); });
  }.bind(this));
  this.ioSocket.on('error', function (error) {
    _.each(this._monitors, function (monitor) { monitor._onIoError(error); });
  }.bind(this));
  this.ioSocket.on('eventsChanged', function () {
    _.each(this._monitors, function (monitor) { monitor._onIoEventsChanged(); });
  }.bind(this));
  this.ioSocket.on('streamsChanged', function () {
    _.each(this._monitors, function (monitor) { monitor._onIoStreamsChanged(); });
  }.bind(this));
  callback(null);
};

module.exports = ConnectionMonitors;



},{"../Monitor":33,"../utility/utility":60,"underscore":28}],44:[function(require,module,exports){
var apiPathPrivateProfile = '/profile/private';
var apiPathPublicProfile = '/profile/public';
var CC = require('./ConnectionConstants.js');

/**
 * @class Profile
 * @link http://api.pryv.com/reference.html#methods-app-profile
 */

/**
 * Accessible by connection.profile.xxx`
 * @param {Connection} connection
 * @constructor
 */
function Profile(connection) {
  this.connection = connection;
  this.timeLimits = null;
}




/**
 * @param {String | null} key
 * @param {Connection~requestCallback} callback - handles the response
 */
Profile.prototype.getPrivate = function (key, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this._get(apiPathPrivateProfile, key, callback);
};
/**
 * @param {String | null} key
 * @param {Connection~requestCallback} callback - handles the response
 */
Profile.prototype.getPublic = function (key, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this._get(apiPathPublicProfile, key, callback);
};


/**
 * @example
 * // set x=25 and delete y
 * conn.profile.setPrivate({x : 25, y : null}, function(error) { console.log('done'); });
 *
 * @param {Object} keyValuePairs
 * @param {Connection~requestCallback} callback - handles the response
 */
Profile.prototype.setPrivate = function (keyValuePairs, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this._set(apiPathPrivateProfile, keyValuePairs, callback);
};
/**
 * @example
 * // set x=25 and delete y
 * conn.profile.setPublic({x : 25, y : null}, function(error) { console.log('done'); });
 *
 * @param {Object} keyValuePairs
 * @param {Connection~requestCallback} callback - handles the response
 */
Profile.prototype.setPublic = function (keyValuePairs, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  this._set(apiPathPublicProfile, keyValuePairs, callback);
};

/**
 * TODO write documentation
 */
Profile.prototype.getTimeLimits = function (force, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (!force && this.timeLimits) {
      callback(this.timeLimits);
  } else {
    var i = 2;
    this.timeLimits = {
      timeFrameST : [],
      timeFrameLT : []
    };
    this.connection.events.get({
      toTime: 9900000000,
      fromTime: 0,
      limit: 1,
      sortAscending: false,
      state: 'all'
    }, function (error, events) {
      if (!error && events) {
        this.timeLimits.timeFrameST[1] = events[0].time;
        this.timeLimits.timeFrameLT[1] = events[0].timeLT;
      }
      i--;
      if (i === 0) {
          callback(this.timeLimits);
      }
    }.bind(this));
    this.connection.events.get({
      toTime: 9900000000, // TODO add a constant UNDEFINED_TO_TIME in constant
      fromTime: -9900000000, // TODO add a constant UNDEFINED_FROM_TIME in constant
      limit: 1,
      sortAscending: true,
      state: 'all'
    }, function (error, events) {
      if (!error && events) {
        this.timeLimits.timeFrameST[0] = events[0].time;
        this.timeLimits.timeFrameLT[0] = events[0].timeLT;
      }
      i--;
      if (i === 0) {
          callback(this.timeLimits);
      }
    }.bind(this));
  }
};


// --------- private stuff to be hidden

/**
 * @private
 * @param {String | null} key
 * @param {Connection~requestCallback} callback - handles the response
 */
Profile.prototype._get = function (path, key, callback) {
  this.connection.request({
    method: 'GET',
    path: path,
    callback: function(error, result) {
      if (error) {
        return callback(error);
      }
      result = result.profile || null;
      if (key !== null && result) {
        result = result[key];
      }
      callback(null, result);
    }
  });
};

/**
 * @private
 * @example
 * // set x=25 and delete y
 * conn.profile.set({x : 25, y : null}, function(error) { console.log('done'); });
 *
 * @param {Object} keyValuePairs
 * @param {Connection~requestCallback} callback - handles the response
 */
Profile.prototype._set = function (path, keyValuePairs, callback) {
  this.connection.request({
    method: 'PUT',
    path: path,
    callback: callback,
    jsonData: keyValuePairs
  });
};

module.exports = Profile;
},{"./ConnectionConstants.js":41}],45:[function(require,module,exports){
var _ = require('underscore'),
  utility = require('../utility/utility.js'),
  Stream = require('../Stream.js'),
  CC = require('./ConnectionConstants.js');

/**
 * @class ConnectionStreams
 * @description
 * ##Coverage of the API
 *
 *  * GET /streams -- 100%
 *  * POST /streams -- only data (no object)
 *  * PUT /streams -- 0%
 *  * DELETE /streams/{stream-id} -- 0%
 *
 *
 *
 * @param {Connection} connection
 * @constructor
 */
function ConnectionStreams(connection) {
  this.connection = connection;
  this._streamsIndex = {};
}


/**
 * @typedef ConnectionStreamsOptions parameters than can be passed along a Stream request
 * @property {string} parentId  if parentId is null you will get all the "root" streams.
 * @property {string} [state] 'all' || null  - if null you get only "active" streams
 **/


/**
 * @param {ConnectionStreamsOptions} options
 * @param {ConnectionStreams~getCallback} callback - handles the response
 */
ConnectionStreams.prototype.get = function (options, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (this.connection.datastore) {
    var resultTree = [];
    if (options && _.has(options, 'parentId')) {
      resultTree = this.connection.datastore.getStreamById(options.parentId).children;
    } else if (options && _.has(options, 'state')) {
      resultTree = this.connection.datastore.getStreams(options.state);
    } else {
      resultTree = this.connection.datastore.getStreams();
    }
    if (resultTree.length > 0) {
      callback(null, resultTree);
    } else {
      this._getObjects(options, callback);
    }
  } else {
    this._getObjects(options, callback);
  }
};

/**
 * TODO make it object-aware like for Events
 * TODO why to we need a _create ?
 * TODO could return Stream object synchronously before calling the API
 * @param streamData
 * @param callback
 */
ConnectionStreams.prototype.create = function (streamData, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  streamData = _.pick(streamData, 'id', 'name', 'parentId', 'singleActivity',
    'clientData', 'trashed');
  return this._createWithData(streamData, callback);
};


ConnectionStreams.prototype.update = function (streamData, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }

  if (typeof streamData === 'object') {
    streamData = [ streamData ];
  }

  _.each(streamData, function (e) {
    var s = _.pick(e, 'id', 'name', 'parentId', 'singleActivity',
      'clientData', 'trashed');
    this.connection.request({
      method: 'PUT',
      path: '/streams/' + s.id,
      callback: function (error, result) {
        if (!error && result && result.stream) {

          this._getObjects(null, function (err, res) {
            if (!err && res) {
              if (!this.connection.datastore) {
                result = new Stream(this.connection, result.stream);
              } else {
                result = this.connection.datastore.createOrReuseStream(result.stream);
                if (result.parent &&
                  _.indexOf(result.parent.childrenIds, result.id) === -1) {
                  result.parent.childrenIds.push(result.id);
                }
              }
            } else {
              result = null;
            }

            callback(err, result);
          }.bind(this));

        } else {
          result = null;
        }
        if (error) {
          callback(error, null);
        }
      }.bind(this),
      jsonData: s
    });
  }.bind(this));
};


/**
 * @param streamData
 * @param callback
 * @param mergeEventsWithParent
 */
ConnectionStreams.prototype.delete = ConnectionStreams.prototype.trash =
    function (streamData, callback, mergeEventsWithParent) {
      if (typeof(callback) !== 'function') {
        throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
      }
      var id;
      if (streamData && streamData.id) {
        id = streamData.id;
      } else {
        id = streamData;
      }

      mergeEventsWithParent = mergeEventsWithParent ? true : false;
      this.connection.request({
        method: 'DELETE',
        path: '/streams/' + id + '?mergeEventsWithParent=' + mergeEventsWithParent,
        callback: function (error, resultData) {
          var stream = null;
          if (!error && resultData && resultData.stream) {
            streamData.id = resultData.stream.id;
            stream = new Stream(this.connection, resultData.stream);
            if (this.connection.datastore) {
              this.connection.datastore.indexStream(stream);
            }
          }
          return callback(error, error ? null : resultData.stream);
        }.bind(this)
      });
};


/**
 * TODO remove it's unused
 * @param {ConnectionStreamsOptions} options
 * @param {ConnectionStreams~getCallback} callback - handles the response
 */
ConnectionStreams.prototype.updateProperties = function (stream, properties, options, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  if (this.connection.datastore) {
    var resultTree = [];
    if (options && _.has(options, 'parentId')) {
      resultTree = this.connection.datastore.getStreamById(options.parentId).children;
    } else {
      resultTree = this.connection.datastore.getStreams();
    }
    callback(null, resultTree);
  } else {
    this._getObjects(options, callback);
  }
};


/**
 * TODO remove it's unused and could lead to miscomprehension
 * Get a Stream by it's Id.
 * Works only if fetchStructure has been done once.
 * @param {string} streamId
 * @throws {Error} Connection.fetchStructure must have been called before.
 */
ConnectionStreams.prototype.getById = function (streamId) {
  if (!this.connection.datastore) {
    throw new Error('Call connection.fetchStructure before, to get automatic stream mapping');
  }
  return this.connection.datastore.getStreamById(streamId);
};


// ------------- Raw calls to the API ----------- //

/**
 * TODO rename _getStreams
 * get streams on the API
 * @private
 * @param {ConnectionStreams~options} opts
 * @param callback
 */
ConnectionStreams.prototype._getData = function (opts, callback) {
  this.connection.request({
    method: 'GET',
    path: opts ? '/streams?' + utility.getQueryParametersString(opts) : '/streams',
    callback: callback
  });
};


/**
 * TODO makes it return the Stream object before doing the online request
 * TODO create a streamLike Object
 * Create a stream on the API with a jsonObject
 * @private
 * @param {Object} streamData an object array.. typically one that can be obtained with
 * stream.getData()
 * @param callback
 */
ConnectionStreams.prototype._createWithData = function (streamData, callback) {
  this.connection.request({
    method: 'POST',
    path: '/streams',
    jsonData: streamData,
    callback: function (err, resultData) {
      var stream = null;
      if (!err && resultData) {
        streamData.id = resultData.stream.id;
        stream = new Stream(this.connection, resultData.stream);
        if (this.connection.datastore) {
          this.connection.datastore.indexStream(stream);
        }
      }
      if (_.isFunction(callback)) {
        return callback(err, err ? null : stream);
      }
    }.bind(this)
  });
};

/**
 * Update a stream on the API with a jsonObject
 * @private
 * @param {Object} streamData an object array.. typically one that can be obtained with
 * stream.getData()
 * @param callback
 */
ConnectionStreams.prototype._updateWithData = function (streamData, callback) {
  this.connection.request({
    method: 'PUT',
    path: '/streams/' + streamData.id,
    jsonData: streamData,
    callback: callback
  });
};

// -- helper for get --- //

/**
 * @private
 * @param {ConnectionStreams~options} options
 */
ConnectionStreams.prototype._getObjects = function (options, callback) {
  options = options || {};
  options.parentId = options.parentId || null;
  var streamsIndex = {};
  var resultTree = [];
  this._getData(options, function (error, result) {
    if (error) {
      return callback('Stream.get failed: ' + JSON.stringify(error));
    }
    var treeData = result.streams || result.stream;
    ConnectionStreams.Utils.walkDataTree(treeData, function (streamData) {
      var stream = new Stream(this.connection, streamData);
      streamsIndex[streamData.id] = stream;
      if (stream.parentId === options.parentId) { // attached to the rootNode or filter
        resultTree.push(stream);
        stream._parent = null;
        stream._children = [];
      } else {
        // localStorage will cleanup  parent / children link if needed
        stream._parent = streamsIndex[stream.parentId];
        stream._parent._children.push(stream);
      }
    }.bind(this));
    callback(null, resultTree);
  }.bind(this));
};


/**
 * Called once per streams
 * @callback ConnectionStreams~walkTreeEachStreams
 * @param {Stream} stream
 */

/**
 * Called when walk is done
 * @callback ConnectionStreams~walkTreeDone
 */

/**
 * Walk the tree structure.. parents are always announced before childrens
 * @param {ConnectionStreams~options} options
 * @param {ConnectionStreams~walkTreeEachStreams} eachStream
 * @param {ConnectionStreams~walkTreeDone} done
 */
ConnectionStreams.prototype.walkTree = function (options, eachStream, done) {
  this.get(options, function (error, result) {
    if (error) {
      return done('Stream.walkTree failed: ' + error);
    }
    ConnectionStreams.Utils.walkObjectTree(result, eachStream);
    if (done) {
      done(null);
    }
  });
};


/**
 * Get the all the streams of the Tree in a list.. parents firsts
 * @param {ConnectionStreams~options} options
 * @param {ConnectionStreams~getFlatenedObjectsDone} done
 */
ConnectionStreams.prototype.getFlatenedObjects = function (options, callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  var result = [];
  this.walkTree(options,
    function (stream) { // each stream
      result.push(stream);
    }, function (error) {  // done
      if (error) {
        return callback(error);
      }
      callback(null, result);
    }.bind(this));
};


/**
 * Utility to debug a tree structure
 * @param {ConnectionStreams[]} arrayOfStreams
 */
ConnectionStreams.prototype.getDisplayTree = function (arrayOfStreams) {
  return ConnectionStreams.Utils._debugTree(arrayOfStreams);
};

/**
 * Utility to get a Stream Tree as if was sent by the API
 * @param {ConnectionStreams[]} arrayOfStreams
 */
ConnectionStreams.prototype.toJSON = function (arrayOfStreams) {
  return ConnectionStreams.Utils.toJSON(arrayOfStreams);
};


// TODO Validate that it's the good place for them .. Could have been in Stream or utility
ConnectionStreams.Utils = {

  /**
   * Make a pure JSON object from an array of Stream.. shoudl be the same than what we
   * get from the API
   * @param streamArray
   * @param eachStream
   */
  toJSON: function (arrayOfStreams) {

    var result = [];
    if (!arrayOfStreams || !(arrayOfStreams instanceof Array)) {
      throw new Error('expected an array for argument :' + arrayOfStreams);
    }

    _.each(arrayOfStreams, function (stream) {
      if (!stream || !(stream instanceof Stream)) {
        throw new Error('expected a Streams array ' + stream);
      }
      result.push({
        name: stream.name,
        id: stream.id,
        parentId: stream.parentId,
        singleActivity: stream.singleActivity,
        clientData: stream.clientData,
        trashed: stream.trashed,
        created: stream.created,
        createdBy: stream.createdBy,
        modified: stream.modified,
        modifiedBy: stream.modifiedBy,
        children: ConnectionStreams.Utils.toJSON(stream.children)
      });
    });
    return result;
  },

  /**
   * Walk thru a streamArray of objects
   * @param streamTree
   * @param callback function(stream)
   */
  walkObjectTree: function (streamArray, eachStream) {
    _.each(streamArray, function (stream) {
      eachStream(stream);
      ConnectionStreams.Utils.walkObjectTree(stream.children, eachStream);
    });
  },

  /**
   * Walk thru a streamTree obtained from the API. Replaces the children[] by childrenIds[].
   * This is used to Flaten the Tree
   * @param streamTree
   * @param callback function(streamData, subTree)  subTree is the descendance tree
   */
  walkDataTree: function (streamTree, callback) {
    if (typeof(callback) !== 'function') {
      throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
    }
    _.each(streamTree, function (streamStruct) {
      var stream = _.omit(streamStruct, 'children');
      stream.childrenIds = [];
      var subTree = {};
      callback(stream, subTree);
      if (_.has(streamStruct, 'children')) {
        subTree = streamStruct.children;

        _.each(streamStruct.children, function (childTree) {
          stream.childrenIds.push(childTree.id);
        });
        this.walkDataTree(streamStruct.children, callback);
      }
    }.bind(this));
  },


  /**
   * ShowTree
   */
  _debugTree: function (arrayOfStreams) {
    var result = [];
    if (!arrayOfStreams || !(arrayOfStreams instanceof Array)) {
      throw new Error('expected an array for argument :' + arrayOfStreams);
    }
    _.each(arrayOfStreams, function (stream) {
      if (!stream || !(stream instanceof Stream)) {
        throw new Error('expected a Streams array ' + stream);
      }
      result.push({
        name: stream.name,
        id: stream.id,
        parentId: stream.parentId,
        children: ConnectionStreams.Utils._debugTree(stream.children)
      });
    });
    return result;
  }

};

module.exports = ConnectionStreams;

/**
 * Called with the desired streams as result.
 * @callback ConnectionStreams~getCallback
 * @param {Object} error - eventual error
 * @param {Stream[]} result
 */


},{"../Stream.js":34,"../utility/utility.js":60,"./ConnectionConstants.js":41,"underscore":28}],46:[function(require,module,exports){
module.exports={
  "version": "0.2.9",
  "sets": {
    "basic-measurements-metric": {
      "name": {
        "en": "Metric measures (basics)",
        "fr": "Mesures métriques de base"
      },
      "description": {
        "en": "Kg, m, Km, ... "
      },
      "types": {
        "count": [
          "generic"
        ],
        "length": [
          "cm",
          "km",
          "m",
          "mm"
        ],
        "mass": [
          "kg",
          "g",
          "t"
        ],
        "temperature": [
          "c"
        ],
        "ratio": [
          "percent"
        ],
        "speed": [
          "km-h",
          "m-s"
        ],
        "volume": [
          "l",
          "m3",
          "ml"
        ]
      }
    },
    "generic-measurements-metric": {
      "name": {
        "en": "Metric measures",
        "fr": "Mesures métriques"
      },
      "description": {
        "en": "Kg, m, Km, ... "
      },
      "types": {
        "area": [
          "ha",
          "km2",
          "m2"
        ],
        "electric-current": [
          "a"
        ],
        "electromotive-force": [
          "v"
        ],
        "energy": [
          "cal",
          "j",
          "kcal"
        ],
        "frequency": [
          "hz",
          "bpm",
          "rpm"
        ],
        "length": [
          "cm",
          "km",
          "m",
          "mm"
        ],
        "mass": [
          "kg",
          "g",
          "t"
        ],
        "power": [
          "hp",
          "kw",
          "w"
        ],
        "pressure": [
          "bar",
          "kg-m2",
          "pa",
          "kpa"
        ],
        "temperature": [
          "c"
        ],
        "speed": [
          "km-h",
          "m-s"
        ],
        "volume": [
          "l",
          "m3",
          "ml"
        ]
      }
    },
    "basic-measurements-imperial": {
      "name": {
        "en": "Imperial measures (basics)",
        "fr": "Mesures, système impérial (de base)"
      },
      "description": {
        "en": "lb, in, ft, ..."
      },
      "types": {
        "count": [
          "generic"
        ],
        "length": [
          "ch",
          "lea",
          "ft",
          "in",
          "mi",
          "fur",
          "yd"
        ],
        "mass": [
          "lb",
          "oz",
          "s-t",
          "st"
        ],
        "temperature": [
          "f"
        ],
        "ratio": [
          "percent"
        ],
        "speed": [
          "ft-s",
          "m-min",
          "mph"
        ],
        "volume": [
          "c",
          "floz",
          "galgb",
          "pt",
          "qt",
          "tbs",
          "tsp"
        ]
      }
    },
    "generic-measurements-imperial": {
      "name": {
        "en": "Imperial measures",
        "fr": "Mesures, système impérial"
      },
      "description": {
        "en": "lb, in, ft, ..."
      },
      "types": {
        "area": [
          "ac",
          "ft2",
          "in2",
          "yd2",
          "mi2"
        ],
        "electric-current": [
          "a"
        ],
        "electromotive-force": [
          "v"
        ],
        "energy": [
          "btu",
          "erg",
          "ftlb",
          "kcal"
        ],
        "force": [
          "pdl"
        ],
        "length": [
          "ch",
          "lea",
          "ft",
          "in",
          "mi",
          "fur",
          "yd"
        ],
        "mass": [
          "lb",
          "oz",
          "s-t",
          "st"
        ],
        "power": [
          "hp"
        ],
        "pressure": [
          "inhg",
          "psi"
        ],
        "temperature": [
          "f"
        ],
        "speed": [
          "ft-s",
          "m-min",
          "mph"
        ],
        "volume": [
          "c",
          "floz",
          "galgb",
          "pt",
          "qt",
          "tbs",
          "tsp"
        ]
      }
    },
    "basic-measurements-us": {
      "name": {
        "en": "US measures (basics)",
        "fr": "Mesures USA (de base)"
      },
      "description": {
        "en": "yd, mil, oz, ..."
      },
      "types": {
        "count": [
          "generic"
        ],
        "length": [
          "ch",
          "ft",
          "in",
          "mil",
          "mi",
          "fur",
          "p",
          "pica",
          "yd"
        ],
        "mass": [
          "gr",
          "dr",
          "l-t",
          "lb",
          "oz"
        ],
        "temperature": [
          "f"
        ],
        "ratio": [
          "percent"
        ],
        "speed": [
          "ft-s",
          "m-min",
          "mph"
        ],
        "volume": [
          "c",
          "floz",
          "ft3",
          "galus",
          "in3",
          "yd3",
          "pt",
          "qt",
          "bbloil",
          "tbs",
          "tsp"
        ]
      }
    },
    "generic-measurements-us": {
      "name": {
        "en": "US measures",
        "fr": "Mesures USA"
      },
      "description": {
        "en": "yd, mil, oz, ..."
      },
      "types": {
        "area": [
          "ac",
          "ft2",
          "in2",
          "yd2"
        ],
        "electric-current": [
          "a"
        ],
        "electromotive-force": [
          "v"
        ],
        "length": [
          "ch",
          "ft",
          "in",
          "mil",
          "mi",
          "fur",
          "p",
          "pica",
          "yd"
        ],
        "mass": [
          "gr",
          "dr",
          "l-t",
          "lb",
          "oz"
        ],
        "power": [
          "hp"
        ],
        "pressure": [
          "inhg",
          "psi"
        ],
        "temperature": [
          "f"
        ],
        "speed": [
          "ft-s",
          "m-min",
          "mph"
        ],
        "volume": [
          "c",
          "floz",
          "ft3",
          "galus",
          "in3",
          "yd3",
          "pt",
          "qt",
          "bbloil",
          "tbs",
          "tsp"
        ]
      }
    },
    "money-most-used": {
      "name": {
        "en": "Most used currencies",
        "fr": "Devises les plus utilisées"
      },
      "description": {
        "en": "$, €, ¥, ..."
      },
      "types": {
        "money": [
          "eur",
          "usd",
          "cny",
          "gbp",
          "jpy",
          "chf",
          "cad"
        ]
      }
    },
    "money-europe": {
      "name": {
        "en": "Currencies Europe",
        "fr": "Devises Europe"
      },
      "description": {
        "en": "€, £, CHF, ..."
      },
      "types": {
        "money": [
          "all",
          "byr",
          "bam",
          "bgn",
          "hrk",
          "czk",
          "dkk",
          "eek",
          "eur",
          "fkp",
          "gip",
          "ggp",
          "huf",
          "isk",
          "irr",
          "jep",
          "lvl",
          "ltl",
          "mkd",
          "ang",
          "nok",
          "pln",
          "ron",
          "rub",
          "shp",
          "rsd",
          "sek",
          "chf",
          "try",
          "trl",
          "uah",
          "gbp"
        ]
      }
    },
    "money-america": {
      "name": {
        "en": "Currencies Americas",
        "fr": "Devises Amériques"
      },
      "description": {
        "en": "$US, $CAD,  BRL, ..."
      },
      "types": {
        "money": [
          "ars",
          "bsd",
          "bbd",
          "bzd",
          "bmd",
          "bob",
          "brl",
          "cad",
          "kyd",
          "clp",
          "cop",
          "crc",
          "cup",
          "dop",
          "xcd",
          "svc",
          "fjd",
          "gtq",
          "gyd",
          "jmd",
          "mxn",
          "nio",
          "pab",
          "pyg",
          "pen",
          "shp",
          "srd",
          "ttd",
          "usd",
          "uyu",
          "vef"
        ]
      }
    },
    "money-asia": {
      "name": {
        "en": "Currencies Asia",
        "fr": "Devises Asie"
      },
      "description": {
        "en": "¥, 元, INR, ..."
      },
      "types": {
        "money": [
          "azn",
          "khr",
          "cny",
          "hnl",
          "inr",
          "idr",
          "jpy",
          "kzt",
          "kpw",
          "krw",
          "kgs",
          "lak",
          "myr",
          "mur",
          "mnt",
          "npr",
          "pkr",
          "rub",
          "scr",
          "sgd",
          "lkr",
          "syp",
          "twd",
          "thb",
          "try",
          "trl",
          "uzs",
          "vnd"
        ]
      }
    },
    "money-africa": {
      "name": {
        "en": "Currencies Africa",
        "fr": "Devises Afrique"
      },
      "description": {
        "en": "BWP, EGP, GHC, ..."
      },
      "types": {
        "money": [
          "bwp",
          "egp",
          "ghc",
          "mzn",
          "nad",
          "ngn",
          "sos",
          "zar",
          "zwd"
        ]
      }
    },
    "money-indonesia-australia": {
      "name": {
        "en": "Currencies Oceania & Indonesia",
        "fr": "Devises Océanie & Indonésie"
      },
      "description": {
        "en": "$AU, $NZ, PHP, ... "
      },
      "types": {
        "money": [
          "aud",
          "nzd",
          "php",
          "sbd",
          "tvd"
        ]
      }
    },
    "money-middleeast": {
      "name": {
        "en": "Currencies Middle East",
        "fr": "Devises Moyen-Orient"
      },
      "description": {
        "en": "AFN, BND, OMR, ...."
      },
      "types": {
        "money": [
          "afn",
          "bnd",
          "egp",
          "imp",
          "lbp",
          "omr",
          "qar",
          "sar",
          "syp",
          "yer"
        ]
      }
    },
    "generic-medical": {
      "name": {
        "en": "Common health mesures",
        "fr": "Mesures de santé courantes"
      },
      "description": {
        "en": "mmhg, bpm, ..."
      },
      "types": {
        "count": [
          "steps"
        ],
        "density": [
          "mg-dl",
          "mmol-l"
        ],
        "pressure": [
          "mmhg"
        ],
        "frequency": [
          "bpm"
        ]
      }
    },
    "navigation": {
      "name": {
        "en": "Navigation",
        "fr": "Navigation"
      },
      "description": {
        "en": "nmi, °, kt, ..."
      },
      "types": {
        "angle": [
          "deg",
          "grad",
          "rad"
        ],
        "length": [
          "nmi",
          "ftm",
          "cb"
        ],
        "speed": [
          "kt"
        ]
      }
    },
    "all-measures": {
      "name": {
        "en": "All measures",
        "fr": "Toutes les mesures"
      },
      "types": {
        "absorbed-dose": [
          "gy"
        ],
        "absorbed-dose-equivalent": [
          "sv"
        ],
        "absorbed-dose-rate": [
          "gy-s"
        ],
        "mol": [
          "mol"
        ],
        "angle": [
          "deg",
          "grad",
          "rad"
        ],
        "angular-acceleration": [
          "rad-s2"
        ],
        "area": [
          "ac",
          "ft2",
          "ha",
          "in2",
          "km2",
          "m2",
          "mm2",
          "yd2",
          "mi2"
        ],
        "capacitance": [
          "f"
        ],
        "catalytic-activity": [
          "kat"
        ],
        "data-quantity": [
          "b",
          "bits",
          "gb",
          "gbits",
          "kb",
          "kbits",
          "mb",
          "mbits",
          "tb"
        ],
        "density": [
          "g-dl",
          "kg-m3",
          "mg-dl",
          "mmol-l"
        ],
        "time": [
          "d",
          "h",
          "min",
          "ms",
          "s",
          "y"
        ],
        "dynamic-viscosity": [
          "pa-s"
        ],
        "electric-charge": [
          "c"
        ],
        "electric-charge-line-density": [
          "c-m"
        ],
        "electric-current": [
          "a"
        ],
        "electrical-conductivity": [
          "s"
        ],
        "electromotive-force": [
          "v"
        ],
        "energy": [
          "btu",
          "cal",
          "ev",
          "erg",
          "ftlb",
          "j",
          "kcal",
          "ws",
          "kwh",
          "nm",
          "wh"
        ],
        "force": [
          "dyn",
          "n",
          "pdl"
        ],
        "length": [
          "a",
          "au",
          "cm",
          "ch",
          "lea",
          "ft",
          "in",
          "km",
          "ly",
          "m",
          "mil",
          "mi",
          "fur",
          "mm",
          "nmi",
          "p",
          "pica",
          "ftm",
          "cb",
          "um",
          "yd"
        ],
        "luminous-intensity": [
          "cd"
        ],
        "mass": [
          "gr",
          "dr",
          "kg",
          "g",
          "l-t",
          "lb",
          "t",
          "oz",
          "s-t",
          "st"
        ],
        "power": [
          "btu-min",
          "ftlb-s",
          "hp",
          "kw",
          "w"
        ],
        "pressure": [
          "at",
          "bar",
          "cmhg",
          "inhg",
          "kg-m2",
          "pa",
          "kpa",
          "psf",
          "psi"
        ],
        "temperature": [
          "c",
          "f",
          "k"
        ],
        "speed": [
          "ft-m",
          "ft-s",
          "km-h",
          "kt",
          "m-min",
          "m-s",
          "mph"
        ],
        "volume": [
          "c",
          "cm3",
          "floz",
          "ft3",
          "galgb",
          "galus",
          "in3",
          "yd3",
          "l",
          "m3",
          "ml",
          "pt",
          "qt",
          "bbloil",
          "tbs",
          "tsp"
        ]
      }
    }
  },
  "extras": {
    "count": {
      "name": {
        "en": "Count",
        "fr": "Compte"
      },
      "formats": {
        "steps": {
          "name": {
            "en": "Steps",
            "fr": "Pas"
          }
        },
        "generic": {
          "name": {
            "en": "Units",
            "fr": "Unités"
          }
        }
      }
    },
    "money": {
      "name": {
        "en": "Money",
        "fr": "Argent"
      },
      "formats": {
        "chf": {
          "name": {
            "en": "Switzerland Franc",
            "fr": "Franc Suisse"
          },
          "symbol": "CHF"
        },
        "cny": {
          "name": {
            "en": "China Yuan Renminbi",
            "fr": "Yuan Ren-Min-Bi"
          },
          "symbol": "¥"
        },
        "eur": {
          "symbol": "€",
          "name": {
            "en": "Euro",
            "fr": "Euro"
          }
        },
        "gbp": {
          "name": {
            "en": "United Kingdom Pound",
            "fr": "Livre"
          },
          "symbol": "£"
        },
        "jpy": {
          "name": {
            "en": "Japan Yen",
            "fr": "Yen japonais"
          },
          "symbol": "¥"
        },
        "usd": {
          "name": {
            "en": "United States Dollar",
            "fr": "Dollar des États-Unis"
          },
          "symbol": "$"
        },
        "btc": {
          "name": {
            "en": "Bitcoin"
          },
          "symbol": "฿"
        },
        "all": {
          "name": {
            "en": "Albania Lek",
            "fr": "Lek Albanai"
          },
          "symbol": "Lek"
        },
        "afn": {
          "name": {
            "en": "Afghanistan Afghani",
            "fr": "Afghani"
          },
          "symbol": "؋"
        },
        "ars": {
          "name": {
            "en": "Argentina Peso",
            "fr": "Peso argentin"
          },
          "symbol": "$"
        },
        "awg": {
          "name": {
            "en": "Aruba Guilder",
            "fr": "Florin d'Aruba"
          },
          "symbol": "ƒ"
        },
        "aud": {
          "name": {
            "en": "Australia Dollar",
            "fr": "Dollar australien"
          },
          "symbol": "$"
        },
        "azn": {
          "name": {
            "en": "Azerbaijan New Manat",
            "fr": "Manat"
          },
          "symbol": "ман"
        },
        "bsd": {
          "name": {
            "en": "Bahamas Dollar",
            "fr": "Dollar des Bahamas"
          },
          "symbol": "$"
        },
        "bbd": {
          "name": {
            "en": "Barbados Dollar",
            "fr": "Dollar de Barbade"
          },
          "symbol": "$"
        },
        "byr": {
          "name": {
            "en": "Belarus Ruble",
            "fr": "Rouble bélorusse"
          },
          "symbol": "p."
        },
        "bzd": {
          "name": {
            "en": "Belize Dollar",
            "fr": "Dollar de Belize"
          },
          "symbol": "BZ$"
        },
        "bmd": {
          "name": {
            "en": "Bermuda Dollar",
            "fr": "Dollar des Bermudes"
          },
          "symbol": "$"
        },
        "bob": {
          "name": {
            "en": "Bolivia Boliviano",
            "fr": "Boliviano"
          },
          "symbol": "$b"
        },
        "bam": {
          "name": {
            "en": "Bosnia and Herzegovina Convertible Marka"
          },
          "symbol": "KM"
        },
        "bwp": {
          "name": {
            "en": "Botswana Pula"
          },
          "symbol": "P"
        },
        "bgn": {
          "name": {
            "en": "Bulgaria Lev",
            "fr": "Bulgarian Lev"
          },
          "symbol": "лв"
        },
        "brl": {
          "name": {
            "en": "Brazil Real",
            "fr": "Real"
          },
          "symbol": "R$"
        },
        "bnd": {
          "name": {
            "en": "Brunei Darussalam Dollar",
            "fr": "Dollar de Brunei"
          },
          "symbol": "$"
        },
        "khr": {
          "name": {
            "en": "Cambodia Riel",
            "fr": "Riel"
          },
          "symbol": "៛"
        },
        "cad": {
          "name": {
            "en": "Canada Dollar",
            "fr": "Dollar canadien"
          },
          "symbol": "$"
        },
        "kyd": {
          "name": {
            "en": "Cayman Islands Dollar",
            "fr": "Dollar des Iles Caïmans"
          },
          "symbol": "$"
        },
        "clp": {
          "name": {
            "en": "Chile Peso",
            "fr": "Peso chilien"
          },
          "symbol": "$"
        },
        "cop": {
          "name": {
            "en": "Colombia Peso",
            "fr": "Peso colombien"
          },
          "symbol": "$"
        },
        "crc": {
          "name": {
            "en": "Costa Rica Colon",
            "fr": "Colon de Costa Rica"
          },
          "symbol": "₡"
        },
        "hrk": {
          "name": {
            "en": "Croatia Kuna",
            "fr": "Kuna"
          },
          "symbol": "kn"
        },
        "cup": {
          "name": {
            "en": "Cuba Peso",
            "fr": "Peso cubain"
          },
          "symbol": "₱"
        },
        "czk": {
          "name": {
            "en": "Czech Republic Koruna"
          },
          "symbol": "Kč"
        },
        "dkk": {
          "name": {
            "en": "Denmark Krone",
            "fr": "Couronne danoise"
          },
          "symbol": "kr"
        },
        "dop": {
          "name": {
            "en": "Dominican Republic Peso",
            "fr": "Peso dominicain"
          },
          "symbol": "RD$"
        },
        "xcd": {
          "name": {
            "en": "East Caribbean Dollar",
            "fr": "Dollar des Caraïbes orientales"
          },
          "symbol": "$"
        },
        "egp": {
          "name": {
            "en": "Egypt Pound",
            "fr": "Livre égyptienne"
          },
          "symbol": "£"
        },
        "svc": {
          "name": {
            "en": "El Salvador Colon",
            "fr": "Colon du El Salvador"
          },
          "symbol": "$"
        },
        "eek": {
          "name": {
            "en": "Estonia Kroon",
            "fr": "Couronne estonienne"
          },
          "symbol": "kr"
        },
        "fkp": {
          "name": {
            "en": "Falkland Islands (Malvinas) Pound"
          },
          "symbol": "£"
        },
        "fjd": {
          "name": {
            "en": "Fiji Dollar"
          },
          "symbol": "$"
        },
        "ghc": {
          "name": {
            "en": "Ghana Cedis"
          },
          "symbol": "¢"
        },
        "gip": {
          "name": {
            "en": "Gibraltar Pound"
          },
          "symbol": "£"
        },
        "gtq": {
          "name": {
            "en": "Guatemala Quetzal"
          },
          "symbol": "Q"
        },
        "ggp": {
          "name": {
            "en": "Guernsey Pound"
          },
          "symbol": "£"
        },
        "gyd": {
          "name": {
            "en": "Guyana Dollar"
          },
          "symbol": "$"
        },
        "hnl": {
          "name": {
            "en": "Honduras Lempira"
          },
          "symbol": "L"
        },
        "hkd": {
          "name": {
            "en": "Hong Kong Dollar"
          },
          "symbol": "$"
        },
        "huf": {
          "name": {
            "en": "Hungary Forint"
          },
          "symbol": "Ft"
        },
        "isk": {
          "name": {
            "en": "Iceland Krona"
          },
          "symbol": "kr"
        },
        "inr": {
          "name": {
            "en": "India Rupee",
            "fr": "Rhoupie indienne"
          }
        },
        "idr": {
          "name": {
            "en": "Indonesia Rupiah"
          },
          "symbol": "Rp"
        },
        "irr": {
          "name": {
            "en": "Iran Rial"
          },
          "symbol": "﷼"
        },
        "imp": {
          "name": {
            "en": "Isle of Man Pound"
          },
          "symbol": "£"
        },
        "ils": {
          "name": {
            "en": "Israel Shekel"
          },
          "symbol": "₪"
        },
        "jmd": {
          "name": {
            "en": "Jamaica Dollar"
          },
          "symbol": "J$"
        },
        "jep": {
          "name": {
            "en": "Jersey Pound"
          },
          "symbol": "£"
        },
        "kzt": {
          "name": {
            "en": "Kazakhstan Tenge"
          },
          "symbol": "лв"
        },
        "kpw": {
          "name": {
            "en": "Korea (North) Won",
            "fr": "Won de la Corée du Nord"
          },
          "symbol": "₩"
        },
        "krw": {
          "name": {
            "en": "Korea (South) Won",
            "fr": "Won"
          },
          "symbol": "₩"
        },
        "kgs": {
          "name": {
            "en": "Kyrgyzstan Som"
          },
          "symbol": "лв"
        },
        "lak": {
          "name": {
            "en": "Laos Kip"
          },
          "symbol": "₭"
        },
        "lvl": {
          "name": {
            "en": "Latvia Lat",
            "fr": "Lat letton"
          },
          "symbol": "Ls"
        },
        "lbp": {
          "name": {
            "en": "Lebanon Pound"
          },
          "symbol": "£"
        },
        "lrd": {
          "name": {
            "en": "Liberia Dollar"
          },
          "symbol": "$"
        },
        "ltl": {
          "name": {
            "en": "Lithuania Litas"
          },
          "symbol": "Lt"
        },
        "mkd": {
          "name": {
            "en": "Macedonia Denar"
          },
          "symbol": "ден"
        },
        "myr": {
          "name": {
            "en": "Malaysia Ringgit"
          },
          "symbol": "RM"
        },
        "mur": {
          "name": {
            "en": "Mauritius Rupee"
          },
          "symbol": "₨"
        },
        "mxn": {
          "name": {
            "en": "Mexico Peso"
          },
          "symbol": "$"
        },
        "mnt": {
          "name": {
            "en": "Mongolia Tughrik"
          },
          "symbol": "₮"
        },
        "mzn": {
          "name": {
            "en": "Mozambique Metical"
          },
          "symbol": "MT"
        },
        "nad": {
          "name": {
            "en": "Namibia Dollar"
          },
          "symbol": "$"
        },
        "npr": {
          "name": {
            "en": "Nepal Rupee"
          },
          "symbol": "₨"
        },
        "ang": {
          "name": {
            "en": "Netherlands Antilles Guilder",
            "fr": "Florin des Antilles"
          },
          "symbol": "ƒ"
        },
        "nzd": {
          "name": {
            "en": "New Zealand Dollar",
            "fr": "Dollar néo-zélandais"
          },
          "symbol": "$"
        },
        "nio": {
          "name": {
            "en": "Nicaragua Cordoba"
          },
          "symbol": "C$"
        },
        "ngn": {
          "name": {
            "en": "Nigeria Naira"
          },
          "symbol": "₦"
        },
        "nok": {
          "name": {
            "en": "Norway Krone",
            "fr": "Couronne norvégienne"
          },
          "symbol": "kr"
        },
        "omr": {
          "name": {
            "en": "Oman Rial"
          },
          "symbol": "﷼"
        },
        "pkr": {
          "name": {
            "en": "Pakistan Rupee"
          },
          "symbol": "₨"
        },
        "pab": {
          "name": {
            "en": "Panama Balboa"
          },
          "symbol": "B/."
        },
        "pyg": {
          "name": {
            "en": "Paraguay Guarani"
          },
          "symbol": "Gs"
        },
        "pen": {
          "name": {
            "en": "Peru Nuevo Sol"
          },
          "symbol": "S/."
        },
        "php": {
          "name": {
            "en": "Philippines Peso"
          },
          "symbol": "₱"
        },
        "pln": {
          "name": {
            "en": "Poland Zloty"
          },
          "symbol": "zł"
        },
        "qar": {
          "name": {
            "en": "Qatar Riyal"
          },
          "symbol": "﷼"
        },
        "ron": {
          "name": {
            "en": "Romania New Leu"
          },
          "symbol": "lei"
        },
        "rub": {
          "name": {
            "en": "Russia Ruble"
          },
          "symbol": "руб"
        },
        "shp": {
          "name": {
            "en": "Saint Helena Pound"
          },
          "symbol": "£"
        },
        "sar": {
          "name": {
            "en": "Saudi Arabia Riyal",
            "fr": "Riyal saoudien"
          },
          "symbol": "﷼"
        },
        "rsd": {
          "name": {
            "en": "Serbia Dinar"
          },
          "symbol": "Дин."
        },
        "scr": {
          "name": {
            "en": "Seychelles Rupee"
          },
          "symbol": "₨"
        },
        "sgd": {
          "name": {
            "en": "Singapore Dollar"
          },
          "symbol": "$"
        },
        "sbd": {
          "name": {
            "en": "Solomon Islands Dollar"
          },
          "symbol": "$"
        },
        "sos": {
          "name": {
            "en": "Somalia Shilling"
          },
          "symbol": "S"
        },
        "zar": {
          "name": {
            "en": "South Africa Rand",
            "fr": "Rand"
          },
          "symbol": "R"
        },
        "lkr": {
          "name": {
            "en": "Sri Lanka Rupee"
          },
          "symbol": "₨"
        },
        "sek": {
          "name": {
            "en": "Sweden Krona"
          },
          "symbol": "kr"
        },
        "srd": {
          "name": {
            "en": "Suriname Dollar"
          },
          "symbol": "$"
        },
        "syp": {
          "name": {
            "en": "Syria Pound"
          },
          "symbol": "£"
        },
        "twd": {
          "name": {
            "en": "Taiwan New Dollar"
          },
          "symbol": "NT$"
        },
        "thb": {
          "name": {
            "en": "Thailand Baht"
          },
          "symbol": "฿"
        },
        "ttd": {
          "name": {
            "en": "Trinidad and Tobago Dollar"
          },
          "symbol": "TT$"
        },
        "try": {
          "name": {
            "en": "Turkey Lira"
          }
        },
        "trl": {
          "name": {
            "en": "Turkey Lira"
          },
          "symbol": "₤"
        },
        "tvd": {
          "name": {
            "en": "Tuvalu Dollar"
          },
          "symbol": "$"
        },
        "uah": {
          "name": {
            "en": "Ukraine Hryvna"
          },
          "symbol": "₴"
        },
        "uyu": {
          "name": {
            "en": "Uruguay Peso"
          },
          "symbol": "$U"
        },
        "uzs": {
          "name": {
            "en": "Uzbekistan Som"
          },
          "symbol": "лв"
        },
        "vef": {
          "name": {
            "en": "Venezuela Bolivar"
          },
          "symbol": "Bs"
        },
        "vnd": {
          "name": {
            "en": "Viet Nam Dong"
          },
          "symbol": "₫"
        },
        "yer": {
          "name": {
            "en": "Yemen Rial"
          },
          "symbol": "﷼"
        },
        "zwd": {
          "name": {
            "en": "Zimbabwe Dollar"
          },
          "symbol": "Z$"
        }
      }
    },
    "temperature": {
      "name": {
        "en": "Temperature",
        "fr": "Température"
      },
      "formats": {
        "c": {
          "name": {
            "en": "Degrees Celsius",
            "fr": "Degrés Celsius"
          },
          "symbol": "°C"
        },
        "f": {
          "name": {
            "en": "Degrees Fahrenheit",
            "fr": "Degrés Fahrenheit"
          },
          "symbol": "°F"
        },
        "k": {
          "name": {
            "en": "Degrees Kelvin",
            "fr": "Degrés Kelvin"
          },
          "symbol": "°K"
        }
      }
    },
    "length": {
      "name": {
        "fr": "Longueur",
        "en": "Length"
      },
      "formats": {
        "cm": {
          "name": {
            "en": "Centimeters",
            "fr": "Centimètres"
          },
          "symbol": "cm"
        },
        "km": {
          "name": {
            "en": "Kilometers",
            "fr": "Kilomètres"
          },
          "symbol": "km"
        },
        "m": {
          "name": {
            "en": "Meters",
            "fr": "Mètres"
          },
          "symbol": "m"
        },
        "mm": {
          "name": {
            "en": "Millimeters",
            "fr": "Millimètres"
          },
          "symbol": "mm"
        },
        "a": {
          "name": {
            "en": "Ångströms",
            "fr": "Ångströms"
          },
          "symbol": "Å"
        },
        "au": {
          "name": {
            "en": "Astronomical units",
            "fr": "Unités astronomiques"
          },
          "symbol": "AU"
        },
        "ch": {
          "name": {
            "en": "Chains",
            "fr": "Chaînes"
          },
          "symbol": "ch"
        },
        "lea": {
          "name": {
            "en": "Leagues",
            "fr": "Lieues"
          },
          "symbol": "lea"
        },
        "ft": {
          "name": {
            "en": "Feet",
            "fr": "Pieds"
          },
          "symbol": "ft"
        },
        "in": {
          "name": {
            "en": "Inches",
            "fr": "Pouces"
          },
          "symbol": "In"
        },
        "ly": {
          "name": {
            "en": "Light-years",
            "fr": "Années-lumière"
          },
          "symbol": "ly"
        },
        "mil": {
          "name": {
            "en": "Mils",
            "fr": "Mils"
          },
          "symbol": "mil"
        },
        "mi": {
          "name": {
            "en": "Miles",
            "fr": "Miles"
          },
          "symbol": "mi"
        },
        "fur": {
          "name": {
            "en": "Furlongs",
            "fr": "Furlongs"
          },
          "symbol": "fur"
        },
        "nmi": {
          "name": {
            "en": "Miles (nautical)",
            "fr": "Miles nautiques"
          },
          "symbol": "nmi"
        },
        "p": {
          "name": {
            "en": "Points",
            "fr": "Points"
          },
          "symbol": "p"
        },
        "pica": {
          "name": {
            "en": "Picas",
            "fr": "Picas"
          },
          "symbol": "P̸"
        },
        "ftm": {
          "name": {
            "en": "Fathoms",
            "fr": "Fathoms"
          },
          "symbol": "ftm"
        },
        "cb": {
          "name": {
            "en": "Cables",
            "fr": "Cables"
          },
          "symbol": "cb"
        },
        "um": {
          "name": {
            "en": "Microns",
            "fr": "Microns"
          },
          "symbol": "µm"
        },
        "yd": {
          "name": {
            "en": "Yards",
            "fr": "Verges"
          },
          "symbol": "yd"
        }
      }
    },
    "mass": {
      "formats": {
        "g": {
          "name": {
            "en": "Grams",
            "fr": "Grammes"
          },
          "symbol": "g"
        },
        "kg": {
          "name": {
            "en": "Kilograms",
            "fr": "Kilogrammes"
          },
          "symbol": "Kg"
        },
        "gr": {
          "name": {
            "en": "Grains",
            "fr": "Grains"
          },
          "symbol": "gr"
        },
        "dr": {
          "name": {
            "en": "Drams",
            "fr": "Drams"
          },
          "symbol": "dr"
        },
        "l-t": {
          "name": {
            "en": "Long tons",
            "fr": "Tonnes longues"
          },
          "symbol": "L/T"
        },
        "lb": {
          "name": {
            "en": "Pounds",
            "fr": "Livres"
          },
          "symbol": "lb"
        },
        "t": {
          "name": {
            "en": "Metric tons",
            "fr": "Tonnes métriques"
          },
          "symbol": "Mg"
        },
        "oz": {
          "name": {
            "en": "Ounces",
            "fr": "Onces"
          },
          "symbol": "oz"
        },
        "s-t": {
          "name": {
            "en": "Short tons",
            "fr": "Tonnes courtes"
          },
          "symbol": "S/T"
        },
        "st": {
          "name": {
            "en": "Stones",
            "fr": "Stones"
          },
          "symbol": "st"
        }
      },
      "name": {
        "en": "Mass",
        "fr": "Masse"
      }
    },
    "absorbed-dose": {
      "formats": {
        "gy": {
          "name": {
            "en": "Grays",
            "fr": "Grays"
          },
          "symbol": "Gy"
        }
      },
      "name": {
        "en": "Absorbed dose",
        "fr": "Dose absorbée"
      }
    },
    "absorbed-dose-equivalent": {
      "formats": {
        "sv": {
          "name": {
            "en": "Sieverts",
            "fr": "Sieverts"
          },
          "symbol": "Sv"
        }
      },
      "name": {
        "en": "Dose equivalent",
        "fr": "Dose équivalente"
      }
    },
    "absorbed-dose-rate": {
      "formats": {
        "gy-s": {
          "name": {
            "en": "Grays/second",
            "fr": "Grays/seconde"
          },
          "symbol": "Gy/s"
        }
      },
      "name": {
        "en": "Absorbed dose rate",
        "fr": "Débit de dose absorbée"
      }
    },
    "angle": {
      "formats": {
        "deg": {
          "name": {
            "en": "Degrees",
            "fr": "Degrés"
          },
          "symbol": "°"
        },
        "grad": {
          "name": {
            "en": "Gradians",
            "fr": "Grades"
          },
          "symbol": "grad"
        },
        "rad": {
          "name": {
            "en": "Radians",
            "fr": "Radians"
          },
          "symbol": "rad"
        }
      },
      "name": {
        "en": "Angle",
        "fr": "Angle"
      }
    },
    "angular-acceleration": {
      "formats": {
        "rad-s2": {
          "name": {
            "en": "Radians/second squared",
            "fr": "Radians/seconde carrée"
          },
          "symbol": "rad/s²"
        }
      },
      "name": {
        "en": "Angular acceleration",
        "fr": "Accélération angulaire"
      }
    },
    "area": {
      "formats": {
        "ac": {
          "name": {
            "en": "Acres (imperial)",
            "fr": "Acres (anglo-saxon)"
          },
          "symbol": "ac"
        },
        "ft2": {
          "name": {
            "en": "Square feet",
            "fr": "Pieds carrés"
          },
          "symbol": "ft²"
        },
        "ha": {
          "name": {
            "en": "Hectares",
            "fr": "Hectares"
          },
          "symbol": "ha"
        },
        "in2": {
          "name": {
            "en": "Square inches",
            "fr": "Pouces carrés"
          },
          "symbol": "in²"
        },
        "km2": {
          "name": {
            "en": "Square kilometers",
            "fr": "Kilomètres carrés"
          },
          "symbol": "km²"
        },
        "m2": {
          "name": {
            "en": "Square meters",
            "fr": "Mètres carrés"
          },
          "symbol": "m²"
        },
        "mm2": {
          "name": {
            "en": "Square millimeters",
            "fr": "Millimètres carrés"
          },
          "symbol": "mm²"
        },
        "yd2": {
          "name": {
            "en": "Square yards",
            "fr": "Verges carrées"
          },
          "symbol": "yd²"
        },
        "mi2": {
          "name": {
            "en": "Square miles",
            "fr": "Milles carrés"
          },
          "symbol": "mi²"
        }
      },
      "name": {
        "en": "Area",
        "fr": "Aire"
      }
    },
    "capacitance": {
      "formats": {
        "f": {
          "name": {
            "en": "Farads",
            "fr": "Farads"
          },
          "symbol": "F"
        }
      },
      "name": {
        "en": "Capacitance",
        "fr": "Capacitance"
      }
    },
    "catalytic-activity": {
      "formats": {
        "kat": {
          "name": {
            "en": "Katals",
            "fr": "Katals"
          },
          "symbol": "kat"
        }
      },
      "name": {
        "en": "Catalytic activity",
        "fr": "Activité catalytique"
      }
    },
    "data-quantity": {
      "formats": {
        "b": {
          "name": {
            "en": "Bytes",
            "fr": "Octets"
          },
          "symbol": "B"
        },
        "bits": {
          "name": {
            "en": "Bits",
            "fr": "Bits"
          },
          "symbol": "bit"
        },
        "gb": {
          "name": {
            "en": "Gigabytes",
            "fr": "Gigaoctets"
          },
          "symbol": "Gb"
        },
        "gbits": {
          "name": {
            "en": "Gigabits",
            "fr": "Gigabits"
          },
          "symbol": "Gbit"
        },
        "kb": {
          "name": {
            "en": "Kilobytes",
            "fr": "Kilooctets"
          },
          "symbol": "Kb"
        },
        "kbits": {
          "name": {
            "en": "Kilobits",
            "fr": "Kilobits"
          },
          "symbol": "Kbit"
        },
        "mb": {
          "name": {
            "en": "Megabytes",
            "fr": "Megaoctets"
          },
          "symbol": "Mb"
        },
        "mbits": {
          "name": {
            "en": "Megabits",
            "fr": "Megabits"
          },
          "symbol": "Mbit"
        },
        "tb": {
          "name": {
            "en": "Terabytes",
            "fr": "Teraoctets"
          },
          "symbol": "Tb"
        }
      },
      "name": {
        "en": "Data quantity",
        "fr": "Quantité de données"
      }
    },
    "density": {
      "formats": {
        "g-dl": {
          "name": {
            "en": "Grams/deciliter",
            "fr": "Grammes/décilitre"
          },
          "symbol": "g/dL"
        },
        "kg-m3": {
          "name": {
            "en": "Kilograms/cubic meter",
            "fr": "Kilogrammes/mètre cube"
          },
          "symbol": "kg/m³"
        },
        "mg-dl": {
          "name": {
            "en": "Milligrams/deciliter",
            "fr": "Milligrammes/décilitre"
          },
          "symbol": "mg/dL"
        },
        "mmol-l": {
          "name": {
            "en": "Millimoles/liter",
            "fr": "Millimoles/litre"
          },
          "symbol": "mmol/L"
        }
      },
      "name": {
        "en": "Density",
        "fr": "Densité"
      }
    },
    "dynamic-viscosity": {
      "formats": {
        "pa-s": {
          "name": {
            "en": "Pascals/second",
            "fr": "Pascals/seconde"
          },
          "symbol": "Pa/s"
        }
      },
      "name": {
        "en": "Dynamic viscosity",
        "fr": "Viscosité dynamique"
      }
    },
    "electric-charge": {
      "formats": {
        "c": {
          "name": {
            "en": "Coulombs",
            "fr": "Coulombs"
          },
          "symbol": "C"
        }
      },
      "name": {
        "en": "Electric charge",
        "fr": "Charge électrique"
      }
    },
    "electric-charge-line-density": {
      "formats": {
        "c-m": {
          "name": {
            "en": "Coulombs/meter",
            "fr": "Coulombs/mètre"
          },
          "symbol": "C/m"
        }
      },
      "name": {
        "en": "Electric charge line density",
        "fr": "Densité linéique de charge électrique"
      }
    },
    "electric-current": {
      "formats": {
        "a": {
          "name": {
            "en": "Amperes",
            "fr": "Ampères"
          },
          "symbol": "A"
        }
      },
      "name": {
        "en": "Electric current",
        "fr": "Courant électrique"
      }
    },
    "electrical-conductivity": {
      "formats": {
        "s": {
          "name": {
            "en": "Siemens",
            "fr": "Siemens"
          },
          "symbol": "S"
        }
      },
      "name": {
        "en": "Electrical conductivity",
        "fr": "Conductivité électrique"
      }
    },
    "electromotive-force": {
      "formats": {
        "v": {
          "name": {
            "en": "Volts",
            "fr": "Volts"
          },
          "symbol": "V"
        }
      },
      "name": {
        "en": "Electromotive force",
        "fr": "Force électromotrice"
      }
    },
    "energy": {
      "formats": {
        "btu": {
          "name": {
            "en": "British thermal units",
            "fr": "British thermal units"
          },
          "symbol": "BTU"
        },
        "cal": {
          "name": {
            "en": "Calories",
            "fr": "Calories"
          },
          "symbol": "cal"
        },
        "ev": {
          "name": {
            "en": "Electron-volts",
            "fr": "Électron-volts"
          },
          "symbol": "eV"
        },
        "erg": {
          "name": {
            "en": "Ergs",
            "fr": "Ergs"
          },
          "symbol": "Erg"
        },
        "ftlb": {
          "name": {
            "en": "Foot-pounds",
            "fr": "Pied-livres"
          },
          "symbol": "ft·lb"
        },
        "j": {
          "name": {
            "en": "Joules",
            "fr": "Joules"
          },
          "symbol": "J"
        },
        "kcal": {
          "name": {
            "en": "Kilogram-calories",
            "fr": "Kilocalories"
          },
          "symbol": "kg·cal"
        },
        "ws": {
          "name": {
            "en": "Watt-seconds",
            "fr": "Watt-secondes"
          },
          "symbol": "Ws"
        },
        "kwh": {
          "name": {
            "en": "Kilowatt-hours",
            "fr": "Kilowatt-heures"
          },
          "symbol": "kW·h"
        },
        "nm": {
          "name": {
            "en": "Newton-meters",
            "fr": "Newton-mètres"
          },
          "symbol": "N·m"
        },
        "wh": {
          "name": {
            "en": "Watt-hours",
            "fr": "Watt-heures"
          },
          "symbol": "W·h"
        }
      },
      "name": {
        "en": "Energy",
        "fr": "Energie"
      }
    },
    "force": {
      "formats": {
        "dyn": {
          "name": {
            "en": "Dynes",
            "fr": "Dynes"
          },
          "symbol": "dyn"
        },
        "n": {
          "name": {
            "en": "Newtons",
            "fr": "Newtons"
          },
          "symbol": "N"
        },
        "pdl": {
          "name": {
            "en": "Poundals",
            "fr": "Poundals"
          },
          "symbol": "Pdl"
        }
      },
      "name": {
        "en": "Force",
        "fr": "Force"
      }
    },
    "frequency": {
      "formats": {
        "rpm": {
          "name": {
            "en": "Revolutions per minute",
            "fr": "Rotations par minute"
          },
          "symbol": "rpm"
        },
        "hz": {
          "name": {
            "en": "Hertz",
            "fr": "Hertz"
          },
          "symbol": "Hz"
        },
        "bpm": {
          "name": {
            "en": "Beats per minute",
            "fr": "Battements par minute"
          },
          "symbol": "bpm"
        }
      },
      "name": {
        "en": "Frequency",
        "fr": "Fréquence"
      }
    },
    "luminous-intensity": {
      "formats": {
        "cd": {
          "name": {
            "en": "Candelas",
            "fr": "Candelas"
          },
          "symbol": "Cd"
        }
      },
      "name": {
        "en": "Luminous intensity",
        "fr": "Intensité lumineuse"
      }
    },
    "mol": {
      "formats": {
        "mol": {
          "name": {
            "en": "Moles",
            "fr": "Moles"
          },
          "symbol": "Mol"
        }
      },
      "name": {
        "en": "Amount of substance",
        "fr": "Quantité de matière"
      }
    },
    "power": {
      "formats": {
        "btu-min": {
          "name": {
            "en": "BTUs/minute",
            "fr": "BTUs/minute"
          },
          "symbol": "BTU/min"
        },
        "ftlb-s": {
          "name": {
            "en": "Foot-pounds/second",
            "fr": "Pied-livres/seconde"
          },
          "symbol": "ft·lb/s"
        },
        "hp": {
          "name": {
            "en": "Horsepower",
            "fr": "Chevaux"
          },
          "symbol": "hp"
        },
        "kw": {
          "name": {
            "en": "Kilowatts",
            "fr": "Kilowatts"
          },
          "symbol": "kW"
        },
        "w": {
          "name": {
            "en": "Watts",
            "fr": "Watts"
          },
          "symbol": "W"
        }
      },
      "name": {
        "en": "Power",
        "fr": "Puissance"
      }
    },
    "pressure": {
      "formats": {
        "at": {
          "name": {
            "en": "Atmospheres",
            "fr": "Atmosphères"
          },
          "symbol": "at"
        },
        "bar": {
          "name": {
            "en": "Bars",
            "fr": "Bars"
          },
          "symbol": "bar"
        },
        "cmhg": {
          "name": {
            "en": "Centimeters of mercury",
            "fr": "Centimètres de mercure"
          },
          "symbol": "cmHg"
        },
        "inhg": {
          "name": {
            "en": "Inches of mercury",
            "fr": "Pouces de mercure"
          },
          "symbol": "inHg"
        },
        "kg-m2": {
          "name": {
            "en": "Kilograms/square meter",
            "fr": "Kilogrammes/mètre cube"
          },
          "symbol": "kg/m²"
        },
        "mmhg": {
          "name": {
            "en": "Millimeters of mercury",
            "fr": "Millimètres de mercure"
          },
          "symbol": "mmHg"
        },
        "pa": {
          "name": {
            "en": "Pascals",
            "fr": "Pascals"
          },
          "symbol": "Pa"
        },
        "kpa": {
          "name": {
            "en": "Kilo Pascals",
            "fr": "Kilo Pascals"
          },
          "symbol": "kPa"
        },
        "psf": {
          "name": {
            "en": "Pounds/square foot",
            "fr": "Livres/pied carré"
          },
          "symbol": "psf"
        },
        "psi": {
          "name": {
            "en": "Pounds/square inch",
            "fr": "Livres/pouce carré"
          },
          "symbol": "psi"
        }
      },
      "name": {
        "en": "Pressure",
        "fr": "Pression"
      }
    },
    "ratio": {
      "formats": {
        "percent": {
          "name": {
            "en": "Percentage",
            "fr": "Pourcentage"
          }
        }
      },
      "name": {
        "en": "Ratio",
        "fr": "Ratio"
      }
    },
    "speed": {
      "formats": {
        "ft-m": {
          "name": {
            "en": "Feet/minute",
            "fr": "Pieds/minute"
          },
          "symbol": "ft/m"
        },
        "ft-s": {
          "name": {
            "en": "Feet/second",
            "fr": "Pieds/seconde"
          },
          "symbol": "ft/s"
        },
        "km-h": {
          "name": {
            "en": "Kilometers/hour",
            "fr": "Kilomètres/heure"
          },
          "symbol": "km/h"
        },
        "kt": {
          "name": {
            "en": "Knots",
            "fr": "Noeuds"
          },
          "symbol": "kt"
        },
        "m-min": {
          "name": {
            "en": "Miles/minute",
            "fr": "Miles/minute"
          },
          "symbol": "m/min"
        },
        "m-s": {
          "name": {
            "en": "Meters/second",
            "fr": "Mètres/seconde"
          },
          "symbol": "m/s"
        },
        "mph": {
          "name": {
            "en": "Miles/hour",
            "fr": "Miles/heure"
          },
          "symbol": "mph"
        }
      },
      "name": {
        "en": "Speed",
        "fr": "Vitesse"
      }
    },
    "volume": {
      "formats": {
        "c": {
          "name": {
            "en": "Cups",
            "fr": "Tasses"
          },
          "symbol": "c"
        },
        "cm3": {
          "name": {
            "en": "Cubic centimeters",
            "fr": "Centimètres cube"
          },
          "symbol": "cm³"
        },
        "floz": {
          "name": {
            "en": "Fluid ounces",
            "fr": "Onces liquides"
          },
          "symbol": "fl oz"
        },
        "ft3": {
          "name": {
            "en": "Cubic feet",
            "fr": "Pieds cube"
          },
          "symbol": "cu ft"
        },
        "galgb": {
          "name": {
            "en": "Gallons imperial",
            "fr": "Gallons impériaux"
          },
          "symbol": "gal GB"
        },
        "galus": {
          "name": {
            "en": "Gallons US",
            "fr": "Gallons US"
          },
          "symbol": "gal US"
        },
        "in3": {
          "name": {
            "en": "Cubic inches",
            "fr": "Pouce cube"
          },
          "symbol": "cu in"
        },
        "yd3": {
          "name": {
            "en": "Cubic yards",
            "fr": "Verges cube"
          },
          "symbol": "cu yd"
        },
        "l": {
          "name": {
            "en": "Liters",
            "fr": "Litres"
          },
          "symbol": "L"
        },
        "m3": {
          "name": {
            "en": "Cubic meters",
            "fr": "Mètres cube"
          },
          "symbol": "m³"
        },
        "ml": {
          "name": {
            "en": "Milliliters",
            "fr": "Millilitres"
          },
          "symbol": "mL"
        },
        "pt": {
          "name": {
            "en": "Pints",
            "fr": "Pintes"
          },
          "symbol": "pt"
        },
        "qt": {
          "name": {
            "en": "Quarts",
            "fr": "Quarts"
          },
          "symbol": "qt"
        },
        "bbloil": {
          "name": {
            "en": "Barrels (oil)",
            "fr": "Barils (pétrole)"
          },
          "symbol": "bbl (oil)"
        },
        "tbs": {
          "name": {
            "en": "Tablespoons",
            "fr": "Cuillères à soupe"
          },
          "symbol": "tbs"
        },
        "tsp": {
          "name": {
            "en": "Teaspoons",
            "fr": "Cuillères à café"
          },
          "symbol": "tsp"
        }
      },
      "name": {
        "en": "Volume",
        "fr": "Volume"
      }
    },
    "time": {
      "formats": {
        "d": {
          "name": {
            "en": "Days",
            "fr": "Jours"
          },
          "symbol": "d"
        },
        "h": {
          "name": {
            "en": "Hours",
            "fr": "Heures"
          },
          "symbol": "h"
        },
        "min": {
          "name": {
            "en": "Minutes",
            "fr": "Minutes"
          },
          "symbol": "min"
        },
        "ms": {
          "name": {
            "en": "Milliseconds",
            "fr": "Millisecondes"
          },
          "symbol": "ms"
        },
        "s": {
          "name": {
            "en": "Seconds",
            "fr": "Secondes"
          },
          "symbol": "s"
        },
        "y": {
          "name": {
            "en": "Years (Julian)",
            "fr": "Années (juliennes)"
          },
          "symbol": "yr"
        }
      },
      "name": {
        "en": "Time",
        "fr": "Temps"
      }
    }
  }
}
},{}],47:[function(require,module,exports){
module.exports={
  "version": "0.2.9",
  "classes": {
    "activity": {
      "description": "The time spent on a given activity (tasks, sports, etc.).",
      "formats": {
        "plain": {
          "description": "Plain activity event with no specific content; the activity is defined by the event's stream, time and duration, and possibly description and tags.",
          "type": "null"
        }
      }
    },
    "audio": {
      "description": "To record audio (conversations, voice messages, etc.).",
      "formats": {
        "attached": {
          "description": "The audio source is the file attached to the event (no explicit content defined).\nYou can use the event's duration to mirror the recording's duration.",
          "type": "null",
          "attachmentRequired": true
        },
        "url": {
          "description": "A reference to an audio file online.",
          "type": "string",
          "pattern": "^(https?)://.+$"
        }
      }
    },
    "call": {
      "description": "To record references to phone calls (landline, mobile, Skype, etc.).",
      "formats": {
        "name": {
          "description": "The contact's name (or a free-form identifier)",
          "type": "string"
        },
        "skype": {
          "description": "The Skype id",
          "type": "string"
        },
        "telephone": {
          "description": "The phone number",
          "type": "string"
        }
      }
    },
    "contact": {
      "description": "To record events related to people (meeting someone special, business encounters, etc.).",
      "formats": {
        "facebook": {
          "type": "object",
          "description": "A Facebook user as specified in the Graph API: https://developers.facebook.com/docs/reference/api/user/",
          "additionalProperties": "true",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        },
        "vcard": {
          "description": "A business card in vCard 2.0-3.x format. See: rfc2425, rfc2426.",
          "type": "string"
        }
      }
    },
    "encrypted": {
      "description": "For client-side-encrypted events. The decrypted <code>payload</code> is expected to be a JSON object with the regular <code>type</code> and <code>content</code> properties (e.g. <code>{ \"type\": \"..\", \"content\": \"..\" }</code>). If the event has attached files, they are expected to be similarly encrypted.",
      "formats": {
        "aes-text-base64": {
          "description": "AES encrypted payload, with a <em>text</em> key and a <em>Base64</em> payload.",
          "type": "object",
          "properties": {
            "payload": {
              "description": "The encrypted data.",
              "type": "string"
            },
            "keyRef": {
              "description": "A reference (e.g. id, name in keychain) to the key to use for decryption.",
              "type": "string"
            },
            "hint": {
              "description": "Alternative to <code>keyRef</code>. A textual hint about which key to use for decryption.",
              "type": "string"
            }
          },
          "required": [
            "payload"
          ]
        }
      }
    },
    "file": {
      "description": "To record a file, or a group of files. A fallback type for data with no specific handling in Pryv.",
      "formats": {
        "attached": {
          "description": "The file is attached to the event",
          "type": "null",
          "attachmentRequired": true
        },
        "attached-multiple": {
          "description": "A set of file attached. Structure can be declared in the filenames.",
          "attachmentRequired": true,
          "type": "null"
        },
        "url": {
          "description": "A reference to a file hosted elsewhere",
          "type": "string",
          "pattern": "^(https?)://.+$"
        }
      }
    },
    "message": {
      "description": "To record messages, such as e-mails or posts on social networks.",
      "formats": {
        "email": {
          "description": "An e-mail message.",
          "type": "object",
          "properties": {
            "from": {
              "type": "string"
            },
            "to": {
              "type": "string"
            },
            "cc": {
              "type": "string"
            },
            "bcc": {
              "type": "string"
            },
            "subject": {
              "type": "string"
            },
            "message-id": {
              "type": "string"
            },
            "reply-to": {
              "type": "string"
            },
            "x-headers": {
              "description": "Key/value map of `X-*` headers",
              "type": "object",
              "additionalProperties": true
            },
            "body": {
              "type": "string"
            }
          },
          "required": [
            "from",
            "to",
            "body"
          ]
        },
        "facebook": {
          "description": "A Facebook post. See [Facebook's API docs](https://developers.facebook.com/docs/reference/api/post/) for reference. Facebook properties `message` and `created_time` map to event `description` and `time` respectively. Facebook attached pictures can be directly mapped to attachments. Other Facebook properties such as `link`, `source`, `privacy` are allowed.",
          "type": "object",
          "additionalProperties": true,
          "properties": {
            "id": {
              "type": "string"
            },
            "from": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                },
                "id": {
                  "type": "string"
                }
              },
              "required": [
                "name",
                "id"
              ]
            },
            "to": {
              "type": "object",
              "properties": {
                "data": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "id": {
                        "type": "string"
                      }
                    },
                    "required": [
                      "name",
                      "id"
                    ]
                  }
                }
              }
            },
            "message": {
              "type": "string"
            },
            "source": {
              "type": "string",
              "description": "Either a fully qualified \"URL\" for an external source or a \"filename\" for a Flash Movie or Video attached to this event."
            },
            "properties": {
              "type": "string",
              "description": "Relative to `source`: a list of properties for an uploaded video, for example, the length of the video.",
              "additionalProperties": true
            },
            "picture": {
              "description": "Either a fully qualified \"URL\" for an external picture or a \"filename\" for a picture attached to this event.",
              "type": "string"
            },
            "status-type": {
              "description": "One of mobile_status_update, created_note, added_photos, added_video, shared_story, created_group, created_event, wall_post, app_created_story, published_story, tagged_in_photo, approved_friend",
              "type": "string"
            }
          },
          "required": [
            "id",
            "message"
          ]
        },
        "twitter": {
          "description": "A Twitter post. Twitter property `created_at` maps to event `time`. Other Twitter properties (see [Twitter's API docs](https://dev.twitter.com/docs/api/1.1/get/statuses/show/%3Aid)) are allowed.",
          "type": "object",
          "additionalProperties": true,
          "properties": {
            "id": {
              "type": "string"
            },
            "screen-name": {
              "type": "string"
            },
            "text": {
              "type": "string"
            }
          },
          "required": [
            "id",
            "screen-name",
            "text"
          ]
        }
      }
    },
    "money": {
      "description": "To record sums of money (expenses, loans, stock values, etc.). Format = currency. Based on ISO 4217.",
      "formats": {
        "aed": {
          "type": "number"
        },
        "ang": {
          "type": "number",
          "description": "Netherlands Antilles Guilder"
        },
        "ars": {
          "type": "number",
          "description": "Argentina Peso"
        },
        "aud": {
          "type": "number",
          "description": "Australia Dollar"
        },
        "bgn": {
          "type": "number",
          "description": "Bulgaria Lev"
        },
        "bhd": {
          "type": "number"
        },
        "bnd": {
          "type": "number",
          "description": "Brunei Darussalam Dollar"
        },
        "bob": {
          "type": "number",
          "description": "Bolivia Boliviano"
        },
        "brl": {
          "type": "number",
          "description": "Brazil Real"
        },
        "bwp": {
          "type": "number",
          "description": "Botswana Pula"
        },
        "cad": {
          "type": "number",
          "description": "Canada Dollar"
        },
        "chf": {
          "type": "number",
          "description": "Switzerland Franc"
        },
        "clp": {
          "type": "number",
          "description": "Chile Peso"
        },
        "cny": {
          "type": "number",
          "description": "China Yuan Renminbi"
        },
        "cop": {
          "type": "number",
          "description": "Colombia Peso"
        },
        "crc": {
          "type": "number",
          "description": "Costa Rica Colon"
        },
        "czk": {
          "type": "number",
          "description": "Czech Republic Koruna"
        },
        "dkk": {
          "type": "number",
          "description": "Denmark Krone"
        },
        "dop": {
          "type": "number",
          "description": "Dominican Republic Peso"
        },
        "dzd": {
          "type": "number"
        },
        "eek": {
          "type": "number",
          "description": "Estonia Kroon"
        },
        "egp": {
          "type": "number",
          "description": "Egypt Pound"
        },
        "eur": {
          "type": "number",
          "description": "Euro"
        },
        "fjd": {
          "type": "number",
          "description": "Fiji Dollar"
        },
        "gbp": {
          "type": "number",
          "description": "United Kingdom Pound"
        },
        "hkd": {
          "type": "number",
          "description": "Hong Kong Dollar"
        },
        "hnl": {
          "type": "number",
          "description": "Honduras Lempira"
        },
        "hrk": {
          "type": "number",
          "description": "Croatia Kuna"
        },
        "huf": {
          "type": "number",
          "description": "Hungary Forint"
        },
        "idr": {
          "type": "number",
          "description": "Indonesia Rupiah"
        },
        "ils": {
          "type": "number",
          "description": "Israel Shekel"
        },
        "inr": {
          "type": "number",
          "description": "India Rupee"
        },
        "jmd": {
          "type": "number",
          "description": "Jamaica Dollar"
        },
        "jod": {
          "type": "number"
        },
        "jpy": {
          "type": "number",
          "description": "Japan Yen"
        },
        "kes": {
          "type": "number"
        },
        "krw": {
          "type": "number",
          "description": "Korea (South) Won"
        },
        "kwd": {
          "type": "number"
        },
        "kyd": {
          "type": "number",
          "description": "Cayman Islands Dollar"
        },
        "kzt": {
          "type": "number",
          "description": "Kazakhstan Tenge"
        },
        "lbp": {
          "type": "number",
          "description": "Lebanon Pound"
        },
        "lkr": {
          "type": "number",
          "description": "Sri Lanka Rupee"
        },
        "ltl": {
          "type": "number",
          "description": "Lithuania Litas"
        },
        "lvl": {
          "type": "number",
          "description": "Latvia Lat"
        },
        "mad": {
          "type": "number"
        },
        "mdl": {
          "type": "number"
        },
        "mkd": {
          "type": "number",
          "description": "Macedonia Denar"
        },
        "mur": {
          "type": "number",
          "description": "Mauritius Rupee"
        },
        "mxn": {
          "type": "number",
          "description": "Mexico Peso"
        },
        "myr": {
          "type": "number",
          "description": "Malaysia Ringgit"
        },
        "nad": {
          "type": "number",
          "description": "Namibia Dollar"
        },
        "ngn": {
          "type": "number",
          "description": "Nigeria Naira"
        },
        "nio": {
          "type": "number",
          "description": "Nicaragua Cordoba"
        },
        "nok": {
          "type": "number",
          "description": "Norway Krone"
        },
        "npr": {
          "type": "number",
          "description": "Nepal Rupee"
        },
        "nzd": {
          "type": "number",
          "description": "New Zealand Dollar"
        },
        "omr": {
          "type": "number",
          "description": "Oman Rial"
        },
        "pen": {
          "type": "number",
          "description": "Peru Nuevo Sol"
        },
        "pgk": {
          "type": "number"
        },
        "php": {
          "type": "number",
          "description": "Philippines Peso"
        },
        "pkr": {
          "type": "number",
          "description": "Pakistan Rupee"
        },
        "pln": {
          "type": "number",
          "description": "Poland Zloty"
        },
        "pyg": {
          "type": "number",
          "description": "Paraguay Guarani"
        },
        "qar": {
          "type": "number",
          "description": "Qatar Riyal"
        },
        "ron": {
          "type": "number",
          "description": "Romania New Leu"
        },
        "rsd": {
          "type": "number",
          "description": "Serbia Dinar"
        },
        "rub": {
          "type": "number",
          "description": "Russia Ruble"
        },
        "sar": {
          "type": "number",
          "description": "Saudi Arabia Riyal"
        },
        "scr": {
          "type": "number",
          "description": "Seychelles Rupee"
        },
        "sek": {
          "type": "number",
          "description": "Sweden Krona"
        },
        "sgd": {
          "type": "number",
          "description": "Singapore Dollar"
        },
        "skk": {
          "type": "number"
        },
        "sll": {
          "type": "number"
        },
        "svc": {
          "type": "number",
          "description": "El Salvador Colon"
        },
        "thb": {
          "type": "number",
          "description": "Thailand Baht"
        },
        "tnd": {
          "type": "number"
        },
        "try": {
          "type": "number",
          "description": "Turkey Lira"
        },
        "ttd": {
          "type": "number",
          "description": "Trinidad and Tobago Dollar"
        },
        "twd": {
          "type": "number",
          "description": "Taiwan New Dollar"
        },
        "tzs": {
          "type": "number"
        },
        "uah": {
          "type": "number",
          "description": "Ukraine Hryvna"
        },
        "ugx": {
          "type": "number"
        },
        "usd": {
          "type": "number",
          "description": "United States Dollar"
        },
        "uyu": {
          "type": "number",
          "description": "Uruguay Peso"
        },
        "uzs": {
          "type": "number",
          "description": "Uzbekistan Som"
        },
        "vnd": {
          "type": "number",
          "description": "Viet Nam Dong"
        },
        "yer": {
          "type": "number",
          "description": "Yemen Rial"
        },
        "zar": {
          "type": "number",
          "description": "South Africa Rand"
        },
        "zmk": {
          "type": "number"
        },
        "btc": {
          "description": "Bitcoin",
          "type": "number"
        },
        "all": {
          "description": "Albania Lek",
          "type": "number"
        },
        "afn": {
          "description": "Afghanistan Afghani",
          "type": "number"
        },
        "awg": {
          "description": "Aruba Guilder",
          "type": "number"
        },
        "azn": {
          "description": "Azerbaijan New Manat",
          "type": "number"
        },
        "bsd": {
          "description": "Bahamas Dollar",
          "type": "number"
        },
        "bbd": {
          "description": "Barbados Dollar",
          "type": "number"
        },
        "byr": {
          "description": "Belarus Ruble",
          "type": "number"
        },
        "bzd": {
          "description": "Belize Dollar",
          "type": "number"
        },
        "bmd": {
          "description": "Bermuda Dollar",
          "type": "number"
        },
        "bam": {
          "description": "Bosnia and Herzegovina Convertible Marka",
          "type": "number"
        },
        "khr": {
          "description": "Cambodia Riel",
          "type": "number"
        },
        "cup": {
          "description": "Cuba Peso",
          "type": "number"
        },
        "xcd": {
          "description": "East Caribbean Dollar",
          "type": "number"
        },
        "fkp": {
          "description": "Falkland Islands (Malvinas) Pound",
          "type": "number"
        },
        "ghc": {
          "description": "Ghana Cedis",
          "type": "number"
        },
        "gip": {
          "description": "Gibraltar Pound",
          "type": "number"
        },
        "gtq": {
          "description": "Guatemala Quetzal",
          "type": "number"
        },
        "ggp": {
          "description": "Guernsey Pound",
          "type": "number"
        },
        "gyd": {
          "description": "Guyana Dollar",
          "type": "number"
        },
        "isk": {
          "description": "Iceland Krona",
          "type": "number"
        },
        "irr": {
          "description": "Iran Rial",
          "type": "number"
        },
        "imp": {
          "description": "Isle of Man Pound",
          "type": "number"
        },
        "jep": {
          "description": "Jersey Pound",
          "type": "number"
        },
        "kpw": {
          "description": "Korea (North) Won",
          "type": "number"
        },
        "kgs": {
          "description": "Kyrgyzstan Som",
          "type": "number"
        },
        "lak": {
          "description": "Laos Kip",
          "type": "number"
        },
        "lrd": {
          "description": "Liberia Dollar",
          "type": "number"
        },
        "mnt": {
          "description": "Mongolia Tughrik",
          "type": "number"
        },
        "mzn": {
          "description": "Mozambique Metical",
          "type": "number"
        },
        "pab": {
          "description": "Panama Balboa",
          "type": "number"
        },
        "shp": {
          "description": "Saint Helena Pound",
          "type": "number"
        },
        "sbd": {
          "description": "Solomon Islands Dollar",
          "type": "number"
        },
        "sos": {
          "description": "Somalia Shilling",
          "type": "number"
        },
        "srd": {
          "description": "Suriname Dollar",
          "type": "number"
        },
        "syp": {
          "description": "Syria Pound",
          "type": "number"
        },
        "trl": {
          "description": "Turkey Lira",
          "type": "number"
        },
        "tvd": {
          "description": "Tuvalu Dollar",
          "type": "number"
        },
        "vef": {
          "description": "Venezuela Bolivar",
          "type": "number"
        },
        "zwd": {
          "description": "Zimbabwe Dollar",
          "type": "number"
        }
      }
    },
    "mood": {
      "description": "To record personal mood.",
      "formats": {
        "rating": {
          "description": "Rating of mood (float value) 0:worst -> 1:best",
          "type": "number",
          "minimum": 0,
          "maximum": 1
        },
        "emoticon": {
          "description": "ASCII Art emoticon",
          "type": "string"
        }
      }
    },
    "music": {
      "description": "To record references to music, usualy tracks (from Soundcloud, Shazam tags, etc.).",
      "formats": {
        "basic": {
          "description": "Inspired from id3 key/pair",
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "artist": {
              "type": "string"
            },
            "album": {
              "type": "string"
            },
            "track": {
              "type": "integer"
            },
            "year": {
              "type": "integer"
            },
            "genre": {
              "type": "string"
            }
          }
        },
        "soundcloud": {
          "description": "See [Soundcloud track properties](http://developers.soundcloud.com/docs/api/reference#tracks).",
          "type": "object",
          "additionalProperties": true,
          "properties": {
            "id": {
              "type": "integer"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    },
    "note": {
      "description": "To record different kinds of text-based notes, from simple text to more complex formatted content like social network posts.",
      "formats": {
        "html": {
          "description": "An HTML-formatted note.",
          "type": "string",
          "maxLength": 4194304
        },
        "txt": {
          "description": "A plain-text note.",
          "type": "string",
          "maxLength": 4194304
        },
        "webclip": {
          "description": "An HTML-formatted note associated to its source URL.",
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "pattern": "^(https?)://.+$"
            },
            "content": {
              "description": "An HTML-formatted string.",
              "type": "string",
              "maxLength": 4194304
            }
          },
          "required": [
            "url"
          ]
        }
      }
    },
    "numset": {
      "description": "A set of numerical values.",
      "formats": {
        "*": {
          "description": "The format key is freely defined.\n\nFor example, a heart measurement with type `numset/heart` and content:\n```\n{Â \n  \"systolic\": { \"pressure/mmhg\": 105 },\n  \"diastolic\": { \"pressure/mmhg\": 64 },\n  \"rate\": { \"frequency/bpm\": 88 }\n}\n```\n\n ",
          "type": "object",
          "patternProperties": {
            "^(/[^/]+)+$": {
              "type": "number"
            }
          },
          "additionalProperties": "false",
          "required": []
        }
      }
    },
    "picture": {
      "description": "To record any kind of image (photos, designs, screenshots, etc.)",
      "formats": {
        "base64": {
          "description": "The picture is caried in base64 (utf-8) encoded in string",
          "type": "string",
          "properties": {
            "payload": {
              "type": "string",
              "description": "base64 encoded content"
            },
            "format": {
              "type": "string",
              "description": "The data format \"gif\", \"jpeg\", \"png\", \"tiff\", \"vnd.microsoft.com\", \"svg+xml\""
            },
            "filename": {
              "description": "A filename",
              "type": "string"
            }
          },
          "required": [
            "payload",
            "format"
          ]
        },
        "attached": {
          "description": "The picture is the image file attached to the event (no explicit content defined). TODO: list accepted formats.",
          "type": "null",
          "attachmentRequired": true
        },
        "url": {
          "description": "A reference to a picture file online.",
          "type": "string",
          "pattern": "^(https?)://.+$"
        }
      }
    },
    "position": {
      "description": "To record a geographical position.",
      "formats": {
        "wgs84": {
          "description": "The latest revision of the World Geodetic System (used by GPS).",
          "type": "object",
          "properties": {
            "latitude": {
              "type": "number",
              "description": "Unit: degrees north from the equator."
            },
            "longitude": {
              "type": "number",
              "description": "Unit: degrees east from the zero meridian."
            },
            "altitude": {
              "type": "number",
              "description": "Unit: meters above sea level."
            },
            "horizontalAccuracy": {
              "type": "number",
              "description": "The radius of uncertainty for latitude and longitude. Unit: meters. Negative if latitude and longitude are invalid."
            },
            "verticalAccuracy": {
              "type": "number",
              "description": "The radius of uncertainty for altitude. Unit: meters. Negative if altitude is invalid."
            },
            "speed": {
              "type": "number",
              "description": "For informational purposes only. Unit: meters / second. Negative if invalid."
            },
            "bearing": {
              "type": "number",
              "description": "Unit: degrees clockwise from north. Negative if invalid."
            }
          },
          "required": [
            "latitude",
            "longitude"
          ]
        }
      }
    },
    "ratio": {
      "description": "To record proportional values (e.g. 1/3, 21.5/100).",
      "formats": {
        "generic": {
          "description": "Generic ratio.",
          "type": "object",
          "properties": {
            "value": {
              "type": "number"
            },
            "relativeTo": {
              "type": "number"
            }
          },
          "required": [
            "value",
            "relativeTo"
          ]
        },
        "percent": {
          "description": "A percentage value.",
          "type": "number"
        }
      }
    },
    "url": {
      "description": "To record references to online resources. Format ~= protocol.",
      "formats": {
        "http": {
          "description": "An HTTP or HTTPS resource.",
          "type": "string",
          "pattern": "^(https?)://.+$"
        }
      }
    },
    "video": {
      "description": "To record video (home snippets, Vimeo or YouTube links, etc.).",
      "formats": {
        "attached": {
          "description": "The video is the file attached to the event (no explicit content defined). TODO: list accepted formats.",
          "type": "null",
          "attachmentRequired": true
        },
        "url": {
          "description": "A reference to an video file online.",
          "type": "string",
          "pattern": "^(https?)://.+$"
        },
        "vimeo": {
          "description": "A Vimeo video ID.",
          "type": "string"
        },
        "youtube": {
          "description": "A YouTube video ID.",
          "type": "string"
        }
      }
    },
    "absorbed-dose": {
      "formats": {
        "gy": {
          "description": "Gray",
          "type": "number"
        }
      },
      "description": "The energy deposited in a medium by ionizing radiation per unit mass."
    },
    "absorbed-dose-equivalent": {
      "formats": {
        "sv": {
          "description": "Sievert",
          "type": "number"
        }
      },
      "description": "TheÂ radiationÂ absorbed by a fixed mass of biological tissue."
    },
    "absorbed-dose-rate": {
      "formats": {
        "gy-s": {
          "description": "Gray per second",
          "type": "number"
        }
      },
      "description": "The absorbed dose of ionizing radiation imparted at a given location per unit of time (second, minute, hour, or day). "
    },
    "angle": {
      "formats": {
        "deg": {
          "description": "Degrees",
          "type": "number"
        },
        "grad": {
          "description": "Grade",
          "type": "number"
        },
        "rad": {
          "description": "Radians",
          "type": "number"
        }
      },
      "description": "The figure formed by two rays."
    },
    "angular-acceleration": {
      "formats": {
        "rad-s2": {
          "description": "Radians per second squared",
          "type": "number"
        }
      },
      "description": "The rate of change ofÂ angular velocity."
    },
    "angular-speed": {
      "formats": {
        "rad-s": {
          "description": "Radians per second",
          "type": "number"
        }
      },
      "description": ""
    },
    "area": {
      "formats": {
        "ac": {
          "description": "Acres (imperial)",
          "type": "number"
        },
        "ft2": {
          "description": "Square feet",
          "type": "number"
        },
        "ha": {
          "description": "Hectares",
          "type": "number"
        },
        "in2": {
          "description": "Square inches",
          "type": "number"
        },
        "km2": {
          "description": "Square kilometers",
          "type": "number"
        },
        "m2": {
          "description": "Square meter",
          "type": "number"
        },
        "mm2": {
          "description": "Square millimeters",
          "type": "number"
        },
        "yd2": {
          "description": "Square yards",
          "type": "number"
        },
        "mi2": {
          "description": "Square miles",
          "type": "number"
        }
      },
      "description": "The extent of a two-dimensional surface or shape, or planar lamina, in the plane."
    },
    "capacitance": {
      "formats": {
        "f": {
          "description": "Farad",
          "type": "number"
        }
      },
      "description": "The ability of a body to store an electricalÂ charge."
    },
    "catalytic-activity": {
      "formats": {
        "kat": {
          "description": "Katal",
          "type": "number"
        }
      },
      "description": "The  increase inÂ rateÂ of aÂ chemical reactionÂ due to the participation of a substance called aÂ catalyst."
    },
    "count": {
      "description": "To record the counting of objects (eggs, apples, etc.).",
      "formats": {
        "steps": {
          "description": "Number of steps",
          "type": "number"
        },
        "generic": {
          "description": "For general items that demand no particular handling.",
          "type": "number"
        }
      }
    },
    "data-quantity": {
      "formats": {
        "b": {
          "description": "Bytes",
          "type": "number"
        },
        "bits": {
          "description": "Bits",
          "type": "number"
        },
        "gb": {
          "description": "Gigabytes",
          "type": "number"
        },
        "gbits": {
          "description": "Gigabits",
          "type": "number"
        },
        "kb": {
          "description": "Kilobytes",
          "type": "number"
        },
        "kbits": {
          "description": "Kilobits",
          "type": "number"
        },
        "mb": {
          "description": "Megabytes",
          "type": "number"
        },
        "mbits": {
          "description": "Megabits",
          "type": "number"
        },
        "tb": {
          "description": "Terabytes",
          "type": "number"
        }
      },
      "description": "UnitÂ ofÂ informationÂ inÂ computingÂ and digitalÂ communications."
    },
    "density": {
      "formats": {
        "g-dl": {
          "description": "Grams per deciliter",
          "type": "number"
        },
        "kg-m3": {
          "description": "Kilograms per cubic meter",
          "type": "number"
        },
        "mmol-l": {
          "description": "Millimoles per liter",
          "type": "number"
        },
        "mg-dl": {
          "description": "Milligrams per deciliter",
          "type": "number"
        }
      },
      "description": "The densityÂ of a material (volumetric mass density)."
    },
    "dynamic-viscosity": {
      "formats": {
        "pa-s": {
          "description": "Pascal second",
          "type": "number"
        }
      },
      "description": "The resistance to flow of a fluid under an applied force."
    },
    "electric-charge": {
      "formats": {
        "c": {
          "description": "Coulomb ",
          "type": "number"
        }
      },
      "description": "The electric charge of an object."
    },
    "electric-charge-line-density": {
      "formats": {
        "c-m": {
          "description": "Coulomb per meter",
          "type": "number"
        }
      },
      "description": "The electric chargeÂ per unitÂ volumeÂ of space, in one, two or three dimensions."
    },
    "electric-current": {
      "formats": {
        "a": {
          "description": "Ampere",
          "type": "number"
        }
      },
      "description": "A flow ofÂ electric charge."
    },
    "electrical-conductivity": {
      "formats": {
        "s": {
          "description": "Siemens",
          "type": "number"
        }
      },
      "description": "A material that accommodates the transport of electric charge."
    },
    "electromotive-force": {
      "formats": {
        "v": {
          "description": "Volt",
          "type": "number"
        }
      },
      "description": "Voltage generated by a battery or by the magnetic force."
    },
    "energy": {
      "formats": {
        "btu": {
          "description": "British Thermal Units",
          "type": "number"
        },
        "cal": {
          "description": "Calories",
          "type": "number"
        },
        "ev": {
          "description": "Electron-Volts",
          "type": "number"
        },
        "erg": {
          "description": "Ergs",
          "type": "number"
        },
        "ftlb": {
          "description": "Foot-Pounds",
          "type": "number"
        },
        "j": {
          "description": "Joules",
          "type": "number"
        },
        "kcal": {
          "description": "Kilo-calories",
          "type": "number"
        },
        "ws": {
          "description": "Watt-seconds",
          "type": "number"
        },
        "kwh": {
          "description": "Kilowatt-hours",
          "type": "number"
        },
        "nm": {
          "description": "Newton-meters",
          "type": "number"
        },
        "wh": {
          "description": "Watt-hours",
          "type": "number"
        }
      },
      "description": "The capacity of a physical system to perform work."
    },
    "force": {
      "formats": {
        "dyn": {
          "description": "Dynes",
          "type": "number"
        },
        "n": {
          "description": "Newtons",
          "type": "number"
        },
        "pdl": {
          "description": "Poundals",
          "type": "number"
        }
      },
      "description": "A push or pull upon an object resulting from the object'sÂ interactionÂ with another object."
    },
    "frequency": {
      "description": "The number of occurrences of a repeating event per unit time.",
      "formats": {
        "bpm": {
          "description": "Beats per minute",
          "type": "number"
        },
        "ghz": {
          "description": "Gigahertz",
          "type": "number"
        },
        "hz": {
          "description": "Hertz (also known as cycles per second) ",
          "type": "number"
        },
        "khz": {
          "description": "Kilohertz",
          "type": "number"
        },
        "megahz": {
          "description": "Megahertz",
          "type": "number"
        },
        "millihz": {
          "description": "Millihertz",
          "type": "number"
        },
        "nhz": {
          "description": "Nanohertz",
          "type": "number"
        },
        "rpm": {
          "description": "Revolutions per minute",
          "type": "number"
        },
        "thz": {
          "description": "Terahertz",
          "type": "number"
        },
        "uhz": {
          "description": "Microhertz",
          "type": "number"
        }
      }
    },
    "length": {
      "description": "Length measurements. Format = unit.",
      "formats": {
        "cm": {
          "description": "Centimeters",
          "type": "number"
        },
        "m": {
          "description": "Meters",
          "type": "number"
        },
        "mm": {
          "description": "Millimeters",
          "type": "number"
        },
        "km": {
          "description": "Kilometers",
          "type": "number"
        },
        "a": {
          "description": "Ã…ngstrÃ¶ms",
          "type": "number"
        },
        "au": {
          "description": "Astronomical units",
          "type": "number"
        },
        "ch": {
          "description": "Chains",
          "type": "number"
        },
        "lea": {
          "description": "Leagues",
          "type": "number"
        },
        "ft": {
          "description": "Feet",
          "type": "number"
        },
        "in": {
          "description": "Inches",
          "type": "number"
        },
        "ly": {
          "description": "Light-years",
          "type": "number"
        },
        "mil": {
          "description": "Mil",
          "type": "number"
        },
        "mi": {
          "description": "Miles",
          "type": "number"
        },
        "fur": {
          "description": "Furlongs",
          "type": "number"
        },
        "nmi": {
          "description": "Miles (nautical)",
          "type": "number"
        },
        "p": {
          "description": "Points",
          "type": "number"
        },
        "pica": {
          "description": "Picas",
          "type": "number"
        },
        "ftm": {
          "description": "Fathoms",
          "type": "number"
        },
        "cb": {
          "description": "Cables",
          "type": "number"
        },
        "um": {
          "description": "Microns",
          "type": "number"
        },
        "yd": {
          "description": "Yards",
          "type": "number"
        }
      }
    },
    "luminous-intensity": {
      "formats": {
        "cd": {
          "description": "Candela",
          "type": "number"
        }
      },
      "description": "TheÂ wavelength-weightedÂ powerÂ emitted by aÂ light source."
    },
    "mass": {
      "description": "The heaviness of an object.",
      "formats": {
        "kg": {
          "description": "Kilograms",
          "type": "number"
        },
        "gr": {
          "description": "Grains",
          "type": "number"
        },
        "dr": {
          "description": "Drams",
          "type": "number"
        },
        "g": {
          "description": "Grams",
          "type": "number"
        },
        "l-t": {
          "description": "Long tons",
          "type": "number"
        },
        "lb": {
          "description": "Pounds",
          "type": "number"
        },
        "t": {
          "description": "Metric tons",
          "type": "number"
        },
        "oz": {
          "description": "Ounces",
          "type": "number"
        },
        "s-t": {
          "description": "Short tons",
          "type": "number"
        },
        "st": {
          "description": "Stone",
          "type": "number"
        }
      }
    },
    "mol": {
      "description": "The size of an ensemble of elementary entities, such as atoms, molecules, electrons, andÂ other particles.",
      "formats": {
        "mol": {
          "description": "Mole ",
          "type": "number"
        },
        "lb-mol": {
          "description": "Pound-mole.",
          "type": "number"
        }
      }
    },
    "power": {
      "formats": {
        "btu-min": {
          "description": "BTUs/minute",
          "type": "number"
        },
        "ftlb-s": {
          "description": "Foot-pounds/second",
          "type": "number"
        },
        "hp": {
          "description": "Horsepower",
          "type": "number"
        },
        "kw": {
          "description": "Kilowatts",
          "type": "number"
        },
        "w": {
          "description": "Watts",
          "type": "number"
        }
      },
      "description": "The rate at whichÂ energyÂ is transferred, used, or transformed."
    },
    "pressure": {
      "formats": {
        "at": {
          "description": "Atmospheres",
          "type": "number"
        },
        "bar": {
          "description": "Bars",
          "type": "number"
        },
        "mmhg": {
          "description": "Millimeters of mercury",
          "type": "number"
        },
        "cmhg": {
          "description": "Centimeters of mercury",
          "type": "number"
        },
        "inhg": {
          "description": "Inches of mercury",
          "type": "number"
        },
        "kg-m2": {
          "description": "Kilograms/square meter",
          "type": "number"
        },
        "pa": {
          "description": "Pascals",
          "type": "number"
        },
        "kpa": {
          "description": "Kilo pascals",
          "type": "number"
        },
        "psf": {
          "description": "Pounds/square foot",
          "type": "number"
        },
        "psi": {
          "description": "Pounds/square inch",
          "type": "number"
        }
      },
      "description": "The ratio of force to the area over which that force is distributed."
    },
    "speed": {
      "formats": {
        "ft-m": {
          "description": "Feet/minute",
          "type": "number"
        },
        "ft-s": {
          "description": "Feet/second",
          "type": "number"
        },
        "km-h": {
          "description": "Kilometers/hour",
          "type": "number"
        },
        "kt": {
          "description": "Knots",
          "type": "number"
        },
        "m-min": {
          "description": "Miles/minute",
          "type": "number"
        },
        "m-s": {
          "description": "Meters/second",
          "type": "number"
        },
        "mph": {
          "description": "Miles/hour",
          "type": "number"
        }
      },
      "description": "TheÂ magnitudeÂ of theÂ velocityÂ of an object."
    },
    "temperature": {
      "description": "Temperature measurements. Format = unit.",
      "formats": {
        "c": {
          "description": "Celsius",
          "type": "number"
        },
        "k": {
          "description": "Kelvin",
          "type": "number"
        },
        "f": {
          "description": "Fahrenheit",
          "type": "number"
        }
      }
    },
    "time": {
      "description": "Amount of time. Use with care! To store an activity or duration the \"activity/plain\" event type is more appropriate, in most cases.",
      "formats": {
        "d": {
          "description": "Days",
          "type": "number"
        },
        "h": {
          "description": "Hours",
          "type": "number"
        },
        "min": {
          "description": "Minutes",
          "type": "number"
        },
        "ms": {
          "description": "Milliseconds",
          "type": "number"
        },
        "s": {
          "description": "Seconds",
          "type": "number"
        },
        "y": {
          "description": "Years",
          "type": "number"
        }
      }
    },
    "volume": {
      "description": "The quantityÂ ofÂ three-dimensional spaceÂ enclosed by some closed boundary.",
      "formats": {
        "l": {
          "description": "Liters",
          "type": "number"
        },
        "m3": {
          "description": "Cubic meters",
          "type": "number"
        },
        "c": {
          "description": "Cups",
          "type": "number"
        },
        "cm3": {
          "description": "Cubic centimeters",
          "type": "number"
        },
        "floz": {
          "description": "Fluid ounces",
          "type": "number"
        },
        "ft3": {
          "description": "Cubic feet",
          "type": "number"
        },
        "galgb": {
          "description": "Gallons imperial",
          "type": "number"
        },
        "galus": {
          "description": "Gallons US",
          "type": "number"
        },
        "in3": {
          "description": "Cubic inches",
          "type": "number"
        },
        "yd3": {
          "description": "Cubic yard",
          "type": "number"
        },
        "ml": {
          "description": "Milliliters",
          "type": "number"
        },
        "pt": {
          "description": "Pints",
          "type": "number"
        },
        "qt": {
          "description": "Quarts",
          "type": "number"
        },
        "bbloil": {
          "description": "Barrels (oil)",
          "type": "number"
        },
        "tbs": {
          "description": "Tablespoons",
          "type": "number"
        },
        "tsp": {
          "description": "Teaspoons",
          "type": "number"
        }
      }
    }
  }
}
},{}],48:[function(require,module,exports){
module.exports=  {
  "version": "0.2.9",
  "types": {
    "activity/plain": {
      "description": "Plain activity event with no specific content; the activity is defined by the event's stream, time and duration, and possibly description and tags.",
      "type": "null"
    },
    "audio/attached": {
      "description": "The audio source is the file attached to the event (no explicit content defined).\nYou can use the event's duration to mirror the recording's duration.",
      "type": "null",
      "attachmentRequired": true
    },
    "audio/url": {
      "description": "A reference to an audio file online.",
      "type": "string",
      "pattern": "^(https?)://.+$"
    },
    "call/name": {
      "description": "The contact's name (or a free-form identifier)",
      "type": "string"
    },
    "call/skype": {
      "description": "The Skype id",
      "type": "string"
    },
    "call/telephone": {
      "description": "The phone number",
      "type": "string"
    },
    "contact/facebook": {
      "type": "object",
      "description": "A Facebook user as specified in the Graph API: https://developers.facebook.com/docs/reference/api/user/",
      "additionalProperties": "true",
      "properties": {
        "id": {
          "type": "string"
        }
      },
      "required": [
        "id"
      ]
    },
    "contact/vcard": {
      "description": "A business card in vCard 2.0-3.x format. See: rfc2425, rfc2426.",
      "type": "string"
    },
    "encrypted/aes-text-base64": {
      "description": "AES encrypted payload, with a <em>text</em> key and a <em>Base64</em> payload.",
      "type": "object",
      "properties": {
        "payload": {
          "description": "The encrypted data.",
          "type": "string"
        },
        "keyRef": {
          "description": "A reference (e.g. id, name in keychain) to the key to use for decryption.",
          "type": "string"
        },
        "hint": {
          "description": "Alternative to <code>keyRef</code>. A textual hint about which key to use for decryption.",
          "type": "string"
        }
      },
      "required": [
        "payload"
      ]
    },
    "file/attached": {
      "description": "The file is attached to the event",
      "type": "null",
      "attachmentRequired": true
    },
    "file/attached-multiple": {
      "description": "A set of file attached. Structure can be declared in the filenames.",
      "attachmentRequired": true,
      "type": "null"
    },
    "file/url": {
      "description": "A reference to a file hosted elsewhere",
      "type": "string",
      "pattern": "^(https?)://.+$"
    },
    "message/email": {
      "description": "An e-mail message.",
      "type": "object",
      "properties": {
        "from": {
          "type": "string"
        },
        "to": {
          "type": "string"
        },
        "cc": {
          "type": "string"
        },
        "bcc": {
          "type": "string"
        },
        "subject": {
          "type": "string"
        },
        "message-id": {
          "type": "string"
        },
        "reply-to": {
          "type": "string"
        },
        "x-headers": {
          "description": "Key/value map of `X-*` headers",
          "type": "object",
          "additionalProperties": true
        },
        "body": {
          "type": "string"
        }
      },
      "required": [
        "from",
        "to",
        "body"
      ]
    },
    "message/facebook": {
      "description": "A Facebook post. See [Facebook's API docs](https://developers.facebook.com/docs/reference/api/post/) for reference. Facebook properties `message` and `created_time` map to event `description` and `time` respectively. Facebook attached pictures can be directly mapped to attachments. Other Facebook properties such as `link`, `source`, `privacy` are allowed.",
      "type": "object",
      "additionalProperties": true,
      "properties": {
        "id": {
          "type": "string"
        },
        "from": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "id": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "id"
          ]
        },
        "to": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "id": {
                    "type": "string"
                  }
                },
                "required": [
                  "name",
                  "id"
                ]
              }
            }
          }
        },
        "message": {
          "type": "string"
        },
        "source": {
          "type": "string",
          "description": "Either a fully qualified \"URL\" for an external source or a \"filename\" for a Flash Movie or Video attached to this event."
        },
        "properties": {
          "type": "string",
          "description": "Relative to `source`: a list of properties for an uploaded video, for example, the length of the video.",
          "additionalProperties": true
        },
        "picture": {
          "description": "Either a fully qualified \"URL\" for an external picture or a \"filename\" for a picture attached to this event.",
          "type": "string"
        },
        "status-type": {
          "description": "One of mobile_status_update, created_note, added_photos, added_video, shared_story, created_group, created_event, wall_post, app_created_story, published_story, tagged_in_photo, approved_friend",
          "type": "string"
        }
      },
      "required": [
        "id",
        "message"
      ]
    },
    "message/twitter": {
      "description": "A Twitter post. Twitter property `created_at` maps to event `time`. Other Twitter properties (see [Twitter's API docs](https://dev.twitter.com/docs/api/1.1/get/statuses/show/%3Aid)) are allowed.",
      "type": "object",
      "additionalProperties": true,
      "properties": {
        "id": {
          "type": "string"
        },
        "screen-name": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "screen-name",
        "text"
      ]
    },
    "money/aed": {
      "type": "number"
    },
    "money/ang": {
      "type": "number",
      "description": "Netherlands Antilles Guilder"
    },
    "money/ars": {
      "type": "number",
      "description": "Argentina Peso"
    },
    "money/aud": {
      "type": "number",
      "description": "Australia Dollar"
    },
    "money/bgn": {
      "type": "number",
      "description": "Bulgaria Lev"
    },
    "money/bhd": {
      "type": "number"
    },
    "money/bnd": {
      "type": "number",
      "description": "Brunei Darussalam Dollar"
    },
    "money/bob": {
      "type": "number",
      "description": "Bolivia Boliviano"
    },
    "money/brl": {
      "type": "number",
      "description": "Brazil Real"
    },
    "money/bwp": {
      "type": "number",
      "description": "Botswana Pula"
    },
    "money/cad": {
      "type": "number",
      "description": "Canada Dollar"
    },
    "money/chf": {
      "type": "number",
      "description": "Switzerland Franc"
    },
    "money/clp": {
      "type": "number",
      "description": "Chile Peso"
    },
    "money/cny": {
      "type": "number",
      "description": "China Yuan Renminbi"
    },
    "money/cop": {
      "type": "number",
      "description": "Colombia Peso"
    },
    "money/crc": {
      "type": "number",
      "description": "Costa Rica Colon"
    },
    "money/czk": {
      "type": "number",
      "description": "Czech Republic Koruna"
    },
    "money/dkk": {
      "type": "number",
      "description": "Denmark Krone"
    },
    "money/dop": {
      "type": "number",
      "description": "Dominican Republic Peso"
    },
    "money/dzd": {
      "type": "number"
    },
    "money/eek": {
      "type": "number",
      "description": "Estonia Kroon"
    },
    "money/egp": {
      "type": "number",
      "description": "Egypt Pound"
    },
    "money/eur": {
      "type": "number",
      "description": "Euro"
    },
    "money/fjd": {
      "type": "number",
      "description": "Fiji Dollar"
    },
    "money/gbp": {
      "type": "number",
      "description": "United Kingdom Pound"
    },
    "money/hkd": {
      "type": "number",
      "description": "Hong Kong Dollar"
    },
    "money/hnl": {
      "type": "number",
      "description": "Honduras Lempira"
    },
    "money/hrk": {
      "type": "number",
      "description": "Croatia Kuna"
    },
    "money/huf": {
      "type": "number",
      "description": "Hungary Forint"
    },
    "money/idr": {
      "type": "number",
      "description": "Indonesia Rupiah"
    },
    "money/ils": {
      "type": "number",
      "description": "Israel Shekel"
    },
    "money/inr": {
      "type": "number",
      "description": "India Rupee"
    },
    "money/jmd": {
      "type": "number",
      "description": "Jamaica Dollar"
    },
    "money/jod": {
      "type": "number"
    },
    "money/jpy": {
      "type": "number",
      "description": "Japan Yen"
    },
    "money/kes": {
      "type": "number"
    },
    "money/krw": {
      "type": "number",
      "description": "Korea (South) Won"
    },
    "money/kwd": {
      "type": "number"
    },
    "money/kyd": {
      "type": "number",
      "description": "Cayman Islands Dollar"
    },
    "money/kzt": {
      "type": "number",
      "description": "Kazakhstan Tenge"
    },
    "money/lbp": {
      "type": "number",
      "description": "Lebanon Pound"
    },
    "money/lkr": {
      "type": "number",
      "description": "Sri Lanka Rupee"
    },
    "money/ltl": {
      "type": "number",
      "description": "Lithuania Litas"
    },
    "money/lvl": {
      "type": "number",
      "description": "Latvia Lat"
    },
    "money/mad": {
      "type": "number"
    },
    "money/mdl": {
      "type": "number"
    },
    "money/mkd": {
      "type": "number",
      "description": "Macedonia Denar"
    },
    "money/mur": {
      "type": "number",
      "description": "Mauritius Rupee"
    },
    "money/mxn": {
      "type": "number",
      "description": "Mexico Peso"
    },
    "money/myr": {
      "type": "number",
      "description": "Malaysia Ringgit"
    },
    "money/nad": {
      "type": "number",
      "description": "Namibia Dollar"
    },
    "money/ngn": {
      "type": "number",
      "description": "Nigeria Naira"
    },
    "money/nio": {
      "type": "number",
      "description": "Nicaragua Cordoba"
    },
    "money/nok": {
      "type": "number",
      "description": "Norway Krone"
    },
    "money/npr": {
      "type": "number",
      "description": "Nepal Rupee"
    },
    "money/nzd": {
      "type": "number",
      "description": "New Zealand Dollar"
    },
    "money/omr": {
      "type": "number",
      "description": "Oman Rial"
    },
    "money/pen": {
      "type": "number",
      "description": "Peru Nuevo Sol"
    },
    "money/pgk": {
      "type": "number"
    },
    "money/php": {
      "type": "number",
      "description": "Philippines Peso"
    },
    "money/pkr": {
      "type": "number",
      "description": "Pakistan Rupee"
    },
    "money/pln": {
      "type": "number",
      "description": "Poland Zloty"
    },
    "money/pyg": {
      "type": "number",
      "description": "Paraguay Guarani"
    },
    "money/qar": {
      "type": "number",
      "description": "Qatar Riyal"
    },
    "money/ron": {
      "type": "number",
      "description": "Romania New Leu"
    },
    "money/rsd": {
      "type": "number",
      "description": "Serbia Dinar"
    },
    "money/rub": {
      "type": "number",
      "description": "Russia Ruble"
    },
    "money/sar": {
      "type": "number",
      "description": "Saudi Arabia Riyal"
    },
    "money/scr": {
      "type": "number",
      "description": "Seychelles Rupee"
    },
    "money/sek": {
      "type": "number",
      "description": "Sweden Krona"
    },
    "money/sgd": {
      "type": "number",
      "description": "Singapore Dollar"
    },
    "money/skk": {
      "type": "number"
    },
    "money/sll": {
      "type": "number"
    },
    "money/svc": {
      "type": "number",
      "description": "El Salvador Colon"
    },
    "money/thb": {
      "type": "number",
      "description": "Thailand Baht"
    },
    "money/tnd": {
      "type": "number"
    },
    "money/try": {
      "type": "number",
      "description": "Turkey Lira"
    },
    "money/ttd": {
      "type": "number",
      "description": "Trinidad and Tobago Dollar"
    },
    "money/twd": {
      "type": "number",
      "description": "Taiwan New Dollar"
    },
    "money/tzs": {
      "type": "number"
    },
    "money/uah": {
      "type": "number",
      "description": "Ukraine Hryvna"
    },
    "money/ugx": {
      "type": "number"
    },
    "money/usd": {
      "type": "number",
      "description": "United States Dollar"
    },
    "money/uyu": {
      "type": "number",
      "description": "Uruguay Peso"
    },
    "money/uzs": {
      "type": "number",
      "description": "Uzbekistan Som"
    },
    "money/vnd": {
      "type": "number",
      "description": "Viet Nam Dong"
    },
    "money/yer": {
      "type": "number",
      "description": "Yemen Rial"
    },
    "money/zar": {
      "type": "number",
      "description": "South Africa Rand"
    },
    "money/zmk": {
      "type": "number"
    },
    "money/btc": {
      "description": "Bitcoin",
      "type": "number"
    },
    "money/all": {
      "description": "Albania Lek",
      "type": "number"
    },
    "money/afn": {
      "description": "Afghanistan Afghani",
      "type": "number"
    },
    "money/awg": {
      "description": "Aruba Guilder",
      "type": "number"
    },
    "money/azn": {
      "description": "Azerbaijan New Manat",
      "type": "number"
    },
    "money/bsd": {
      "description": "Bahamas Dollar",
      "type": "number"
    },
    "money/bbd": {
      "description": "Barbados Dollar",
      "type": "number"
    },
    "money/byr": {
      "description": "Belarus Ruble",
      "type": "number"
    },
    "money/bzd": {
      "description": "Belize Dollar",
      "type": "number"
    },
    "money/bmd": {
      "description": "Bermuda Dollar",
      "type": "number"
    },
    "money/bam": {
      "description": "Bosnia and Herzegovina Convertible Marka",
      "type": "number"
    },
    "money/khr": {
      "description": "Cambodia Riel",
      "type": "number"
    },
    "money/cup": {
      "description": "Cuba Peso",
      "type": "number"
    },
    "money/xcd": {
      "description": "East Caribbean Dollar",
      "type": "number"
    },
    "money/fkp": {
      "description": "Falkland Islands (Malvinas) Pound",
      "type": "number"
    },
    "money/ghc": {
      "description": "Ghana Cedis",
      "type": "number"
    },
    "money/gip": {
      "description": "Gibraltar Pound",
      "type": "number"
    },
    "money/gtq": {
      "description": "Guatemala Quetzal",
      "type": "number"
    },
    "money/ggp": {
      "description": "Guernsey Pound",
      "type": "number"
    },
    "money/gyd": {
      "description": "Guyana Dollar",
      "type": "number"
    },
    "money/isk": {
      "description": "Iceland Krona",
      "type": "number"
    },
    "money/irr": {
      "description": "Iran Rial",
      "type": "number"
    },
    "money/imp": {
      "description": "Isle of Man Pound",
      "type": "number"
    },
    "money/jep": {
      "description": "Jersey Pound",
      "type": "number"
    },
    "money/kpw": {
      "description": "Korea (North) Won",
      "type": "number"
    },
    "money/kgs": {
      "description": "Kyrgyzstan Som",
      "type": "number"
    },
    "money/lak": {
      "description": "Laos Kip",
      "type": "number"
    },
    "money/lrd": {
      "description": "Liberia Dollar",
      "type": "number"
    },
    "money/mnt": {
      "description": "Mongolia Tughrik",
      "type": "number"
    },
    "money/mzn": {
      "description": "Mozambique Metical",
      "type": "number"
    },
    "money/pab": {
      "description": "Panama Balboa",
      "type": "number"
    },
    "money/shp": {
      "description": "Saint Helena Pound",
      "type": "number"
    },
    "money/sbd": {
      "description": "Solomon Islands Dollar",
      "type": "number"
    },
    "money/sos": {
      "description": "Somalia Shilling",
      "type": "number"
    },
    "money/srd": {
      "description": "Suriname Dollar",
      "type": "number"
    },
    "money/syp": {
      "description": "Syria Pound",
      "type": "number"
    },
    "money/trl": {
      "description": "Turkey Lira",
      "type": "number"
    },
    "money/tvd": {
      "description": "Tuvalu Dollar",
      "type": "number"
    },
    "money/vef": {
      "description": "Venezuela Bolivar",
      "type": "number"
    },
    "money/zwd": {
      "description": "Zimbabwe Dollar",
      "type": "number"
    },
    "mood/rating": {
      "description": "Rating of mood (float value) 0:worst -> 1:best",
      "type": "number",
      "minimum": 0,
      "maximum": 1
    },
    "mood/emoticon": {
      "description": "ASCII Art emoticon",
      "type": "string"
    },
    "music/basic": {
      "description": "Inspired from id3 key/pair",
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "artist": {
          "type": "string"
        },
        "album": {
          "type": "string"
        },
        "track": {
          "type": "integer"
        },
        "year": {
          "type": "integer"
        },
        "genre": {
          "type": "string"
        }
      }
    },
    "music/soundcloud": {
      "description": "See [Soundcloud track properties](http://developers.soundcloud.com/docs/api/reference#tracks).",
      "type": "object",
      "additionalProperties": true,
      "properties": {
        "id": {
          "type": "integer"
        }
      },
      "required": [
        "id"
      ]
    },
    "note/html": {
      "description": "An HTML-formatted note.",
      "type": "string",
      "maxLength": 4194304
    },
    "note/txt": {
      "description": "A plain-text note.",
      "type": "string",
      "maxLength": 4194304
    },
    "note/webclip": {
      "description": "An HTML-formatted note associated to its source URL.",
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "pattern": "^(https?)://.+$"
        },
        "content": {
          "description": "An HTML-formatted string.",
          "type": "string",
          "maxLength": 4194304
        }
      },
      "required": [
        "url"
      ]
    },
    "numset/*": {
      "description": "The format key is freely defined.\n\nFor example, a heart measurement with type `numset/heart` and content:\n```\n{ \n  \"systolic\": { \"pressure/mmhg\": 105 },\n  \"diastolic\": { \"pressure/mmhg\": 64 },\n  \"rate\": { \"frequency/bpm\": 88 }\n}\n```\n\n ",
      "type": "object",
      "patternProperties": {
        "^(/[^/]+)+$": {
          "type": "number"
        }
      },
      "additionalProperties": "false",
      "required": []
    },
    "picture/base64": {
      "description": "The picture is caried in base64 (utf-8) encoded in string",
      "type": "string",
      "properties": {
        "payload": {
          "type": "string",
          "description": "base64 encoded content"
        },
        "format": {
          "type": "string",
          "description": "The data format \"gif\", \"jpeg\", \"png\", \"tiff\", \"vnd.microsoft.com\", \"svg+xml\""
        },
        "filename": {
          "description": "A filename",
          "type": "string"
        }
      },
      "required": [
        "payload",
        "format"
      ]
    },
    "picture/attached": {
      "description": "The picture is the image file attached to the event (no explicit content defined). TODO: list accepted formats.",
      "type": "null",
      "attachmentRequired": true
    },
    "picture/url": {
      "description": "A reference to a picture file online.",
      "type": "string",
      "pattern": "^(https?)://.+$"
    },
    "position/wgs84": {
      "description": "The latest revision of the World Geodetic System (used by GPS).",
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "description": "Unit: degrees north from the equator."
        },
        "longitude": {
          "type": "number",
          "description": "Unit: degrees east from the zero meridian."
        },
        "altitude": {
          "type": "number",
          "description": "Unit: meters above sea level."
        },
        "horizontalAccuracy": {
          "type": "number",
          "description": "The radius of uncertainty for latitude and longitude. Unit: meters. Negative if latitude and longitude are invalid."
        },
        "verticalAccuracy": {
          "type": "number",
          "description": "The radius of uncertainty for altitude. Unit: meters. Negative if altitude is invalid."
        },
        "speed": {
          "type": "number",
          "description": "For informational purposes only. Unit: meters / second. Negative if invalid."
        },
        "bearing": {
          "type": "number",
          "description": "Unit: degrees clockwise from north. Negative if invalid."
        }
      },
      "required": [
        "latitude",
        "longitude"
      ]
    },
    "ratio/generic": {
      "description": "Generic ratio.",
      "type": "object",
      "properties": {
        "value": {
          "type": "number"
        },
        "relativeTo": {
          "type": "number"
        }
      },
      "required": [
        "value",
        "relativeTo"
      ]
    },
    "ratio/percent": {
      "description": "A percentage value.",
      "type": "number"
    },
    "url/http": {
      "description": "An HTTP or HTTPS resource.",
      "type": "string",
      "pattern": "^(https?)://.+$"
    },
    "video/attached": {
      "description": "The video is the file attached to the event (no explicit content defined). TODO: list accepted formats.",
      "type": "null",
      "attachmentRequired": true
    },
    "video/url": {
      "description": "A reference to an video file online.",
      "type": "string",
      "pattern": "^(https?)://.+$"
    },
    "video/vimeo": {
      "description": "A Vimeo video ID.",
      "type": "string"
    },
    "video/youtube": {
      "description": "A YouTube video ID.",
      "type": "string"
    },
    "absorbed-dose/gy": {
      "description": "Gray",
      "type": "number"
    },
    "absorbed-dose-equivalent/sv": {
      "description": "Sievert",
      "type": "number"
    },
    "absorbed-dose-rate/gy-s": {
      "description": "Gray per second",
      "type": "number"
    },
    "angle/deg": {
      "description": "Degrees",
      "type": "number"
    },
    "angle/grad": {
      "description": "Grade",
      "type": "number"
    },
    "angle/rad": {
      "description": "Radians",
      "type": "number"
    },
    "angular-acceleration/rad-s2": {
      "description": "Radians per second squared",
      "type": "number"
    },
    "angular-speed/rad-s": {
      "description": "Radians per second",
      "type": "number"
    },
    "area/ac": {
      "description": "Acres (imperial)",
      "type": "number"
    },
    "area/ft2": {
      "description": "Square feet",
      "type": "number"
    },
    "area/ha": {
      "description": "Hectares",
      "type": "number"
    },
    "area/in2": {
      "description": "Square inches",
      "type": "number"
    },
    "area/km2": {
      "description": "Square kilometers",
      "type": "number"
    },
    "area/m2": {
      "description": "Square meter",
      "type": "number"
    },
    "area/mm2": {
      "description": "Square millimeters",
      "type": "number"
    },
    "area/yd2": {
      "description": "Square yards",
      "type": "number"
    },
    "area/mi2": {
      "description": "Square miles",
      "type": "number"
    },
    "capacitance/f": {
      "description": "Farad",
      "type": "number"
    },
    "catalytic-activity/kat": {
      "description": "Katal",
      "type": "number"
    },
    "count/steps": {
      "description": "Number of steps",
      "type": "number"
    },
    "count/generic": {
      "description": "For general items that demand no particular handling.",
      "type": "number"
    },
    "data-quantity/b": {
      "description": "Bytes",
      "type": "number"
    },
    "data-quantity/bits": {
      "description": "Bits",
      "type": "number"
    },
    "data-quantity/gb": {
      "description": "Gigabytes",
      "type": "number"
    },
    "data-quantity/gbits": {
      "description": "Gigabits",
      "type": "number"
    },
    "data-quantity/kb": {
      "description": "Kilobytes",
      "type": "number"
    },
    "data-quantity/kbits": {
      "description": "Kilobits",
      "type": "number"
    },
    "data-quantity/mb": {
      "description": "Megabytes",
      "type": "number"
    },
    "data-quantity/mbits": {
      "description": "Megabits",
      "type": "number"
    },
    "data-quantity/tb": {
      "description": "Terabytes",
      "type": "number"
    },
    "density/g-dl": {
      "description": "Grams per deciliter",
      "type": "number"
    },
    "density/kg-m3": {
      "description": "Kilograms per cubic meter",
      "type": "number"
    },
    "density/mmol-l": {
      "description": "Millimoles per liter",
      "type": "number"
    },
    "density/mg-dl": {
      "description": "Milligrams per deciliter",
      "type": "number"
    },
    "dynamic-viscosity/pa-s": {
      "description": "Pascal second",
      "type": "number"
    },
    "electric-charge/c": {
      "description": "Coulomb ",
      "type": "number"
    },
    "electric-charge-line-density/c-m": {
      "description": "Coulomb per meter",
      "type": "number"
    },
    "electric-current/a": {
      "description": "Ampere",
      "type": "number"
    },
    "electrical-conductivity/s": {
      "description": "Siemens",
      "type": "number"
    },
    "electromotive-force/v": {
      "description": "Volt",
      "type": "number"
    },
    "energy/btu": {
      "description": "British Thermal Units",
      "type": "number"
    },
    "energy/cal": {
      "description": "Calories",
      "type": "number"
    },
    "energy/ev": {
      "description": "Electron-Volts",
      "type": "number"
    },
    "energy/erg": {
      "description": "Ergs",
      "type": "number"
    },
    "energy/ftlb": {
      "description": "Foot-Pounds",
      "type": "number"
    },
    "energy/j": {
      "description": "Joules",
      "type": "number"
    },
    "energy/kcal": {
      "description": "Kilo-calories",
      "type": "number"
    },
    "energy/ws": {
      "description": "Watt-seconds",
      "type": "number"
    },
    "energy/kwh": {
      "description": "Kilowatt-hours",
      "type": "number"
    },
    "energy/nm": {
      "description": "Newton-meters",
      "type": "number"
    },
    "energy/wh": {
      "description": "Watt-hours",
      "type": "number"
    },
    "force/dyn": {
      "description": "Dynes",
      "type": "number"
    },
    "force/n": {
      "description": "Newtons",
      "type": "number"
    },
    "force/pdl": {
      "description": "Poundals",
      "type": "number"
    },
    "frequency/bpm": {
      "description": "Beats per minute",
      "type": "number"
    },
    "frequency/ghz": {
      "description": "Gigahertz",
      "type": "number"
    },
    "frequency/hz": {
      "description": "Hertz (also known as cycles per second) ",
      "type": "number"
    },
    "frequency/khz": {
      "description": "Kilohertz",
      "type": "number"
    },
    "frequency/megahz": {
      "description": "Megahertz",
      "type": "number"
    },
    "frequency/millihz": {
      "description": "Millihertz",
      "type": "number"
    },
    "frequency/nhz": {
      "description": "Nanohertz",
      "type": "number"
    },
    "frequency/rpm": {
      "description": "Revolutions per minute",
      "type": "number"
    },
    "frequency/thz": {
      "description": "Terahertz",
      "type": "number"
    },
    "frequency/uhz": {
      "description": "Microhertz",
      "type": "number"
    },
    "length/cm": {
      "description": "Centimeters",
      "type": "number"
    },
    "length/m": {
      "description": "Meters",
      "type": "number"
    },
    "length/mm": {
      "description": "Millimeters",
      "type": "number"
    },
    "length/km": {
      "description": "Kilometers",
      "type": "number"
    },
    "length/a": {
      "description": "Ångströms",
      "type": "number"
    },
    "length/au": {
      "description": "Astronomical units",
      "type": "number"
    },
    "length/ch": {
      "description": "Chains",
      "type": "number"
    },
    "length/lea": {
      "description": "Leagues",
      "type": "number"
    },
    "length/ft": {
      "description": "Feet",
      "type": "number"
    },
    "length/in": {
      "description": "Inches",
      "type": "number"
    },
    "length/ly": {
      "description": "Light-years",
      "type": "number"
    },
    "length/mil": {
      "description": "Mil",
      "type": "number"
    },
    "length/mi": {
      "description": "Miles",
      "type": "number"
    },
    "length/fur": {
      "description": "Furlongs",
      "type": "number"
    },
    "length/nmi": {
      "description": "Miles (nautical)",
      "type": "number"
    },
    "length/p": {
      "description": "Points",
      "type": "number"
    },
    "length/pica": {
      "description": "Picas",
      "type": "number"
    },
    "length/ftm": {
      "description": "Fathoms",
      "type": "number"
    },
    "length/cb": {
      "description": "Cables",
      "type": "number"
    },
    "length/um": {
      "description": "Microns",
      "type": "number"
    },
    "length/yd": {
      "description": "Yards",
      "type": "number"
    },
    "luminous-intensity/cd": {
      "description": "Candela",
      "type": "number"
    },
    "mass/kg": {
      "description": "Kilograms",
      "type": "number"
    },
    "mass/gr": {
      "description": "Grains",
      "type": "number"
    },
    "mass/dr": {
      "description": "Drams",
      "type": "number"
    },
    "mass/g": {
      "description": "Grams",
      "type": "number"
    },
    "mass/l-t": {
      "description": "Long tons",
      "type": "number"
    },
    "mass/lb": {
      "description": "Pounds",
      "type": "number"
    },
    "mass/t": {
      "description": "Metric tons",
      "type": "number"
    },
    "mass/oz": {
      "description": "Ounces",
      "type": "number"
    },
    "mass/s-t": {
      "description": "Short tons",
      "type": "number"
    },
    "mass/st": {
      "description": "Stone",
      "type": "number"
    },
    "mol/mol": {
      "description": "Mole ",
      "type": "number"
    },
    "mol/lb-mol": {
      "description": "Pound-mole.",
      "type": "number"
    },
    "power/btu-min": {
      "description": "BTUs/minute",
      "type": "number"
    },
    "power/ftlb-s": {
      "description": "Foot-pounds/second",
      "type": "number"
    },
    "power/hp": {
      "description": "Horsepower",
      "type": "number"
    },
    "power/kw": {
      "description": "Kilowatts",
      "type": "number"
    },
    "power/w": {
      "description": "Watts",
      "type": "number"
    },
    "pressure/at": {
      "description": "Atmospheres",
      "type": "number"
    },
    "pressure/bar": {
      "description": "Bars",
      "type": "number"
    },
    "pressure/mmhg": {
      "description": "Millimeters of mercury",
      "type": "number"
    },
    "pressure/cmhg": {
      "description": "Centimeters of mercury",
      "type": "number"
    },
    "pressure/inhg": {
      "description": "Inches of mercury",
      "type": "number"
    },
    "pressure/kg-m2": {
      "description": "Kilograms/square meter",
      "type": "number"
    },
    "pressure/pa": {
      "description": "Pascals",
      "type": "number"
    },
    "pressure/kpa": {
      "description": "Kilo pascals",
      "type": "number"
    },
    "pressure/psf": {
      "description": "Pounds/square foot",
      "type": "number"
    },
    "pressure/psi": {
      "description": "Pounds/square inch",
      "type": "number"
    },
    "speed/ft-m": {
      "description": "Feet/minute",
      "type": "number"
    },
    "speed/ft-s": {
      "description": "Feet/second",
      "type": "number"
    },
    "speed/km-h": {
      "description": "Kilometers/hour",
      "type": "number"
    },
    "speed/kt": {
      "description": "Knots",
      "type": "number"
    },
    "speed/m-min": {
      "description": "Miles/minute",
      "type": "number"
    },
    "speed/m-s": {
      "description": "Meters/second",
      "type": "number"
    },
    "speed/mph": {
      "description": "Miles/hour",
      "type": "number"
    },
    "temperature/c": {
      "description": "Celsius",
      "type": "number"
    },
    "temperature/k": {
      "description": "Kelvin",
      "type": "number"
    },
    "temperature/f": {
      "description": "Fahrenheit",
      "type": "number"
    },
    "time/d": {
      "description": "Days",
      "type": "number"
    },
    "time/h": {
      "description": "Hours",
      "type": "number"
    },
    "time/min": {
      "description": "Minutes",
      "type": "number"
    },
    "time/ms": {
      "description": "Milliseconds",
      "type": "number"
    },
    "time/s": {
      "description": "Seconds",
      "type": "number"
    },
    "time/y": {
      "description": "Years",
      "type": "number"
    },
    "volume/l": {
      "description": "Liters",
      "type": "number"
    },
    "volume/m3": {
      "description": "Cubic meters",
      "type": "number"
    },
    "volume/c": {
      "description": "Cups",
      "type": "number"
    },
    "volume/cm3": {
      "description": "Cubic centimeters",
      "type": "number"
    },
    "volume/floz": {
      "description": "Fluid ounces",
      "type": "number"
    },
    "volume/ft3": {
      "description": "Cubic feet",
      "type": "number"
    },
    "volume/galgb": {
      "description": "Gallons imperial",
      "type": "number"
    },
    "volume/galus": {
      "description": "Gallons US",
      "type": "number"
    },
    "volume/in3": {
      "description": "Cubic inches",
      "type": "number"
    },
    "volume/yd3": {
      "description": "Cubic yard",
      "type": "number"
    },
    "volume/ml": {
      "description": "Milliliters",
      "type": "number"
    },
    "volume/pt": {
      "description": "Pints",
      "type": "number"
    },
    "volume/qt": {
      "description": "Quarts",
      "type": "number"
    },
    "volume/bbloil": {
      "description": "Barrels (oil)",
      "type": "number"
    },
    "volume/tbs": {
      "description": "Tablespoons",
      "type": "number"
    },
    "volume/tsp": {
      "description": "Teaspoons",
      "type": "number"
    }
  }
}
},{}],49:[function(require,module,exports){
var utility = require('./utility/utility'),
    _ = require('underscore'),
    CC = require('./connection/ConnectionConstants.js');

/**
 * Event types directory data.
 * @link http://api.pryv.com/event-types/
 */
var eventTypes = module.exports = {};

var HOSTNAME = 'pryv.github.io',
    PORT = 443,
    SSL = true,
    PATH = '/event-types/',
    FLATFILE = 'flat.json',
    EXTRASFILE = 'extras.json',
    // TODO: discuss if hierarchical data is really needed (apparently not); remove all that if not
    HIERARCHICALFILE = 'hierarchical.json';

// load default data (fallback)
var types = require('./event-types.default.json'),
    extras = require('./event-extras.default.json'),
    hierarchical = require('./event-hierarchical.default.json');
types.isDefault = true;
extras.isDefault = true;

/**
 * @link http://api.pryv.com/event-types/#json-file
 * @param {Function} callback
 */
eventTypes.loadFlat = function (callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  _requestFile(FLATFILE, function (err, result) {
    if (err) { return callback(err); }
    if (! isValidTypesFile(result)) {
      return callback(new Error('Missing or corrupt types file: "' +
                                HOSTNAME + PATH + FLATFILE + '"'));
    }
    _.extend(types, result);
    types.isDefault = false;
    callback(null, types);
  });
};

/**
 * Performs a basic check to avoid corrupt data (more smoke test than actual validation).
 * @param {Object} data
 */
function isValidTypesFile(data) {
  return data && data.version && data.types && data.types['activity/plain'];
}

eventTypes.flat = function (eventType) {
  return types.types[eventType];
};

/**
 * @link http://api.pryv.com/event-types/#json-file
 * @param {Function} callback
 */
eventTypes.loadExtras = function (callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  _requestFile(EXTRASFILE, function (err, result) {
    if (err) { return callback(err); }
    if (! isValidExtrasFile(result)) {
      return callback(new Error('Missing or corrupt extras file: "' +
                                HOSTNAME + PATH + EXTRASFILE + '"'));
    }
    _.extend(extras, result);
    extras.isDefault = false;
    callback(null, extras);
  });
};

/**
 * Performs a basic check to avoid corrupt data (more smoke test than actual validation).
 * @param {Object} data
 */
function isValidExtrasFile(data) {
  return data && data.version && data.extras && data.extras.count && data.extras.count.formats;
}

eventTypes.hierarchical = function () {
  return hierarchical;
};

eventTypes.extras = function (eventType) {
  var parts = eventType.split('/');
  return extras.extras[parts[0]] && extras.extras[parts[0]].formats[parts[1]] ?
      extras.extras[parts[0]].formats[parts[1]] : null;
};

eventTypes.isNumerical = function (eventOrEventType) {
  if (! eventOrEventType) { return false; }
  var type;
  if (eventOrEventType.type) {
    type = eventOrEventType.type;
  } else {
    type = eventOrEventType;
  }
  var def = eventTypes.flat(type);
  return def ? def.type === 'number' : false;
};

/**
 * @link http://api.pryv.com/event-types/#json-file
 * @param {Function} callback
 */
eventTypes.loadHierarchical = function (callback) {
  if (typeof(callback) !== 'function') {
    throw new Error(CC.Errors.CALLBACK_IS_NOT_A_FUNCTION);
  }
  _requestFile(HIERARCHICALFILE, function (err, result) {
    if (err) { return callback(err); }
    hierarchical = result;
    hierarchical.isDefault = false;
    callback(null, hierarchical);
  });
};

/**
 * @private
 * @param fileName
 * @param callback
 */
function _requestFile(fileName, callback) {
  utility.request({
    method : 'GET',
    host : HOSTNAME,
    path : PATH + fileName,
    port : PORT,
    ssl : SSL,
    withoutCredentials: true,
    success : function (result) { callback(null, result); },
    error : function (error) { callback(error, null); }
  });
}

},{"./connection/ConnectionConstants.js":41,"./event-extras.default.json":46,"./event-hierarchical.default.json":47,"./event-types.default.json":48,"./utility/utility":60,"underscore":28}],50:[function(require,module,exports){
module.exports = {
  // TODO: fix singleton (see with me [sgoumaz] if needed)
  Auth: require('./auth/Auth.js'),
  Connection: require('./Connection.js'),
  Event: require('./Event.js'),
  Stream: require('./Stream.js'),
  Filter: require('./Filter.js'),

  eventTypes: require('./eventTypes.js'),
  utility: require('./utility/utility.js'),
  MESSAGES: {
    MONITOR: require('./Monitor.js').Messages
  }
};

},{"./Connection.js":29,"./Event.js":31,"./Filter.js":32,"./Monitor.js":33,"./Stream.js":34,"./auth/Auth.js":37,"./eventTypes.js":49,"./utility/utility.js":60}],51:[function(require,module,exports){
/**
 * (event)Emitter renamed to avoid confusion with prvy's events
 */


var _ = require('underscore');

var SignalEmitter = module.exports = function (messagesMap) {
  SignalEmitter.extend(this, messagesMap);
};


SignalEmitter.extend = function (object, messagesMap, name) {
  if (! name) {
    throw new Error('"name" parameter must be set');
  }
  object._signalEmitterEvents = {};
  _.each(_.values(messagesMap), function (value) {
    object._signalEmitterEvents[value] = [];
  });
  _.extend(object, SignalEmitter.prototype);
  object._signalEmitterName = name;
};


SignalEmitter.Messages = {
  /** called when a batch of changes is expected, content: <batchId> unique**/
  BATCH_BEGIN : 'beginBatch',
  /** called when a batch of changes is done, content: <batchId> unique**/
  BATCH_DONE : 'doneBatch',
  /** if an eventListener return this string, it will be removed automatically **/
  UNREGISTER_LISTENER : 'unregisterMePlease'
};

/**
 * Add an event listener
 * @param signal one of  Messages.SIGNAL.*.*
 * @param callback function(content) .. content vary on each signal.
 * If the callback returns SignalEmitter.Messages.UNREGISTER_LISTENER it will be removed
 * @return the callback function for further reference
 */
SignalEmitter.prototype.addEventListener = function (signal, callback) {
  this._signalEmitterEvents[signal].push(callback);
  return callback;
};


/**
 * remove the callback matching this signal
 */
SignalEmitter.prototype.removeEventListener = function (signal, callback) {
  for (var i = 0; i < this._signalEmitterEvents[signal].length; i++) {
    if (this._signalEmitterEvents[signal][i] === callback) {
      this._signalEmitterEvents[signal][i] = null;
    }
  }
};


/**
 * A changes occurred on the filter
 * @param signal
 * @param content
 * @param batch
 * @private
 */
SignalEmitter.prototype._fireEvent = function (signal, content, batch) {
  var batchId = batch ? batch.id : null;
  if (! signal) { throw new Error(); }

  var batchStr = batchId ? ' batch: ' + batchId + ', ' + batch.batchName : '';
  console.log('FireEvent-' + this._signalEmitterName  + ' : ' + signal + batchStr);

  _.each(this._signalEmitterEvents[signal], function (callback) {
    if (callback !== null &&
      SignalEmitter.Messages.UNREGISTER_LISTENER === callback(content, batch)) {
      this.removeEventListener(signal, callback);
    }
  }, this);
};


SignalEmitter.batchSerial = 0;
/**
 * Start a batch process
 *
 * @param batchName Name of the new batch
 * @param orHookOnBatch Existing batch to hook on ("superbatch")
 * @return A batch object (call `done()` when done)
 * @private
 */
SignalEmitter.prototype.startBatch = function (name, orHookOnBatch) {

  if (! orHookOnBatch) {
    return new Batch(name, this);
  }
  name = orHookOnBatch.name + '/' + name;
  var batch = new Batch(name, this);
  orHookOnBatch.waitForMeToFinish(name + ':hook');
  batch.addOnDoneListener(name, function () {
    orHookOnBatch.done(name + ':hook');
  });
  return batch;
};

var Batch = function (name, owner) {
  this.owner = owner;
  this.name = name || 'x';
  this.id = owner._signalEmitterName + SignalEmitter.batchSerial++;
  this.waitFor = 0;
  this.history = [];
  this.doneCallbacks = {};
  this.waitForMeToFinish(this.name);
  this.owner._fireEvent(SignalEmitter.Messages.BATCH_BEGIN, this.id, this);

};



/**
 * listener are stored in key/map fashion, so addOnDoneListener('bob',..)
 * may be called several time, callback 'bob', will be done just once
 * @param key a unique key per callback
 * @param callback
 */
Batch.prototype.addOnDoneListener = function (key, callback) {
  this.checkAlreadyDone('addOnDoneListener(' + key + ')');
  this.doneCallbacks[key] = callback;
};

Batch.prototype.waitForMeToFinish = function (key) {
  this.checkAlreadyDone('waitForMeToFinish(' + key + ')');
  this.waitFor++;
  this.history.push({wait: key, waitFor: this.waitFor});
  return this;
};

Batch.prototype.done = function (key) {
  this.checkAlreadyDone('done(' + key + ')');
  key = key || '--';
  this.waitFor--;
  this.history.push({done: key, waitFor: this.waitFor});
  if (this.waitFor === 0) {

    this.doneTriggered = true;
    _.each(this.doneCallbacks, function (callback) {
      callback();
    });
    delete this.doneCallbacks; // prevents memory leaks
    this.owner._fireEvent(SignalEmitter.Messages.BATCH_DONE, this.id, this);
  }
};

Batch.prototype.checkAlreadyDone = function (addon) {
  if (this.doneTriggered) {
    var msg = 'Batch ' + this.name + ', ' + this.id + ' called ' + addon + '  when already done';
    throw new Error(msg + '     ' + JSON.stringify(this.history));
  }
};

},{"underscore":28}],52:[function(require,module,exports){
/* jshint ignore:start */

/*\
 |*|
 |*|  :: cookies.js ::
 |*|
 |*|  A complete cookies reader/writer framework with full unicode support.
 |*|
 |*|  https://developer.mozilla.org/en-US/docs/DOM/document.cookie
 |*|
 |*|  Syntaxes:
 |*|
 |*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])
 |*|  * docCookies.getItem(name)
 |*|  * docCookies.removeItem(name[, path])
 |*|  * docCookies.hasItem(name)
 |*|  * docCookies.keys()
 |*|
 \*/
module.exports = {
  getItem: function (sKey) {
    if (!sKey || !this.hasItem(sKey)) { return null; }
    return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" +
        escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
  },
  setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return; }
    var sExpires = "";
    if (vEnd) {
      switch (vEnd.constructor) {
        case Number:
          sExpires = vEnd === Infinity ?
              "; expires=Tue, 19 Jan 2038 03:14:07 GMT" : "; max-age=" + vEnd;
          break;
        case String:
          sExpires = "; expires=" + vEnd;
          break;
        case Date:
          sExpires = "; expires=" + vEnd.toGMTString();
          break;
      }
    }
    document.cookie = escape(sKey) + "=" + escape(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
  },
  removeItem: function (sKey, sPath) {
    if (!sKey || !this.hasItem(sKey)) { return; }
    document.cookie = escape(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sPath ? "; path=" + sPath : "");
  },
  hasItem: function (sKey) {
    return (new RegExp("(?:^|;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
  },
  keys: /* optional method: you can safely remove it! */ function () {
    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
    for (var nIdx = 0; nIdx < aKeys.length; nIdx++) { aKeys[nIdx] = unescape(aKeys[nIdx]); }
    return aKeys;
  }
};

},{}],53:[function(require,module,exports){
/* jshint ignore:start */

/*!
 * domready (c) Dustin Diaz 2012 - License MIT
 */
module.exports = function (ready) {


  var fns = [], fn, f = false,
      doc = document,
      testEl = doc.documentElement,
      hack = testEl.doScroll,
      domContentLoaded = 'DOMContentLoaded',
      addEventListener = 'addEventListener',
      onreadystatechange = 'onreadystatechange',
      readyState = 'readyState',
      loaded = /^loade|c/.test(doc[readyState]);

  function flush(f) {
    loaded = 1;
    while (f = fns.shift()) {
      f()
    }
  }

  doc[addEventListener] && doc[addEventListener](domContentLoaded, fn = function () {
    doc.removeEventListener(domContentLoaded, fn, f);
    flush();
  }, f);


  hack && doc.attachEvent(onreadystatechange, fn = function () {
    if (/^c/.test(doc[readyState])) {
      doc.detachEvent(onreadystatechange, fn);
      flush();
    }
  });

  return (ready = hack ?
      function (fn) {
        self != top ?
            loaded ? fn() : fns.push(fn) :
            function () {
              console.log("on dom ready 2");
              try {
                testEl.doScroll('left')
              } catch (e) {
                return setTimeout(function() { ready(fn) }, 50)
              }
              fn()
            }()
      } :
      function (fn) {
        loaded ? fn() : fns.push(fn)
      })
}();

},{}],54:[function(require,module,exports){
/**
 * Common regexps
 * TODO: fix naming to "commonRegexps", "Username" and "Email" (they are constants)
 */
module.exports = {
  username :  /^([a-zA-Z0-9])(([a-zA-Z0-9\-]){3,21})([a-zA-Z0-9])$/,
  email : /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/
};

},{}],55:[function(require,module,exports){
/**
 *
 * @param {Object} pack json with
 * @param {Object} [pack.type = 'POST'] : 'GET/DELETE/POST/PUT'
 * @param {String} pack.host : fully qualified host name
 * @param {Number} pack.port : port to use
 * @param {String} pack.path : the request PATH
 * @param {Object} [pack.headers] : key / value map of headers
 * @param {Object} [pack.params] : the payload -- only with POST/PUT
 * @param {String} [pack.parseResult = 'json'] : 'text' for no parsing
 * @param {Function} pack.success : function (result, resultInfo)
 * @param {Function} pack.error : function (error, resultInfo)
 * @param {String} [pack.info] : a text
 * @param {Boolean} [pack.async = true]
 * @param {Number} [pack.expectedStatus] : http result code
 * @param {Boolean} [pack.ssl = true]
 * @param {Boolean} [pack.withoutCredentials = false]
 */
module.exports = function (pack)  {
  pack.info = pack.info || '';
  var parseResult = pack.parseResult || 'json';

  if (!pack.hasOwnProperty('async')) {
    pack.async = true;
  }

  // ------------ request TYPE
  pack.method = pack.method || 'POST';
  // method override test
  if (false && pack.method === 'DELETE') {
    pack.method = 'POST';
    pack.params =  pack.params || {};
    pack.params._method = 'DELETE';
  }

  // ------------- request HEADERS


  pack.headers = pack.headers || {};

  if (pack.method === 'POST' || pack.method === 'PUT') {// add json headers is POST or PUT

    if (pack.headers['Content-Type'] === 'multipart/form-data') {
      delete pack.headers['Content-Type'];
    } else {
      pack.headers['Content-Type'] =
          pack.headers['Content-Type'] || 'application/json; charset=utf-8';
    }

    //if (pack.method === 'POST') {
    if (pack.params) {
      pack.params = JSON.stringify(pack.params);
    } else {
      pack.params = pack.payload || {};
    }
  }



  // -------------- error
  pack.error = pack.error || function (error) {
    throw new Error(JSON.stringify(error, function (key, value) {
      if (value === null) { return; }
      if (value === '') { return; }
      return value;
    }, 2));
  };

  var detail = pack.info + ', req: ' + pack.method + ' ' + pack.url;

  // --------------- request
  var xhr = _initXHR(),
      httpMode = pack.ssl ? 'https://' : 'http://',
      url = httpMode + pack.host + pack.path;
  xhr.open(pack.method, url, pack.async);
  xhr.withCredentials = pack.withoutCredentials ? false : true;


  xhr.onreadystatechange = function () {
    detail += ' xhrstatus:' + xhr.statusText;
    if (xhr.readyState === 0) {
      pack.callBackSent = 'error in request';
      pack.error({
        message: 'pryvXHRCall unsent',
        detail: detail,
        id: 'INTERNAL_ERROR',
        xhr: xhr
      });
    } else if (xhr.readyState === 4) {
      var result = null;

      if (parseResult === 'json') {
        var response = xhr.responseText;
        response = response.trim() === '' ? '{}' : response;
        try { result = JSON.parse(response); } catch (e) {
          return pack.error({
            message: 'Data is not JSON',
            detail: xhr.responseText + '\n' + detail,
            id: 'RESULT_NOT_JSON',
            xhr: xhr
          });
        }
      }
      var resultInfo = {
        xhr : xhr,
        code : xhr.status,
        headers : parseResponseHeaders(xhr.getAllResponseHeaders())
      };

      if (pack.callBackSent) {
        console.error('xhr.onreadystatechange called with status==4 even if callback is done:' +
          pack.callBackSent);
        return;
      }
      pack.callBackSent = 'success';
      pack.success(result, resultInfo);
    }
  };
  if (pack.progressCallback && typeof(pack.progressCallback) === 'function') {
    xhr.upload.addEventListener('progress', function (e) {
      return pack.progressCallback(e);
    }, false);
  }
  for (var key in pack.headers) {
    if (pack.headers.hasOwnProperty(key)) {
      xhr.setRequestHeader(key, pack.headers[key]);
    }
  }

  //--- sending the request
  try {
    xhr.send(pack.params);
  } catch (e) {
    pack.callBackSent = 'error sending request';
    return pack.error({
      message: 'pryvXHRCall unsent',
      detail: detail,
      id: 'INTERNAL_ERROR',
      error: e,
      xhr: xhr
    });
  }
  return xhr;
};

/**
 * Method to initialize XMLHttpRequest.
 * @method _initXHR
 * @access private
 * @return object
 */
/* jshint -W117 */
var _initXHR = function () {
  var XHR = null;

  try { XHR = new XMLHttpRequest(); }
  catch (e) {
    try { XHR = new ActiveXObject('Msxml2.XMLHTTP'); }
    catch (e2) {
      try { XHR = new ActiveXObject('Microsoft.XMLHTTP'); }
      catch (e3) {
        console.log('XMLHttpRequest implementation not found.');
      }
      console.log('XMLHttpRequest implementation not found.');
    }
    console.log('XMLHttpRequest implementation not found.');
  }
  return XHR;
};


/**
 * XmlHttpRequest's getAllResponseHeaders() method returns a string of response
 * headers according to the format described here:
 * http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method
 * This method parses that string into a user-friendly key/value pair object.
 */
function parseResponseHeaders(headerStr) {
  var headers = {};
  if (!headerStr) {
    return headers;
  }
  var headerPairs = headerStr.split('\u000d\u000a');
  for (var i = 0; i < headerPairs.length; i++) {
    var headerPair = headerPairs[i];
    // Can't use split() here because it does the wrong thing
    // if the header value has the string ": " in it.
    var index = headerPair.indexOf('\u003a\u0020');
    if (index > 0) {
      var key = headerPair.substring(0, index).toLowerCase();
      var val = headerPair.substring(index + 2);
      headers[key] = val;
    }
  }
  return headers;
}

},{}],56:[function(require,module,exports){
(function (Buffer){
//TODO align with XHR error

//TODO: sort out the callback convention

var FormData = require('form-data');
var _ = require('underscore');

/**
 * executes the low-level HTTP request.
 *
 * @param {Object} pack json with
 * @param {Object} [pack.method = 'GET'] : 'GET/DELETE/POST/PUT'
 * @param {String} pack.host : fully qualified host name
 * @param {Number} [pack.port] : port to use
 * @param {String} pack.path : the request PATH
 * @param {Object} [pack.headers] : key / value map of headers
 * @param {Object} [pack.payload] : the payload -- only with POST/PUT
 * @param {String} [pack.parseResult = 'json'] : 'text' for no parsing
 * @param {Function} pack.success : function (data, responseInfo), called when no error occurs in
 * the network or the JSON parsing. data contains the parsed response body, responseInfo contains
 * the headers and HTTP status code.
 * @param {Function} pack.error : function (error, [responseInfo]), called when a network error or
 * JSON parsing error occurs
 * @param {Boolean} [pack.ssl = true]
 */
module.exports = function (pack) {

  // request TYPE
  pack.method = pack.method || 'GET';

  var parseResult = pack.parseResult || 'json';

  // // choose between HTTP and HTTPS
  var httpMode = pack.ssl ? 'https' : 'http';
  var http = require(httpMode);

  var httpOptions = {
    host: pack.host,
    path: pack.path,
    port: pack.port || (pack.ssl ? 443 : 80), // if no port is specified, choose HTTPS or
                                              // HTTP default ports
    method: pack.method,
    headers: pack.headers
  };

  // When creating an attachment
  if (pack.payload instanceof FormData) {
    httpOptions.method = 'POST';
    _.extend(httpOptions.headers, pack.payload.getHeaders());
  } else {
    // if some data is sent to the Back-End, set Content-Length header accordingly
    if (pack.payload) {
      pack.headers['Content-Length'] = Buffer.byteLength(pack.payload, 'utf-8');
    }
  }

  var req = http.request(httpOptions, function (res) {
    var bodyarr = [];
    res.on('data', function (chunk) {
      bodyarr.push(chunk);
    });

    res.on('end', function () {
      var responseInfo = {
        code: res.statusCode,
        headers: res.headers
      };
      var data = null;
      if (parseResult === 'json') {
        try {
          var response = bodyarr.join('').trim() === '' ? '{}' : bodyarr.join('').trim();
          data = JSON.parse(response);
        } catch (error) {
          return pack.error('request failed to parse JSON in response' +
          bodyarr.join('') + '\n' + HttpRequestDetails, responseInfo);
        }
      } else if (parseResult === 'binary') {
        data = res;
      }
      return pack.success(data, responseInfo);
    });
  });

  var HttpRequestDetails = 'Request: ' + httpOptions.method + ' ' +
    httpMode + '://' + httpOptions.host + ':' + httpOptions.port + '' + httpOptions.path;

  req.on('error', function (e) {
    return pack.error(e.message + '\n' + HttpRequestDetails);
  });

  req.on('socket', function (socket) {
    socket.setTimeout(30000);
    socket.on('timeout', function () {
      req.abort();
      return pack.error('Timeout' + '\n' + HttpRequestDetails);
    });
  });


  if (pack.payload instanceof FormData) {
    pack.payload.pipe(req);
  } else {
    if (pack.payload) {
      req.write(pack.payload, 'utf8');
    }
  }
  req.end();

  return req;
};

}).call(this,require("buffer").Buffer)
},{"buffer":10,"form-data":26,"underscore":28}],57:[function(require,module,exports){
/* global document */

var urls = module.exports = {};

/**
 * The one and only reference for Pryv domain names.
 * TODO: client and server will merge
 */
urls.defaultDomain = 'pryv.me';


/* jshint -W101 */
/**
 * Extracts base components from a browser URL string
 * (e.g. today: "https://username.pryv.me:443/some/path").
 *
 * @param url Defaults to `document.location` if available
 * @returns {URLInfo}
 */
urls.parseClientURL = function (url) {
  return new URLInfo(url, 'client');
};

/**
 * Extracts base components from a standard Pryv API URL string
 * (e.g. "https://username.pryv.io:443/some/path").
 *
 * @param url
 * @returns {URLInfo}
 */
urls.parseServerURL = function (url) {
  return new URLInfo(url, 'server');
};

/**
 * @param {String} url
 * @param {String} type "client" or "server"
 * @constructor
 */
function URLInfo(url, type) {
  var loc;
  if (typeof document !== 'undefined') {
    // browser
    if (url) {
      loc = document.createElement('a');
      loc.href = url;
    } else {
      loc = document.location;
    }
  } else {
    // node
    if (! url) {
      throw new Error('`url` is required');
    }
    loc = require('url').parse(url);
  }
  if (! (type === 'client' || type === 'server')) {
    throw new Error('`type` must be either "client" or "server"');
  }
  this.type = type;

  this.protocol = loc.protocol;
  this.hostname = loc.hostname;
  this.port = loc.port || (this.protocol === 'https:' ? 443 : 80);
  this.path = loc.pathname;
  this.hash = loc.hash;
  this.search = loc.search;

  var splitHostname = loc.hostname.split('.');
  if (splitHostname.length >= 3 /* TODO: check & remove, shouldn't be necessary && splitHostname[0].match(this.regex.username)*/) {
    this.username = splitHostname[0];
  }
  this.domain = loc.hostname.substr(loc.hostname.indexOf('.') + 1);

}

URLInfo.prototype.isSSL = function () {
  return this.protocol === 'https:';
};

URLInfo.prototype.parseQuery = function () {
  var objURL = {};
  this.search.replace(new RegExp('([^?=&]+)(=([^&]*))?', 'g'), function ($0, $1, $2, $3) {
    objURL[$1] = $3;
  });
  return objURL;
};

URLInfo.prototype.parseSharingTokens = function () {
  if (this.type !== 'client') {
    throw new Error('Can only parse on client URLs');
  }
  var splitPath = this.hash.split('/');
  var sharingsIndex = splitPath.indexOf('sharings');
  if (sharingsIndex !== -1) {
    return splitPath.splice(sharingsIndex + 1).filter(function (s) { return s.length > 0; });
  } else {
    return [];
  }
};

},{"url":105}],58:[function(require,module,exports){
/* global document, navigator */

/**
 * Browser-only utils
 */
var utility = module.exports = {};

utility.getHostFromUrl = function (url) {
  var location;
  if (url) {
    location = document.createElement('a');
    location.href = url;
  } else {
    location = document.location;
  }
  return location.hostname;
};

utility.getPortFromUrl = function (url) {
  var location;
  if (url) {
    location = document.createElement('a');
    location.href = url;
  } else {
    location = document.location;
  }
  return location.port === '' ? null : location.port;
};

utility.isUrlSsl = function (url) {
  var location;
  if (url) {
    location = document.createElement('a');
    location.href = url;
  } else {
    location = document.location;
  }
  return location.protocol === 'https:';
};

/**
 *  List grabbed from
 *  https://github.com/codefuze/js-mobile-tablet-redirect/blob/master/mobile-redirect.js
 *
 *  @return {Boolean} `true` if browser is seen as a mobile or tablet
 */
utility.browserIsMobileOrTablet = function () {
  /* jshint -W101*/
  return (/iphone|ipod|android|blackberry|opera mini|opera mobi|skyfire|maemo|windows phone|palm|iemobile|symbian|symbianos|fennec|ipad|android 3|sch-i800|playbook|tablet|kindle|gt-p1000|sgh-t849|shw-m180s|a510|a511|a100|dell streak|silk/i.test(navigator.userAgent.toLowerCase()));
};

/**
 * Method to get the preferred language, either from desiredLanguage or from the browser settings
 * @method getPreferredLanguage
 * @param {Array} supportedLanguages an array of supported languages encoded on 2characters
 * @param {String} desiredLanguage (optional) get this language if supported
 */
utility.getPreferredLanguage = function (supportedLanguages, desiredLanguage) {
  if (desiredLanguage) {
    if (supportedLanguages.indexOf(desiredLanguage) >= 0) { return desiredLanguage; }
  }
  var lct = null;
  if (navigator.language) {
    lct = navigator.language.toLowerCase().substring(0, 2);
  } else if (navigator.userLanguage) {
    lct = navigator.userLanguage.toLowerCase().substring(0, 2);
  } else if (navigator.userAgent.indexOf('[') !== -1) {
    var start = navigator.userAgent.indexOf('[');
    var end = navigator.userAgent.indexOf(']');
    lct = navigator.userAgent.substring(start + 1, end).toLowerCase();
  }
  if (desiredLanguage) {
    if (lct.indexOf(desiredLanguage) >= 0) { return lct; }
  }

  return supportedLanguages[0];
};


/**
 * //TODO check if it's robust
 * Method to check the browser supports CSS3.
 * @method supportCSS3
 * @return boolean
 */
utility.supportCSS3 = function ()  {
  var stub = document.createElement('div'),
    testProperty = 'textShadow';

  if (testProperty in stub.style) { return true; }

  testProperty = testProperty.replace(/^[a-z]/, function (val) {
    return val.toUpperCase();
  });

  return false;
};

/**
 * Method to load external files like javascript and stylesheet. this version
 * of method only support to file types - js|javascript and css|stylesheet.
 *
 * @method loadExternalFiles
 * @param {String} filename
 * @param {String} type 'js' or 'css'
 */
utility.loadExternalFiles = function (filename, type)  {
  var tag = null;

  type = type.toLowerCase();

  if (type === 'js' || type === 'javascript') {
    tag = document.createElement('script');
    tag.setAttribute('type', 'text/javascript');
    tag.setAttribute('src', filename);
  } else if (type === 'css' || type === 'stylesheet')  {
    tag = document.createElement('link');
    tag.setAttribute('rel', 'stylesheet');
    tag.setAttribute('type', 'text/css');
    tag.setAttribute('href', filename);
  }

  if (tag !== null || tag !== undefined) {
    document.getElementsByTagName('head')[0].appendChild(tag);
  }
};

utility.docCookies = require('./docCookies');

utility.domReady = require('./domReady');

utility.request = require('./request-browser');

},{"./docCookies":52,"./domReady":53,"./request-browser":55}],59:[function(require,module,exports){
/**
 * Node-only utils
 */
var FormData = require('form-data');

var utility = module.exports = {};

utility.request = require('./request-node');


/**
 * Create or complete FormData object for attachements
 * @param id {String} id of the element to add (may be 'attachment0')
 * @param data {Data} the data to send
 * @param options {Object}
 * @param options.filename {String}
 * @param options.type {String}
 */
utility.forgeFormData = function (id, data, options, appendTo) {
  var formData = appendTo || new FormData();
  formData.append(id, data, options);
  return formData;
};
},{"./request-node":56,"form-data":26}],60:[function(require,module,exports){
var socketIO = require('socket.io-client'),
    _ = require('underscore');

var utility = module.exports = {};

/**
 * @returns {Boolean} `true` if we're in a web browser environment
 */
utility.isBrowser = function () {
  return typeof(window) !== 'undefined';
};

utility.SignalEmitter = require('./SignalEmitter.js');

/**
 * Merges two object (key/value map) and remove "null" properties
 *
 * @param {Object} sourceA
 * @param {Object} sourceB
 * @returns {*|Block|Node|Tag}
 */
utility.mergeAndClean = function (sourceA, sourceB) {
  sourceA = sourceA || {};
  sourceB = sourceB || {};
  var result = _.clone(sourceA);
  _.extend(result, sourceB);
  _.each(_.keys(result), function (key) {
    if (result[key] === null) { delete result[key]; }
  });
  return result;
};

/**
 * Creates a query string from an object (key/value map)
 *
 * @param {Object} data
 * @returns {String} key1=value1&key2=value2....
 */
utility.getQueryParametersString = function (data) {
  data = this.mergeAndClean(data);
  return Object.keys(data).map(function (key) {
    if (data[key] !== null) {
      if (_.isArray(data[key])) {
        data[key] = this.mergeAndClean(data[key]);
        var keyE = encodeURIComponent(key + '[]');
        return data[key].map(function (subData) {
          return keyE + '=' + encodeURIComponent(subData);
        }).join('&');
      } else {
        return encodeURIComponent(key) + '=' + encodeURIComponent(data[key]);
      }
    }
  }, this).join('&');
};

utility.regex = require('./regex');

/**
 * Cross-platform string endsWith
 *
 * @param {String} string
 * @param {String} suffix
 * @returns {Boolean}
 */
utility.endsWith = function (string, suffix) {
  return string.indexOf(suffix, string.length - suffix.length) !== -1;
};

utility.ioConnect = function (settings) {
  var httpMode = settings.ssl ? 'https' : 'http';
  var url = httpMode + '://' + settings.host + ':' + settings.port + '' +
      settings.path + '?auth=' + settings.auth + '&resource=' + settings.namespace;

  return socketIO.connect(url, {'force new connection': true});
};

utility.urls = require('./urls');

// platform-specific members
_.extend(utility, utility.isBrowser() ?
    require('./utility-browser.js') : require('./utility-node.js'));

},{"./SignalEmitter.js":51,"./regex":54,"./urls":57,"./utility-browser.js":58,"./utility-node.js":59,"socket.io-client":27,"underscore":28}],61:[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    domain && domain.exit();
                    setTimeout(flush, 0);
                    domain && domain.enter();

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        requestTick = function () {
            channel.port2.postMessage(0);
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
function uncurryThis(f) {
    var call = Function.call;
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
// engine that has a deployed base of browsers that support generators.
// However, SM's generators use the Python-inspired semantics of
// outdated ES6 drafts.  We would like to support ES6, but we'd also
// like to make it possible to use generators in deployed browsers, so
// we also support Python-style generators.  At some point we can remove
// this block.
var hasES6Generators;
try {
    /* jshint evil: true, nonew: false */
    new Function("(function* (){ yield 1; })");
    hasES6Generators = true;
} catch (e) {
    hasES6Generators = false;
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Creates fulfilled promises from non-thenables,
 * Passes Q promises through,
 * Coerces other thenables to Q promises.
 */
function Q(value) {
    return resolve(value);
}

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = deprecate(function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    }, "valueOf", "inspect");

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(resolve(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }

    var deferred = defer();
    fcall(
        resolver,
        deferred.resolve,
        deferred.reject,
        deferred.notify
    ).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = deprecate(function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        });
    }

    return promise;
}

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Promise.prototype.thenResolve = function (value) {
    return when(this, function () { return value; });
};

Promise.prototype.thenReject = function (reason) {
    return when(this, function () { throw reason; });
};

// Chainable methods
array_reduce(
    [
        "isFulfilled", "isRejected", "isPending",
        "dispatch",
        "when", "spread",
        "get", "set", "del", "delete",
        "post", "send", "mapply", "invoke", "mcall",
        "keys",
        "fapply", "fcall", "fbind",
        "all", "allResolved",
        "timeout", "delay",
        "catch", "finally", "fail", "fin", "progress", "done",
        "nfcall", "nfapply", "nfbind", "denodeify", "nbind",
        "npost", "nsend", "nmapply", "ninvoke", "nmcall",
        "nodeify"
    ],
    function (undefined, name) {
        Promise.prototype[name] = function () {
            return Q[name].apply(
                Q,
                [this].concat(array_slice(arguments))
            );
        };
    },
    void 0
);

Promise.prototype.toSource = function () {
    return this.toString();
};

Promise.prototype.toString = function () {
    return "[object Promise]";
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var unhandledReasonsDisplayed = false;
var trackUnhandledRejections = true;
function displayUnhandledReasons() {
    if (
        !unhandledReasonsDisplayed &&
        typeof window !== "undefined" &&
        !window.Touch &&
        window.console
    ) {
        console.warn("[Q] Unhandled rejection reasons (should be empty):",
                     unhandledReasons);
    }

    unhandledReasonsDisplayed = true;
}

function logUnhandledReasons() {
    for (var i = 0; i < unhandledReasons.length; i++) {
        var reason = unhandledReasons[i];
        if (reason && typeof reason.stack !== "undefined") {
            console.warn("Unhandled rejection reason:", reason.stack);
        } else {
            console.warn("Unhandled rejection reason (no stack):", reason);
        }
    }
}

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;
    unhandledReasonsDisplayed = false;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;

        // Show unhandled rejection reasons if Node exits without handling an
        // outstanding rejection.  (Note that Browserify presently produces a
        // `process` global without the `EventEmitter` `on` method.)
        if (typeof process !== "undefined" && process.on) {
            process.on("exit", logUnhandledReasons);
        }
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    unhandledReasons.push(reason);
    displayUnhandledReasons();
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    if (typeof process !== "undefined" && process.on) {
        process.removeListener("exit", logUnhandledReasons);
    }
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisP, args) {
            return value.apply(thisP, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
Q.resolve = resolve;
function resolve(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return resolve(object).inspect();
    });
}

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(promise, fulfilled, rejected) {
    return when(promise, function (valuesOrPromises) {
        return all(valuesOrPromises).then(function (values) {
            return fulfilled.apply(void 0, values);
        }, rejected);
    }, rejected);
}

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            if (hasES6Generators) {
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return result.value;
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return exception.value;
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "send");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q.resolve(a), Q.resolve(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    var deferred = defer();
    nextTick(function () {
        resolve(object).promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
}

/**
 * Constructs a promise method that can be used to safely observe resolution of
 * a promise for an arbitrarily named method like "propfind" in a future turn.
 *
 * "dispatcher" constructs methods like "get(promise, name)" and "set(promise)".
 */
Q.dispatcher = dispatcher;
function dispatcher(op) {
    return function (object) {
        var args = array_slice(arguments, 1);
        return dispatch(object, op, args);
    };
}

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = dispatcher("get");

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = dispatcher("set");

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q["delete"] = // XXX experimental
Q.del = dispatcher("delete");

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
var post = Q.post = dispatcher("post");
Q.mapply = post; // experimental

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = send;
Q.invoke = send; // synonyms
Q.mcall = send; // experimental
function send(value, name) {
    var args = array_slice(arguments, 2);
    return post(value, name, args);
}

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = fapply;
function fapply(value, args) {
    return dispatch(value, "apply", [void 0, args]);
}

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] = fcall; // XXX experimental
Q.fcall = fcall;
function fcall(value) {
    var args = array_slice(arguments, 1);
    return fapply(value, args);
}

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = fbind;
function fbind(value) {
    var args = array_slice(arguments, 1);
    return function fbound() {
        var allArgs = args.concat(array_slice(arguments));
        return dispatch(value, "apply", [this, allArgs]);
    };
}

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = dispatcher("keys");

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(promise, function (value) {
                    promises[index] = value;
                    if (--countDown === 0) {
                        deferred.resolve(promises);
                    }
                }, deferred.reject);
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, resolve);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Q.allSettled = allSettled;
function allSettled(values) {
    return when(values, function (values) {
        return all(array_map(values, function (value, i) {
            return when(
                value,
                function (fulfillmentValue) {
                    values[i] = { state: "fulfilled", value: fulfillmentValue };
                    return values[i];
                },
                function (reason) {
                    values[i] = { state: "rejected", reason: reason };
                    return values[i];
                }
            );
        })).thenResolve(values);
    });
}

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q["catch"] = // XXX experimental
Q.fail = fail;
function fail(promise, rejected) {
    return when(promise, void 0, rejected);
}

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(promise, progressed) {
    return when(promise, void 0, void 0, progressed);
}

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q["finally"] = // XXX experimental
Q.fin = fin;
function fin(promise, callback) {
    return when(promise, function (value) {
        return when(callback(), function () {
            return value;
        });
    }, function (exception) {
        return when(callback(), function () {
            return reject(exception);
        });
    });
}

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = done;
function done(promise, fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);

            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promiseToHandle = fulfilled || rejected || progress ?
        when(promise, fulfilled, rejected, progress) :
        promise;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }
    fail(promiseToHandle, onUnhandledError);
}

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = timeout;
function timeout(promise, ms, msg) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error(msg || "Timed out after " + ms + " ms"));
    }, ms);

    when(promise, function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
}

/**
 * Returns a promise for the given value (or promised value) after some
 * milliseconds.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after some
 * time has elapsed.
 */
Q.delay = delay;
function delay(promise, timeout) {
    if (timeout === void 0) {
        timeout = promise;
        promise = void 0;
    }

    var deferred = defer();

    when(promise, undefined, undefined, deferred.notify);
    setTimeout(function () {
        deferred.resolve(promise);
    }, timeout);

    return deferred.promise;
}

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = nfapply;
function nfapply(callback, args) {
    var nodeArgs = array_slice(args);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    fapply(callback, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 *
 *      Q.nfcall(FS.readFile, __filename)
 *      .then(function (content) {
 *      })
 *
 */
Q.nfcall = nfcall;
function nfcall(callback/*, ...args */) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    fapply(callback, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 *
 *      Q.nfbind(FS.readFile, __filename)("utf-8")
 *      .then(console.log)
 *      .done()
 *
 */
Q.nfbind = nfbind;
Q.denodeify = Q.nfbind; // synonyms
function nfbind(callback/*, ...args */) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());

        fapply(callback, nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
}

Q.nbind = nbind;
function nbind(callback, thisArg /*, ... args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());

        function bound() {
            return callback.apply(thisArg, arguments);
        }

        fapply(bound, nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
}

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.npost = npost;
Q.nmapply = npost; // synonyms
function npost(object, name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());

    post(object, name, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = nsend;
Q.ninvoke = Q.nsend; // synonyms
Q.nmcall = Q.nsend; // synonyms
function nsend(object, name /*, ...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    post(object, name, nodeArgs).fail(deferred.reject);
    return deferred.promise;
}

Q.nodeify = nodeify;
function nodeify(promise, nodeback) {
    if (nodeback) {
        promise.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return promise;
    }
}

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)
},{"_process":23,"timers":103}],62:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],63:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],64:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":62,"./encode":63}],65:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":66}],66:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":68,"./_stream_writable":70,"core-util-is":12,"inherits":17,"process-nextick-args":22}],67:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":69,"core-util-is":12,"inherits":17}],68:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":66,"./internal/streams/BufferList":71,"./internal/streams/destroy":72,"./internal/streams/stream":73,"_process":23,"core-util-is":12,"events":13,"inherits":17,"isarray":74,"process-nextick-args":22,"safe-buffer":75,"string_decoder/":76,"util":7}],69:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":66,"core-util-is":12,"inherits":17}],70:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":66,"./internal/streams/destroy":72,"./internal/streams/stream":73,"_process":23,"core-util-is":12,"inherits":17,"process-nextick-args":22,"safe-buffer":75,"timers":103,"util-deprecate":107}],71:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":75,"util":7}],72:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":22}],73:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":13}],74:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],75:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":10}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":75}],77:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":78}],78:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":66,"./lib/_stream_passthrough.js":67,"./lib/_stream_readable.js":68,"./lib/_stream_transform.js":69,"./lib/_stream_writable.js":70}],79:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":78}],80:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":70}],81:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":10}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":13,"inherits":17,"readable-stream/duplex.js":65,"readable-stream/passthrough.js":77,"readable-stream/readable.js":78,"readable-stream/transform.js":79,"readable-stream/writable.js":80}],83:[function(require,module,exports){
(function (global){
var ClientRequest = require('./lib/request')
var response = require('./lib/response')
var extend = require('xtend')
var statusCodes = require('builtin-status-codes')
var url = require('url')

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/request":85,"./lib/response":86,"builtin-status-codes":11,"url":105,"xtend":111}],84:[function(require,module,exports){
(function (global){
exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],85:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var response = require('./response')
var stream = require('readable-stream')

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
        body = new Blob(self._body, {
            type: (headersObj['content-type'] || {}).value || ''
        });
    }

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":84,"./response":86,"_process":23,"buffer":10,"inherits":17,"readable-stream":101}],86:[function(require,module,exports){
(function (process,global,Buffer){
var capability = require('./capability')
var inherits = require('inherits')
var stream = require('readable-stream')

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(Buffer.from(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(Buffer.from(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text':
			response = xhr.responseText
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = Buffer.alloc(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./capability":84,"_process":23,"buffer":10,"inherits":17,"readable-stream":101}],87:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],88:[function(require,module,exports){
(function (process){
'use strict'

var experimentalWarnings = new Set();

function emitExperimentalWarning(feature) {
  if (experimentalWarnings.has(feature)) return;
  var msg = feature + ' is an experimental feature. This feature could ' +
       'change at any time';
  experimentalWarnings.add(feature);
  process.emitWarning(msg, 'ExperimentalWarning');
}

function noop() {}

module.exports.emitExperimentalWarning = process.emitWarning
  ? emitExperimentalWarning
  : noop;

}).call(this,require('_process'))
},{"_process":23}],89:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this,require('_process'))
},{"./_stream_readable":91,"./_stream_writable":93,"_process":23,"inherits":17}],90:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":92,"inherits":17}],91:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

var _require2 = require('../experimentalWarning'),
    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;

require('inherits')(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    emitExperimentalWarning('Readable[Symbol.asyncIterator]');

    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":87,"../experimentalWarning":88,"./_stream_duplex":89,"./internal/streams/async_iterator":94,"./internal/streams/buffer_list":95,"./internal/streams/destroy":96,"./internal/streams/state":99,"./internal/streams/stream":100,"_process":23,"buffer":10,"events":13,"inherits":17,"string_decoder/":102,"util":7}],92:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":87,"./_stream_duplex":89,"inherits":17}],93:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":87,"./_stream_duplex":89,"./internal/streams/destroy":96,"./internal/streams/state":99,"./internal/streams/stream":100,"_process":23,"buffer":10,"inherits":17,"util-deprecate":107}],94:[function(require,module,exports){
(function (process){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this,require('_process'))
},{"./end-of-stream":97,"_process":23}],95:[function(require,module,exports){
'use strict';

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  var _proto = BufferList.prototype;

  _proto.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  _proto.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  _proto.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  _proto.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  _proto.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  _proto.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  } // Consumes a specified amount of bytes or characters from the buffered data.
  ;

  _proto.consume = function consume(n, hasStrings) {
    var ret;

    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    return ret;
  };

  _proto.first = function first() {
    return this.head.data;
  } // Consumes a specified amount of characters from the buffered data.
  ;

  _proto._getString = function _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Consumes a specified amount of bytes from the buffered data.
  ;

  _proto._getBuffer = function _getBuffer(n) {
    var ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Make sure the linked list only shows the minimal necessary information.
  ;

  _proto[custom] = function (_, options) {
    return inspect(this, _objectSpread({}, options, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  };

  return BufferList;
}();
},{"buffer":10,"util":7}],96:[function(require,module,exports){
(function (process){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      process.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      process.nextTick(emitErrorAndCloseNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
}).call(this,require('_process'))
},{"_process":23}],97:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":87}],98:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":87,"./end-of-stream":97}],99:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":87}],100:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73,"events":13}],101:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":89,"./lib/_stream_passthrough.js":90,"./lib/_stream_readable.js":91,"./lib/_stream_transform.js":92,"./lib/_stream_writable.js":93,"./lib/internal/streams/end-of-stream.js":97,"./lib/internal/streams/pipeline.js":98}],102:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76,"safe-buffer":81}],103:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":23,"timers":103}],104:[function(require,module,exports){
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the 
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from an array.
  // If **n** is not specified, returns a single random element from the array.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (arguments.length < 2 || guard) {
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = new Date();
      var later = function() {
        var last = (new Date()) - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],105:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":106,"punycode":9,"querystring":64}],106:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],107:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],108:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],109:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],110:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":109,"_process":23,"inherits":108}],111:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],112:[function(require,module,exports){
/* global $, window, document, location, i18n, moment, localStorage, Blob*/
var MonitorsHandler = require('./model/MonitorsHandler.js'),
    _ = require('underscore'),
    ConnectionsHandler = require('./model/ConnectionsHandler.js'),
    SIGNAL = require('./model/Messages').MonitorsHandler.SIGNAL,
    TreeMap = require('./tree/TreeMap.js'),
    Controller = require('./orchestrator/Controller.js'),
    PanelMenu = require('./view/left-panel/Controller.js'),
    Pryv = require('pryv'),
    TimeLine = require('./timeframe-selector/timeframe-selector.js'),
    UnknownUserView = require('./view/error/unknown-user.js'),
    PUBLIC_TOKEN = 'public',
    CALLERID_SEPARATOR_CLIENT = '+',
    CALLERID_SEPARATOR_API = ' ',
    themes = require('./themes/index'),
    toShowWhenLoggedIn = ['.logo-sharing', 'nav #addEvent', '.logo-create-sharing',
      'nav #togglePanel', 'nav #settings', 'nav #connectApps'],
    toShowSubscribe = ['nav #toMyPryv', 'nav #togglePanel'];

// temp fix for jQuery not being setup properly in Backbone/Marionette with Browserify
// probable references:
// - https://github.com/jashkenas/backbone/issues/2997
// - https://github.com/jashkenas/backbone/pull/3038
require('backbone').$ = $;
require('backbone.marionette').$ = $;

var Model = module.exports = function () {  //setup env with grunt
  window.Pryv = Pryv;

  Pryv.eventTypes.loadFlat(function (err) {
    if (err) {
      console.warn('Could not load event types from network: ' + err);
    }
  });

  var urlInfo = Pryv.utility.urls.parseClientURL();

  this.urlSharings = urlInfo.parseSharingTokens();
  this.queryString = urlInfo.parseQuery();
  if (this.queryString.sharing) {
    this.urlSharings = [this.queryString.sharing];
  }
  this.urlUsername = this.queryString.username || urlInfo.username;
  this.personalToken = this.queryString.personalToken;

  // --- domain customisation space ----- //
  this._applyThemeIfAny(this.queryString.theme);


  localStorage.setItem('skipOnboarding', true);
  if (urlInfo.domain === 'pryv.li') {
    localStorage.setItem('skipOnboarding', false);
  }
  if (urlInfo.domain === 'pryv.me') {
    localStorage.setItem('skipOnboarding', false);
  }

  this.urlDomain = this.queryString.domain || urlInfo.domain;

  Pryv.utility.urls.defaultDomain = this.urlDomain;

  testUsername(this.urlUsername, this.urlDomain);

  if (this.urlUsername && urlInfo.hash.toLowerCase().split('/').indexOf('signin') !== -1) {
    $('#login-username').val(this.urlUsername);
    this.openLogin();
  }

  this.publicConnection = null;
  this.loggedConnection = null;
  this.sharingsConnections = null;
  this.bookmakrsConnections = null;
  this.hideLoggedInElement();


  if (this.urlSharings.length > 0) {
    this.sharingsConnections = [];
    this.urlSharings.forEach(function (token) {
      var sharingToken = formatSharingURI(token);
      this.sharingsConnections.push(new Pryv.Connection(
        this.urlUsername, sharingToken, {}));
    }.bind(this));
    this.setTimeframeScale(this.sharingsConnections[0]);
    $('.logo-subscribe').show();
  } else if (this.urlUsername) {
    this.publicConnection =  new Pryv.Connection(
      this.urlUsername, PUBLIC_TOKEN, {});
  }

  // create connection handler and filter
  this.onFiltersChanged = function (from, to) {
    this.activeFilter.timeFrameLT = [new Date(from * 1000), new Date(to * 1000)];
  };

  this.onDateHighlighted = _.throttle(function () {
    if (this.treemap) {
      this.treemap.onDateHighLighted(arguments[0]);
    }
  }, 100);

  this.initBrowser = function () {
    this.connections = new ConnectionsHandler(this);
    this.activeFilter = new MonitorsHandler(this);
    var batchCount = 0;
    this.activeFilter.addEventListener(SIGNAL.BATCH_BEGIN, function () {
      batchCount++;
      $('#logo-reload').addClass('loading');
    });
    this.activeFilter.addEventListener(SIGNAL.BATCH_DONE, function () {
      batchCount--;
      if (batchCount === 0) {
        $('#logo-reload').removeClass('loading');
      }
    });
    this.timeView = TimeLine;
    this.timeView.init();
    initTimeAndFilter(this.timeView, this.activeFilter);
    this.timeView.on('timeBoundsChanged', this.onFiltersChanged.bind(this));
    this.timeView.on('highlightChanged', this.onDateHighlighted.bind(this));
    this.timeView.on('dateMasked', this.onDateMasked, this);

    this.onDateMasked = function () {
      // console.log('onDateMasked', arguments);
    };

    Pryv.eventTypes.loadExtras(function (err) {
      if (err) {
        console.warn('Could not load event extras from network: ' + err);
      }
    });

    // create the TreeMap
    this.controller = new Controller();
    this.treemap = new TreeMap(this);
    this.controller.setTreeMap(this.treemap);
  };
  // ----------------------- //

  // Sign in

  var settings = {
    appId : 'pryv-browser',
    username: this.urlUsername,
    callbacks : {
      signedIn: this.signedIn.bind(this),
      signedOut: function (connection) {
        this.hideLoggedInElement();
        this.treemap.closeViews();
        this.removeConnection(connection);
        this.removeConnections(this.bookmakrsConnections);
        if (this.publicConnection) {
          this.addConnection(this.publicConnection);
        }
        $('#login-button').html('<i class="ss-login"></i> ' + i18n.t('nav.actions.signIn'));
        this.loggedConnection = null;

        if (localStorage) {
          localStorage.removeItem('username');
          localStorage.removeItem('auth');
          localStorage.removeItem('domain');
          localStorage.removeItem('returnUrl');
          localStorage.removeItem('welcome');
        }
      }.bind(this),
      refused: function (reason) {
        console.log('** REFUSED! ' + reason);
      },
      error: function (data) {
        data.error = data.error || data;
        if (data.error && data.error.message && data.error.message !== 'Not signed-on') {
          $('#login form button[type=submit]').prop('disabled', false)
            /*.addClass('btn-pryv-alizarin')*/;
          $('#login form button[type=submit] .fa-spinner').hide();
          window.PryvBrowser.showAlert('#login', i18n.t('error.login.' + data.error.id));
        } else if (!data.error) {
          $('#login form button[type=submit]').prop('disabled', false)
            /*.addClass('btn-pryv-alizarin')*/;
          $('#login form button[type=submit] .fa-spinner').hide();
          window.PryvBrowser.showAlert('#login', i18n.t('error.login.unknown-username'));

        }
      }
    }
  };
  if (this.publicConnection) {
    this.addConnection(this.publicConnection);
  } else if (this.sharingsConnections) {
    this.sharingsConnections.forEach(function (connection) {
      this.addConnection(connection);
    }.bind(this));
  }
  if (this.personalToken) {
     //skip login and force home connection
    settings.callbacks.signedIn(new Pryv.Connection(this.urlUsername, this.personalToken, {
      ssl: true,
      domain: this.urlDomain
    }));
  } else {
    whoAmIReplace(function(connection) {
      if (connection) {
        settings.callbacks.signedIn(connection, true);
      }
    }.bind(this));
  }

  $('nav #togglePanel').click(function () {
    this.togglePanel(function () {
      $(window).trigger('resize');
    });
  }.bind(this));
  $('#sign-out').click(function () {
    if (this.loggedConnection) {
      this.loggedConnection.request({
        method: 'POST',
        path: '/auth/logout',
        callback: function (error) {
          if (error && typeof(settings.callbacks.error) === 'function') {
            return settings.callbacks.error(error);
          } else if (!error && typeof(settings.callbacks.signedOut) === 'function') {
            return settings.callbacks.signedOut(this);
          }
        }.bind(this)
      });
      setPersonalTokenAsDomainCookie(null);
    }
  }.bind(this));
  $('#login-button').click(function (e) {
    if (this.loggedConnection) {
      $('#login-dropdown .dropdown-menu').css('opacity', 1);
    } else {
      e.stopPropagation();
      $('#login-dropdown .dropdown-menu').css('opacity', 0);
      this.openLogin();
    }
  }.bind(this));
  $('#login-caret').click(this.closeLogin);
  $('#login form').submit(function (e) {
    e.preventDefault();
    if (this.loggedConnection) {
      console.warn('You are already logged in, please log out');
      return;
    }
    $('#login form button[type=submit]').prop('disabled', true);
    $('#login form button[type=submit] .fa-spinner').css('display', 'inherit');
    settings.username = $('#login-username').val().trim().toLowerCase();
    settings.password = $('#login-password').val();
    Pryv.Auth.login(settings);
  }.bind(this));
};

Model.prototype._applyThemeIfAny = function (themeId) {
  if (! themeId) { return; }

  var theme = this.theme = themes[themeId.toLowerCase()];
  if (! theme) { return; }

  $('<link rel="stylesheet" type="text/css" href="themes/' + theme.id + '/style.css">')
      .appendTo('head');
  if (theme.appName) {
    document.title = theme.appName;
  }
  if (theme.favicon) {
    $('<link rel="shortcut icon" href="themes/' + theme.id + '/' + theme.favicon + '">')
        .appendTo('head');
  }
};

Model.prototype.setTimeframeScale = function (connection) {
  if (!this.timeView) {
    return setTimeout(function () {
      this.setTimeframeScale(connection);
    }.bind(this), 500);
  }
  var urlInfo = Pryv.utility.urls.parseClientURL(location.href);
  var  params = urlInfo.parseQuery();
  if (params.scale) {
    var scale = params.scale;
    if (scale === 'day' || scale === 'week' || scale === 'month' || scale === 'year') {
      var from;
      if (params.from) {
        from = parseInt(params.from);
      }
      this.timeView.setScale(scale, from);

    }
  } else {
    connection.events.get({state: 'default', limit: 1},
      function (error, events) {
        if (events && events[0]) {
          var eventTime = events[0].time;
          if (moment().startOf('week').unix() <= eventTime) {
            this.timeView.setScale('week');
          } else if (moment().startOf('month').unix() <= eventTime) {
            this.timeView.setScale('month');
          } else if (moment().startOf('year').unix() <= eventTime) {
            this.timeView.setScale('year');
          }
        }
      }.bind(this));
  }
};

Model.prototype.signedIn = function (connection, withCookie) {
  $('#login form button[type=submit]').prop('disabled', false);
  $('#login form button[type=submit] .fa-spinner').hide();
  console.log('Successfully signed in', connection);
  this.loggedConnection = connection;


  $('#login-button').html(connection.username + ' <i class="ss-navigatedown"></i>');
  this.loggedConnection.account.getInfo(function (error, result) {
    if (!error && result && result.email) {
      $('#login-button').prepend('<img  class="gravatar" src="https://www.gravatar.com/avatar/' +
         result.email.md5() +
        '" />');
    }
  });
  if (! withCookie) {
    setPersonalTokenAsDomainCookie(
      this.loggedConnection.username,
      this.loggedConnection.auth,
      this.loggedConnection.settings.domain,
      'pryv-browser'
    );
  }
  if (localStorage) {
    localStorage.setItem('username', this.loggedConnection.username);
    localStorage.setItem('auth', this.loggedConnection.auth);
    localStorage.setItem('domain', this.loggedConnection.settings.domain);
    localStorage.setItem('returnUrl', location.href);
  }
  if (!this.urlUsername || this.urlUsername === connection.username) {// logged into your page
    this.showLoggedInElement();
    $('.logo-subscribe').hide();
    if (this.sharingsConnections && this.sharingsConnections.length === 1 &&
      this.sharingsConnections[0] === this.publicConnection) {
      this.sharingsConnections = null;
    }
    if (!this.sharingsConnections) {
      this.addConnection(connection);
      this.setTimeframeScale(connection);
      if (this.publicConnection) {
        this.removeConnection(this.publicConnection);
      }
      connection.bookmarks.get(function (error, result) {
        if (!error) {
          this.bookmakrsConnections = result;
          this.addConnections(this.bookmakrsConnections);
        }
      }.bind(this));
    }
    this.treemap.isOnboarding();
  } else {
    if (!this.sharingsConnections && this.publicConnection) {
      this.sharingsConnections = [];
      this.sharingsConnections.push(this.publicConnection);
    }

    this.showSubscribeElement();
    $('.logo-subscribe').show();
  }
  this.closeLogin();
};

Model.prototype.addConnection = function (connection) {
  if (!this.treemap) {
    this.initBrowser();
  }
  if (!connection._accessInfo) {
    connection.accessInfo();
  }
  if (!connection._privateProfile) {
    connection.privateProfile();
  }
  var userConnection = this.connections.add(connection),
    batch = this.activeFilter.startBatch('adding connections');
  this.activeFilter.addConnection(userConnection, batch);
  batch.done();
};

Model.prototype.addConnections = function (connections) {
  _.each(connections, function (conn) {
    this.addConnection(conn);
  }.bind(this));
};

Model.prototype.removeConnection = function (connection) {
  this.activeFilter.removeConnections(connection.serialId);
};

Model.prototype.removeConnections = function (connections) {
  _.each(connections, function (conn) {
    this.removeConnection(conn);
  }.bind(this));
};

/**
 * demo utility that set the timeFrame boundaries to the events displayed.
 */
Model.prototype.updateTimeFrameLimits = function () {
  (_.debounce(function () {
    this.activeFilter.stats(false, function () {
     // this.timeView.setLimit(stats.timeFrameLT[0] - 3600, stats.timeFrameLT[1] + 3600);
    }.bind(this));
  }.bind(this), 100))();
};

Model.prototype.showLoggedInElement = function () {
  this.renderPanel(this);
  $(toShowWhenLoggedIn.join(',')).show();
};

Model.prototype.showSubscribeElement = function () {
  this.renderPanel(this);
  var home = location.origin.replace(this.urlUsername, this.loggedConnection.username);
  $('nav #toMyPryv a').attr('href', home);
  $(toShowSubscribe.join(',')).show();
};

Model.prototype.hideLoggedInElement = function () {
  this.renderPanel(this);
  $(toShowWhenLoggedIn.join(',')).hide();
  $(toShowSubscribe.join(',')).hide();
  $('.logo-subscribe').hide();
};

Model.prototype.togglePanel = function (callback) {
  var opened = $('#main-container').data('panel-opened');
  if (opened) {
    this.closePanel(callback);
  } else {
    this.openPanel(callback);
  }
};

Model.prototype.openPanel = function (callback) {
  var callbackCalled = false;
  var $container = $('#main-container');
  this.renderPanel(this);
  $container.addClass('slideRight').data('panel-opened', true);
  if (_.isFunction(callback)) {
    $container.one(
      'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd',
      function () {
        if (!callbackCalled && typeof(callback) === 'function') {
          callbackCalled = true;
          callback();
        }
      });
  }
};

Model.prototype.closePanel = function (callback) {
  var callbackCalled = false;
  var $container = $('#main-container');
  $container.removeClass('slideRight').data('panel-opened', false);
  if (_.isFunction(callback)) {
    $container.one(
      'transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd',
      function () {
        if (!callbackCalled && typeof(callback) === 'function') {
          callbackCalled = true;
          callback();
        }
      });
  }
};

Model.prototype.renderPanel = function () {
  PanelMenu.render(this);
};

function initTimeAndFilter(timeView, filter) {
  var fromTime = new Date(timeView.getTimeBounds().from * 1000),
      toTime = new Date(timeView.getTimeBounds().to * 1000);
  filter.timeFrameLT = [fromTime, toTime];
  filter.set({
    limit: 50000
  });
}

function testUsername(username, domain) {
  $.post('https://reg.' + domain + '/' + username + '/server')
    .fail(function () {
    $('body').html(UnknownUserView);
    $('body').i18n();
  });
}

// Make sure that the caller id is sent to the API alongside the sharing token
// by replacing the client separator with the one expected by the API
function formatSharingURI(sharingURI) {
  var sharing = sharingURI.replace(CALLERID_SEPARATOR_CLIENT, CALLERID_SEPARATOR_API);
  return decodeURIComponent(sharing);
}

Model.prototype.closeLogin = function () {
  var $login = $('#login');
  var $tree = $('#tree');
  var $timeframeContainer = $('#timeframeContainer');
  var $nav = $('nav');
  $nav.animate({'top': '0px'});
  $timeframeContainer.animate({'bottom': '0px'});
  $login.removeClass('animated slideInRight');
  $tree.removeClass('animated slideOutLeft');
  $login.addClass('animated slideOutRight');
  $tree.addClass('animated slideInLeft');
  if (detectIE()) {
    $login.fadeOut('slow', function () {
      $tree.fadeIn('slow');
    });
  }
  $login.data('opened', false);
};

Model.prototype.openLogin = function () {
  var $login = $('#login');
  var $tree = $('#tree');
  var $timeframeContainer = $('#timeframeContainer');
  var $nav = $('nav');

  $login.css('display', 'block');
  $('#login form button[type=submit] .fa-spinner').hide();
  $login.removeClass('animated slideOutRight');
  $tree.removeClass('animated slideInLeft');
  $login.addClass('animated slideInRight');
  $tree.addClass('animated slideOutLeft');
  $nav.animate({'top': -$nav.height() + 'px'});
  $timeframeContainer.animate({'bottom': -$timeframeContainer.height() + 'px'});
  if (detectIE()) {
    $tree.fadeOut('slow', function () {
      $login.fadeIn('slow');
    });
  }
  $login.data('opened', true);
};

function detectIE() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf('MSIE ');
  var trident = ua.indexOf('Trident/');

  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  if (trident > 0) {
    // IE 11 (or newer) => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  // other browser
  return false;
}

// TODO: cleanup this mess of having both window.pryvBrowser (ie. Model.js) and window.PryvBrowser
//       (a big bag of utility and miscellaneous properties every component seems to freely extend)

/**
 * Notifies the error reporting service of the given error.
 *
 * @param {Error} error
 * @param {Object} context
 */
window.PryvBrowser.reportError = function (error, context) {
  if (! window.Airbrake) {
    console.error('Airbrake not loaded; cannot report error: ' + error.message);
    return;
  }
  window.Airbrake.push({
    error: error,
    // TODO: extend context with username, access name etc.
    context: context,
    environment: {
      'navigator.vendor': window.navigator.vendor
    }
  });
};

window.PryvBrowser.showAlert = function (containerSelector, html) {
  alertMsg('alert-danger', containerSelector, html);
};

window.PryvBrowser.showSuccess = function (containerSelector, html) {
  alertMsg('alert-success', containerSelector, html);
};

function alertMsg(severity, containerSelector, html) {
  $('.alert').alert('close');
  var $container = $(containerSelector);
  $container.append('<div class="alert '+severity+' ">' +
    '<button type="button" class="close" data-dismiss="alert" aria-hidden="true">&times;</button>' +
    html + '</div>');
}

// HACK: make utilities globally available for access from templates

window.PryvBrowser.dateTime = require('./utility/dateTime');

window.PryvBrowser.streamUtils = require('./utility/streamUtils');

/* jshint -W101 */
/**
 * Event type utilities
 * TODO: this should be abstracted and split into type-specific plugins
 * follow-up: https://trello.com/c/0P6lmhsS/299-as-a-dev-i-need-event-type-specific-components-to-be-properly-abstracted
 */
window.PryvBrowser.eventTypes = {
  isNote: function (event) {
    if (! event) { return false; }
    var t = event.type;
    return (t === 'note/txt' || t === 'note/text');
  },

  isNumerical: function (event) {
    return Pryv.eventTypes.isNumerical(event);
  },

  isPicture: function (event) {
    if (! event) { return false; }
    var t = event.type;
    return (t === 'note/txt' || t === 'note/text');
  },

  isPosition: function (event) {
    if (! event) { return false; }
    var t = event.type;
    return (t === 'note/txt' || t === 'note/text');
  }
};

window.PryvBrowser.renderNote = function (content, options) {
  var marked = require('marked');
  options = _.extend({sanitize: true}, options);
  marked.setOptions(options);
  return marked(content);
};




// download selected data as csv
function selectionToCSV() {
  //var events = window.pryvBrowser.treemap.events;

  var events = [];
  window.pryvBrowser.activeFilter.triggerForAllCurrentEvents(function (x, y) { 
    y.events.forEach(function (e) { events.push(e); });
  });


  var props = ['username', 'connectionInfo', 'streamName', 'streamId', 'time', 'duration', 'type', 'content', 'tags', 'description',
    'clientData', 'state', 'trashed', 'tags',
    'created', 'createdBy', 'modified', 'modifiedBy', 'attachments'];


  var rows = [];
  rows.push(props);


  for (var eventId in events ) {
    if (!events.hasOwnProperty(eventId)) { continue; }
    var event =   events[eventId];



    var row = [
      '"' + event.connection.username + '"',
      '"' + event.connection._accessInfo.name + '"',
      '"' + event.connection.datastore.getStreamById(event.streamId).name  + '"'
    ];

    for (var i = 3; i < props.length; i++) {
      var l =  JSON.stringify(event[props[i]]) || '';
      row.push('"' +  l.replace(/"/g, '""') + '"');
    }

    rows.push(row);

  }

  var csv = '';
  rows.forEach(function(row) {
    //var l = JSON.stringify(row);
    //csv += l.substring(1,l.length - 1) + '\r\n';
    csv += row.join(',') +  '\r\n';
  });

  console.log('Created a CSV file with: ' + rows.length + 'rows');
  return csv;

}



function download_csv2(csv) {
  var blob = new Blob([csv]);
  if (window.navigator.msSaveOrOpenBlob) { // IE hack; see http://msdn.microsoft.com/en-us/library/ie/hh779016.aspx
    window.navigator.msSaveBlob(blob, 'Pryv_export.csv');
  }
  else
  {
    var a = window.document.createElement('a');
    a.href = window.URL.createObjectURL(blob, {type: 'text/csv;charset=utf-8'});
    a.download = 'Pryv_export.csv';
    document.body.appendChild(a);
    a.click();  // IE: "Access is denied"; see: https://connect.microsoft.com/IE/feedback/details/797361/ie-10-treats-blob-url-as-cross-origin-and-denies-access
    document.body.removeChild(a);
  }
}

// shortcut command


function showOnlyOwner() {
  window.pryvBrowser.treemap.focusOnConnections(window.pryvBrowser.loggedConnection);
}


function showOnlyShared() {
  var followed = [];
  window.pryvBrowser.activeFilter._eachMonitor(function (monitor) { 
    if (monitor.connection !== window.pryvBrowser.loggedConnection) {
      followed.push(monitor.connection);
    }
  });
  window.pryvBrowser.treemap.focusOnConnections(followed);
}


window.onmessage = function (e) {
  var b = $('#pryv-modal');
  if (b) { b.hide(); }
  window.pryvBrowser.treemap.closeViews();
  $('.modal-backdrop').remove();

  if (e.data === 'settings') {
    $('nav #settings').click();
  }

  if (e.data === 'sharings') {
    $('.logo-sharing').click();
  }

  if (e.data === 'sharedata') {
    showOnlyShared();
  }

  if (e.data === 'owner') {
    showOnlyOwner();
  }

  if (e.data === 'toCSV') {
    download_csv2(selectionToCSV());
  }

  console.log('#####>> ' + e.data);
};


// ------------------------------------------------
// who-am-i replacement with client side cookies
// ------------------------------------------------


function whoAmIReplace(callbackOnSuccessOnly) {
  var pryvSSO = getPersonalTokenFromDomainCookie();

  if (pryvSSO) { // test if valid
    window.Pryv.utility.request({
      method: 'GET',
      host: pryvSSO.username + '.' + pryvSSO.domain,
      path: '/access-info',
      ssl: true,
      headers: {'Authorization': pryvSSO.auth},
      success: function (data) {
        console.log(data);
        if (data && data.type && data.type === 'personal') {
          callbackOnSuccessOnly(new window.Pryv.Connection({
            username: pryvSSO.username,
            domain: pryvSSO.domain,
            ssl: true,
            auth: pryvSSO.auth,
          }));
        }
      }
    });
  }
}


function getPersonalTokenFromDomainCookie() {
  return getDomainCookie('pryvsso');
}

function setPersonalTokenAsDomainCookie(username, auth, domain, appId) {
  var value = username ?  {username: username, auth: auth, domain: domain, appId: appId} : null;
  setDomainCookie('pryvsso',value);
}

function setDomainCookie(cname, value) {
  console.log(value);
  var myDate = new Date();
  var hostName = window.location.hostname;
  var domain = hostName.substring(
    hostName.lastIndexOf('.', hostName.lastIndexOf('.') - 1) + 1);
  myDate.setMonth(myDate.getMonth() + 12);
  document.cookie = cname + '=' + encodeURIComponent(JSON.stringify(value)) +
    ';expires=' + myDate +
    ';domain=.' + domain + ';path=/';
}


function getDomainCookie(cname) {
  var name = cname + '=';
  var decodedCookie = decodeURIComponent(document.cookie);
  var ca = decodedCookie.split(';');
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) === ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) === 0) {
      try {
        return JSON.parse(c.substring(name.length, c.length));
      } catch (e) {
        console.log('Error while parsing cookie: ' + cname);
      }
    }
  }
  return null;
}
},{"./model/ConnectionsHandler.js":113,"./model/Messages":114,"./model/MonitorsHandler.js":115,"./orchestrator/Controller.js":116,"./themes/index":117,"./timeframe-selector/timeframe-selector.js":118,"./tree/TreeMap.js":123,"./utility/dateTime":133,"./utility/streamUtils":135,"./view/error/unknown-user.js":143,"./view/left-panel/Controller.js":186,"backbone":5,"backbone.marionette":3,"marked":19,"pryv":50,"underscore":104}],113:[function(require,module,exports){

//TODO write all add / remove connection logic

var ConnectionsHandler = module.exports = function (model) {
  this.model = model;
  this._connections = {};
};

/**
 * @param connection
 * @param andInitializeCallBack (optional) if function(error, connection) { } is defined,
 * the handler will try to initialize the connection
 * @returns {string} serialNumber to access this connection
 */
ConnectionsHandler.prototype.add = function (connection, andInitializeCallBack) {

  this._connections[connection.serialId] = connection;

  if (andInitializeCallBack) {
    connection.fetchStructure(function (error/*, accessInfo*/) {
      // TODO correctly deal with this error
      if (error) { console.log(error); }
      andInitializeCallBack(error, connection);
    });
  }

  return connection.serialId;
};

/**
 * get the connection form it's ID
 * @param connectionSerialId
 * @param andInitializeCallBack (optional) if function(error, connection) { } is defined,
 * the handler will try to initialize the connection
 * @returns {Pryv.Connection} the connection that matches this serial
 */
ConnectionsHandler.prototype.get = function (connectionSerialId, andInitializeCallBack) {
  var connection = this._connections[connectionSerialId];
  if (andInitializeCallBack) {
    if (! connection) {
      andInitializeCallBack('Cannot find connection with serialId: ' + connectionSerialId, null);
      return null;
    }
    connection.fetchStructure(function (error/*, accessInfo*/) {
      // TODO correctly deal with this error
      if (error) { console.log(error); }
      andInitializeCallBack(error, connection);
    });
  }
  return connection;
};



},{}],114:[function(require,module,exports){

var Messages = module.exports = { };

var SignalEmitter = require('pryv').utility.SignalEmitter;
Messages.MonitorsHandler = {
  UNREGISTER_LISTENER : SignalEmitter.Messages.UNREGISTER_LISTENER,
  SIGNAL : {
    /** called when a batch of changes is expected, content: <batchId> unique**/
    BATCH_BEGIN : SignalEmitter.Messages.BATCH_BEGIN,
    /** called when a batch of changes is done, content: <batchId> unique**/
    BATCH_DONE : SignalEmitter.Messages.BATCH_DONE,

    /** called when events Enter Scope, content: {reason: one of .., content: array of Event }**/
    EVENT_SCOPE_ENTER : 'eventEnterScope',
    STREAM_SCOPE_ENTER : 'streamEnterScope',
    EVENT_SCOPE_LEAVE : 'eventLeaveScope',
    STREAM_SCOPE_LEAVE : 'streamLeaveScope',
    EVENT_CHANGE : 'eventChange',
    STREAM_CHANGE : 'streamChange',

    /** filtered streams changed **/
    FILTERED_STREAMS_CHANGE: 'filteredStreamsChange'

  },
  REASON : {
    EVENT_SCOPE_ENTER_ADD_CONNECTION : 'connectionAdded',
    EVENT_SCOPE_LEAVE_REMOVE_CONNECTION : 'connectionRemoved',
    REMOTELY : 'remotely',
    // may happend when several refresh requests overlaps
    FORCE : 'forced',

    FILTER_STREAMS_CHANGED : 'streamsChanged'
  }
};
},{"pryv":50}],115:[function(require,module,exports){

var _ = require('underscore');
var Filter = require('pryv').Filter;
var Pryv = require('pryv');
var MSGs = require('./Messages').MonitorsHandler;


/**
 * Handle multiple monitors and map Pryv.Filter properties
 * @type {Function}
 */
var MonitorsHandler = module.exports = function (model, batchSetKeyValues) {
  Pryv.utility.SignalEmitter.extend(this, MSGs.SIGNAL, 'MonitorsHandler');
  this.model = model;
  this._monitors = {}; // serialIds / monitor
  this.rootFilter = new Filter();
  this.connectionToRemove = [];
  if (batchSetKeyValues) {
    this.set(batchSetKeyValues);
  }
};



// ----------------------------- Generic Event fire ------------------ //

MonitorsHandler.prototype._eventsEnterScope = function (reason, events, batch) {
  if (events.length === 0) { return; }
  this._fireEvent(MSGs.SIGNAL.EVENT_SCOPE_ENTER, {reason: reason, events: events}, batch);
};

MonitorsHandler.prototype._eventsLeaveScope = function (reason, events, batch) {
  if (events.length === 0) { return; }
  this._fireEvent(MSGs.SIGNAL.EVENT_SCOPE_LEAVE, {reason: reason, events: events}, batch);
};

MonitorsHandler.prototype._eventsChange = function (reason, events, batch) {
  if (events.length === 0) { return; }
  this._fireEvent(MSGs.SIGNAL.EVENT_CHANGE, {reason: reason, events: events}, batch);
};
MonitorsHandler.prototype._streamsEnterScope = function (reason, streams, batch) {
  if (streams.length === 0) { return; }
  this._fireEvent(MSGs.SIGNAL.STREAM_SCOPE_ENTER, {reason: reason, streams: streams}, batch);
};

MonitorsHandler.prototype._streamsLeaveScope = function (reason, streams, batch) {
  if (streams.length === 0) { return; }
  this._fireEvent(MSGs.SIGNAL.STREAM_SCOPE_LEAVE, {reason: reason, streams: streams}, batch);
};

MonitorsHandler.prototype._streamsChange = function (reason, message, batch) {
  var streams = message.streams;
  if (streams.length === 0) { return; }
  this._fireEvent(MSGs.SIGNAL.STREAM_CHANGE,
    {reason: reason, streams: streams,
      modifiedPreviousProperties:
        message.modifiedPreviousProperties}, batch);
};


MonitorsHandler.prototype._filteredStreamsChange = function (streams, batch) {
  this._fireEvent(MSGs.SIGNAL.FILTERED_STREAMS_CHANGE, streams, batch);
};



// ----------------------------- Events from monitors ------------------ //

MonitorsHandler.prototype._onMonitorEventChange = function (changes, batch) {
  var myBatch = this.startBatch('eventChange', batch);
  this._eventsEnterScope(MSGs.REASON.REMOTELY, changes.created, myBatch);
  this._eventsLeaveScope(MSGs.REASON.REMOTELY, changes.trashed, myBatch);
  this._eventsChange(MSGs.REASON.REMOTELY, changes.modified, myBatch);
  myBatch.done();
};
MonitorsHandler.prototype._onMonitorStreamChange = function (changes) {
  this._streamsEnterScope(MSGs.REASON.REMOTELY, changes.created);
  this._streamsLeaveScope(MSGs.REASON.REMOTELY, changes.trashed);
  this._streamsLeaveScope(MSGs.REASON.REMOTELY, changes.deleted);
  this._streamsChange(MSGs.REASON.REMOTELY,
    { streams: changes.modified, modifiedPreviousProperties: changes.modifiedPreviousProperties});
};

MonitorsHandler.prototype._onMonitorFilterChange = function (changes, batch) {
  var myBatch = this.startBatch('filterChange', batch);
  this._eventsEnterScope(changes.filterInfos.signal, changes.enter, myBatch);
  this._eventsLeaveScope(changes.filterInfos.signal, changes.leave, myBatch);
  myBatch.done();
};


// ----------------------------- CONNECTIONS -------------------------- //


/**
 * get all events that match this filter
 */
MonitorsHandler.prototype.addConnection = function (connectionSerialId, batch) {
  var batchWaitForMe = batch ?
    batch.waitForMeToFinish('addConnection ' + connectionSerialId) : null;
  if (_.has(this._monitors, connectionSerialId)) {
    console.log('Warning MonitorsHandler.addConnection, already activated: ' + connectionSerialId);
    return;
  }
  var connection = this.model.connections.get(connectionSerialId);
  if (! connection) { // TODO error management
    console.log('MonitorsHandler.addConnection cannot find connection: ' + connectionSerialId);
    return;
  }

  // be sure localstorage is activated
  connection.fetchStructure(function (useLocalStorageError) {
    console.log('fetchStructure', arguments);
    if (useLocalStorageError) {
      console.error('failed activating localStorage for ' + connection.id);
      if (batchWaitForMe) { batchWaitForMe.done(); }
      return;
    }
    var connectionIndex = this.connectionToRemove.indexOf(connection.serialId);
    if (connectionIndex !== -1) {
      this.connectionToRemove[connectionIndex] = null;
      if (batchWaitForMe) { batchWaitForMe.done(); }
      return;
    }
    var filterSettings = _.omit(this.rootFilter.getData(), 'streams'); //copy everything but Streams
    var specificFilter = new Filter(filterSettings);
    specificFilter._xerialId =  'F' + connection.serialId;

    var monitor = connection.monitor(specificFilter);
    this._monitors[connectionSerialId] = monitor;

    // ----- add listeners
    function onMonitorOnLoad(events) {
      this._eventsEnterScope(MSGs.REASON.EVENT_SCOPE_ENTER_ADD_CONNECTION, events, batch);
      if (batchWaitForMe) { batchWaitForMe.done(); } // called only once at load
    }
    monitor.addEventListener('started', onMonitorOnLoad.bind(this));

    monitor.addEventListener('eventsChanged', this._onMonitorEventChange.bind(this));
    monitor.addEventListener('streamsChanged', this._onMonitorStreamChange.bind(this));
    monitor.addEventListener('filterChanged', this._onMonitorFilterChange.bind(this));

    monitor.start(function (error) {
      console.log('monitor started ' + error);
    });
  }.bind(this));
};


/**
 * remove a connection from the list
 */
MonitorsHandler.prototype.removeConnections = function (connectionSerialId, batch) {
  var myBatch = this.startBatch('removeConnections', batch);
  if (! _.isArray(connectionSerialId)) { connectionSerialId = [connectionSerialId];  }
  _.each(connectionSerialId, function (connectionId) {

    var monitor = this._monitors[connectionId];
    if (! monitor) {
      if (this.connectionToRemove.indexOf(connectionId) === -1) {
        this.connectionToRemove.push(connectionId);
      }
      myBatch.done();
      return;
    }

   // this.focusOnStreams([]);
    var self = this;
    var maxCloseTry = 100;
    var closeMonitor = function () {
      if (monitor.getEvents().length > 0) {
        self._eventsLeaveScope(MSGs.REASON.EVENT_SCOPE_LEAVE_REMOVE_CONNECTION,
          monitor.getEvents(), myBatch);
        delete self._monitors[connectionId];
        monitor.destroy();
        myBatch.done();
      } else if (maxCloseTry > 0) {
        maxCloseTry--;
        _.delay(closeMonitor, 100);
      }
    };
    closeMonitor();

  }.bind(this));


};

/**
 * focus on those connections....
 * Technically we set all monitors Filters to []
 */
MonitorsHandler.prototype.focusOnConnections = function (connections) {

  // un-focus
  if (connections === null) {   // same than focusOnConnections
    return this.focusOnStreams(null, batch);
  }

  if (! _.isArray(connections)) { connections = [connections];  }
  // create an array of connectionsIds
  var connectionsIds = [];
  _.each(connections, function (connection) { connectionsIds.push(connection.id); });


  var batch = this.startBatch('focusOnConnections');
  this._eachMonitor(function (monitor) {
    if (connectionsIds.indexOf(monitor.connection.id) < 0) {
      monitor.filter.set({'streamsIds': []}, batch); // shush the connection
    } else {
      monitor.filter.set({'streamsIds': null}, batch); // show all streams
    }
  });
  batch.done();
};






/**
 * get all events actually matching this filter
 */
MonitorsHandler.prototype.triggerForAllCurrentEvents = function (trigger) {
  this._eachMonitor(function (monitor) {
    trigger(MSGs.SIGNAL.EVENT_SCOPE_ENTER,
      {reason: MSGs.REASON.EVENT_SCOPE_ENTER_ADD_CONNECTION,
        events: monitor.getEvents()});
  });
};

// --------- Utils -----

/** execute for each filter **/
MonitorsHandler.prototype._eachMonitor = function (callback) {
  _.each(this._monitors, callback.bind(this));
};

// --------- Filter manipulations -----------------//

// # Streams

/**
 * get the actual streams in the filter;
 * @returns {Array}
 */
MonitorsHandler.prototype.getStreams = function () {
  var result = [];
  this._eachMonitor(function (monitor) {
    _.each(monitor.filter.streamsIds, function (streamId) {
      result.push(monitor.connection.datastore.getStreamById(streamId));
    });
  });
  return result;
};




/**
 * focus on those streams;
 */
MonitorsHandler.prototype.focusOnStreams = function (streams) {

  // un-focus
  if (streams === null) {
    var batchU = this.startBatch('un-focusOnStream');
    this._eachMonitor(function (monitor) {  // clear all
      monitor.filter.set({'streamsIds' : null}, batchU);
    });
    this._filteredStreamsChange(streams, batchU);
    batchU.done();
    return 1;
  }


  if (! _.isArray(streams)) { streams = [streams];  }
  // --- order the streams by connection
  // (note that streams not in current connection pool will be ignored without warning)
  var streamsByConnection = {};
  _.each(streams, function (stream) {
    if (! _.has(streamsByConnection, stream.connection.serialId)) {
      streamsByConnection[stream.connection.serialId] = [];
    }
    streamsByConnection[stream.connection.serialId].push(stream.id);
  });




  var batch = this.startBatch('focusOnStream');
  this._eachMonitor(function (monitor, key) {  // clear all
    if (_.has(streamsByConnection, key)) {
      monitor.filter.set({'streamsIds': streamsByConnection[key]}, batch);
    } else {
      monitor.filter.set({'streamsIds': []}, batch); // shush the connection
    }
  });
  this._filteredStreamsChange(streams, batch);
  batch.done();
};

// # Bind filter properties to rootFilter
Object.defineProperty(MonitorsHandler.prototype, 'timeFrameLT', {
  set: function (newValue) {
    var to = newValue[0] ? newValue[0].getTime() / 1000 : null;
    var from = newValue[1] ? newValue[1].getTime() / 1000 : null;
    this.timeFrameST = [to, from];
  }
});

_.each(['timeFrameST', 'limit'],  function (prop) {
  Object.defineProperty(MonitorsHandler.prototype, prop, {
    get: function () {
      return this.rootFilter[prop];
    },
    set: function (newValue) {
      this.rootFilter[prop] = newValue;
      this._eachMonitor(function (monitor) {
        monitor.filter[prop] = newValue;
      });
    }
  });
});

// -- use this to bind function of filters
_.each(['set'],  function (func) {
  MonitorsHandler.prototype[func] = function () {
    var myargs = arguments;
    this._eachMonitor(function (monitor) {
      monitor.filter[func].apply(monitor.filter, myargs);
    });
    return this.rootFilter[func].apply(this.rootFilter, myargs);
  };
});




// ............ CLEANUP OR REUSE ................................  //


// ----------------------------- EVENTS --------------------------- //

/**
 * return informations on events
 */
MonitorsHandler.prototype.stats = function (force, callback) {
  var result = {
    timeFrameLT : [null, null]
  };
  var monitorNbr = _.size(this._monitors);
  this._eachMonitor(function (monitor) {
    monitor.stats(force, function (timeLimits) {
      var tf = timeLimits.timeFrameLT;
      if (! result.timeFrameLT[0] || tf[0] < result.timeFrameLT[0]) {
        result.timeFrameLT[0] = tf[0];
      }
      if (! result.timeFrameLT[1] || tf[1] > result.timeFrameLT[1]) {
        result.timeFrameLT[1] = tf[1];
      }
      monitorNbr--;
      if (monitorNbr === 0 && _.isFunction(callback)) {
        callback(result);
      }
    });
  });
};
},{"./Messages":114,"pryv":50,"underscore":104}],116:[function(require,module,exports){

var Controller = module.exports = function () {
  this.treeMap = null;
  this.menu = null;
};

Controller.prototype.setTreeMap = function (treemap) {
  this.treeMap = treemap;
};

Controller.prototype.onDragAndDrop =
  function (thisNode, thatNodeId, thatStreamId, thatConnectionId) {
  var thatNode = this.treeMap.getNodeById(thatNodeId, thatStreamId, thatConnectionId);
  console.log('Controller', thatNode);
  //this.showFusionDialog(thatNodeId.data, thatNode.data, function () {}.bind(this));

};

Controller.prototype.showFusionDialog =
  function () {
  console.log('Controller:', 'Show fusion dialog');
};



},{}],117:[function(require,module,exports){
var _ = require('underscore');

/**
 * Theme definitions.
 * Properties for each theme:
 * - `id`: must be lowercase and match the theme's folder name
 * - `appName` (optional): used e.g. to override the page title
 * - `favicon` (optional): the favicon's relative path from the theme's folder (e.g. "favicon.ico")
 */
module.exports = _.reduce([
  {
    id: 'domo',
    appName: 'Domo Safety',
    favicon: 'favicon.png'
  }
], function (map, theme) { map[theme.id] = theme; return map; }, {});

},{"underscore":104}],118:[function(require,module,exports){
/* global $, document, i18n, window, moment */
var _ = require('underscore');
module.exports = (function () {
  var CONTAINER = '#timeframeContainer';
  var MARGIN = {
    left: 0,
    right: 0
  };
  var HIGHLIGHT_MARGIN = {
    left: 90,
    right: 90
  };
  var HIGHLIGHT_SIZE = 180;
  var DATE_FORMAT = {
    'day': {
      'selected': 'D.M.YYYY',
      'others': 'D'
    },
    'month': {
      'selected': 'MMM YYYY',
      'others': 'MMM'
    },
    'week': {
      'selected': 'D.M.YYYY',
      'others': 'D.M'
    },
    'year': {
      'selected': 'YYYY',
      'others': 'YYYY'
    },
    'custom': {
      'selected': 'D.M.YYYY LT'
    },
    'all': {
      'selected': 'D.M.YYYY LT'
    }
  };
  var DATE_SIZE = {
    'day': {
      'selected': 140,
      'others': 70
    },
    'month': {
      'selected': 140,
      'others': 90
    },
    'week': {
      'selected': 150,
      'others': 90
    },
    'year': {
      'selected': 100,
      'others': 90
    },
    'custom': {
      'selected': 500
    }
  };
  var _isInit = false;
  var _callbacks;
  var _from;
  var _to;
  var _scale;
  var _highlight;
  var _mode; // 'timeSelection' || 'highlight'
  var init = function () {
    if (_isInit === true) {
      return;
    }
    _isInit = true;
    moment.lang(i18n.lng());
    _mode = 'timeSelection';
    _callbacks = {};
    _initTimeFrame();
  };
  var _initHtml = function () {
    $(CONTAINER).html('<div id="timeframe" style="margin-left: ' + MARGIN.left +
        'px; margin-right: ' + MARGIN.right + 'px;"><div id="upperLayout"></div>' +
        '<div id="datesContainer"><div id="dates"></div></div>' +
        '<div id="scalesContainer" class="btn-toolbar">' +
        '<div id="scales" class="btn-group btn-group-xs">' +
        '<a href="javascript:void(0)" class="btn btn-default timeScale"' +
        'data-timeScale="day" data-i18n="timeframe.labels.day"></a>' +
        '<a href="javascript:void(0)" class="btn btn-default timeScale selected"' +
        'data-timeScale="week" data-i18n="timeframe.labels.week"></a>' +
        '<a href="javascript:void(0)" class="btn btn-default timeScale"' +
        'data-timeScale="month" data-i18n="timeframe.labels.month"></a>' +
        '<a href="javascript:void(0)" class="btn btn-default timeScale"' +
        'data-timeScale="year" data-i18n="timeframe.labels.year"></a>' +
        '</div>' +
        '<div class="btn-group btn-group-xs">' +
        '<a href="javascript:void(0)" id="custom" class="btn btn-default timeScale"' +
        'data-timeScale="custom" data-i18n="timeframe.labels.custom"></a>' +
        '</div>' +
        '</div>' +
        '</div>');
    $('#custom').popover({
      html: true,
      placement: 'top',
      container: 'body',
      content: function () {
        return $('<form class="form-horizontal">' +
            '<div class="form-group">' +
            '  <label for="fromPicker">' + i18n.t('timeframe.labels.fromTime') + '</label>' +
            '  <div class="input-group date picker" id="fromPicker">' +
            '    <input type="text" class="form-control"/> ' +
            '    <span id="fromButton" class="input-group-addon">' +
            '      <span class="fa fa-calendar"></span>' +
            '    </span>' +
            '  </div>' +
            '</div>' +
            '<div class="form-group">' +
            '  <label for="fromPicker">' + i18n.t('timeframe.labels.toTime') + '</label>' +
            '  <div class="input-group date picker" id="toPicker">' +
            '    <input type="text" class="form-control"/> ' +
            '    <span id="toButton" class="input-group-addon">' +
            '      <span class="fa fa-calendar"></span>' +
            '    </span>' +
            '  </div>' +
            '</div>' +
            '<button type="button" id="cancel" ' +
            'class="btn btn-default col-md-4"  style="float: none">' +
                i18n.t('common.actions.cancel') + '</button>' +

            '<button type="button" id="ok" class="btn btn-default col-md-7 col-md-offset-1"' +
            ' style="float: none">' +
                i18n.t('timeframe.actions.go') + '</button>' +
            '</form>').html();
      }
    });
    $('#custom').on('hidden.bs.popover', function () {
      $('.bootstrap-datetimepicker-widget.dropdown-menu').remove();
    });
    $('#custom').on('shown.bs.popover', function () {
      var fromDate = moment.unix(_from),
          toDate = moment.unix(_to);
      $(document.body).off('click', '#ok');
      $(document.body).on('click', '#ok', function () {
        fromDate = moment(fromDate);
        toDate = moment(toDate);
        if (fromDate.isValid() && toDate.isValid() && fromDate.unix() <= toDate.unix()) {
          $('#custom').popover('toggle');
          _scale = 'custom';
          setTimeBounds(fromDate, toDate);
          _updateDateScale();
        }
      });
      $(document.body).off('click', '#cancel');
      $(document.body).on('click', '#cancel', function () {
        $('#custom').popover('toggle');
      });
      $(document.body).off('click', '#fromButton');
      $(document.body).on('click', '#fromButton', function () {
        fromDate = moment();
        $('#fromButton').trigger('click');
      });

      $(document.body).off('click', '#fromPicker input');
      $(document.body).on('click', '#fromPicker input', function () {
        fromDate = moment();
        $('#fromButton').trigger('click');
      });
      $(document.body).off('click', '#toButton');
      $(document.body).on('click', '#toButton', function () {
        toDate = moment();
        $('#toButton').trigger('click');
      });

      $(document.body).off('click', '#toPicker');
      $(document.body).on('click', '#toPicker input', function () {
        toDate = moment();
        $('#toButton').trigger('click');
      });
      $('#fromPicker').datetimepicker({
        direction: 'auto',
        language: i18n.lng()
      });
      $('#fromPicker').on('dp.change', function (e) {
        fromDate = e.date;
      });
      $('#toPicker').datetimepicker({
        direction: 'auto',
        language: i18n.lng()
      });
      $('#toPicker').on('dp.change', function (e) {
        toDate = e.date;
      });
      $('#fromPicker').data('DateTimePicker').setDate(fromDate);
      $('#toPicker').data('DateTimePicker').setDate(toDate);
    });
  };
  var _updateDateScale = function () {
    var containerWidth = $(CONTAINER).width();
    var $dates = $('#dates');
    var $datesMargin, $datesWidth;
    moment.lang(i18n.lng());
    if (_scale === 'custom') {
      $('.timeScale').removeClass('selected');
      $('#custom').addClass('selected');
      $datesWidth = DATE_SIZE[_scale].selected;
      $datesMargin = ((containerWidth - MARGIN.left - MARGIN.right) - $datesWidth) / 2;
      $dates.empty();
      $dates.css({
        'width': $datesWidth + 'px',
        'margin-left': $datesMargin + 'px'
      });
      $dates.append('<li class="timeItem selected" style="width: ' + DATE_SIZE[_scale].selected +
          'px;">' + moment.unix(_from).format(DATE_FORMAT[_scale].selected) + ' - ' +
          moment.unix(_to).format(DATE_FORMAT[_scale].selected) + '</li>');
      $('.timeItem.selected').click(_openHighlight);
      if (_mode === 'highlight') {
        _mode = 'timeline';
        _openHighlight();
      }
      return;
    }

    var nbrToDisplay = Math.floor((containerWidth - MARGIN.left - MARGIN.right -
        DATE_SIZE[_scale].selected) / (DATE_SIZE[_scale].others * 2));

    $datesWidth = (nbrToDisplay * 4 * DATE_SIZE[_scale].others) + DATE_SIZE[_scale].selected;
    // use margin to center dates
    $datesMargin = -($datesWidth - (containerWidth - MARGIN.left - MARGIN.right)) / 2;
    $dates.empty();
    for (var i = 0; i < nbrToDisplay * 2; i++) {
      $dates.prepend('<li class="timeItem" style="width: ' + DATE_SIZE[_scale].others + 'px;">' +
          moment.unix(_from).subtract(_scale, i + 1).format(DATE_FORMAT[_scale].others) + '</li>');
    }
    $dates.append('<li class="timeItem selected" style="width: ' + DATE_SIZE[_scale].selected +
        'px;">' + moment.unix(_from).format(DATE_FORMAT[_scale].selected) + '</li>');
    for (var j = 0; j < nbrToDisplay * 2; j++) {
      $dates.append('<li class="timeItem" style="width: ' + DATE_SIZE[_scale].others + 'px;">' +
          moment.unix(_from).add(_scale, j + 1).format(DATE_FORMAT[_scale].others) + '</li>');
    }
    $dates.css({
      'width': $datesWidth + 'px',
      'margin-left': $datesMargin + 'px'
    });
    $('.timeItem').off();
    $('.timeItem.selected').click(_openHighlight);
    $('.timeItem').click(_changeTime);
    if (_mode === 'highlight') {
      _mode = 'timeline';
      _openHighlight();
    }
  };

  var _changeTime = function () {
    var clickedIndex = $(this).index();
    var totalIndex = $('.timeItem').length;
    var centerIndex = (totalIndex - 1) / 2;
    var diff = centerIndex - clickedIndex;
    if (diff === 0) {
      return;
    }
    if (_mode === 'highlight') {
      return;
    }
    var c = centerIndex + 1;
    $('.timeItem:nth-child(' + c + ')').html(moment.unix(_from)
            .format(DATE_FORMAT[_scale].others))
        .css('width', DATE_SIZE[_scale].others).removeClass('selected');
    var $dates = $('#dates');
    if (diff > 0) {
      // add before and remove last
      c = clickedIndex + 1;
      $('.timeItem:nth-child(' + c + ')')
          .html(moment.unix(_from).subtract(_scale, diff).format(DATE_FORMAT[_scale].selected))
          .css('width', DATE_SIZE[_scale].selected).addClass('selected');
      var d = diff + 1;
      $('.timeItem:gt(-' + d + ')').remove();
      for (var i = 0; i < diff; i++) {
        $('<li class="timeItem" style="width: ' + DATE_SIZE[_scale].others + 'px;">' +
          moment.unix(_from).subtract(_scale, totalIndex - centerIndex + i)
          .format(DATE_FORMAT[_scale].others) + '</li>').hide().prependTo('#dates').animate({
            width: 'toggle'
          });
      }
      setTimeBounds(moment.unix(_from)
          .subtract(_scale, diff).startOf(_scale),
          moment.unix(_to).subtract(_scale, diff).endOf(_scale));
    } else {
      // remove before and add last

      c = clickedIndex + 1;
      $('.timeItem:nth-child(' + c + ')').html(moment.unix(_from).add(_scale, -diff)
              .format(DATE_FORMAT[_scale].selected))
          .css('width', DATE_SIZE[_scale].selected).addClass('selected');



      $('.timeItem:lt(' + -diff + ')').animate({
        width: 'toggle'
      }, {
        complete: function () {
          $(this).remove();
        }
      });

      for (var j = 0; j < -diff; j++) {
        $dates.append('<li class="timeItem" style="width: ' + DATE_SIZE[_scale].others + 'px;">' +
            moment.unix(_from).add(_scale, totalIndex - centerIndex + j)
            .format(DATE_FORMAT[_scale].others) + '</li>');
      }
      setTimeBounds(moment.unix(_from).add(_scale, -diff)
          .startOf(_scale), moment.unix(_to).add(_scale, -diff).endOf(_scale));
    }
    $('.timeItem').off();
    $('.timeItem.selected').click(_openHighlight);
    $('.timeItem').click(_changeTime);
  };
  var _changeScale = function (e, scale, from) {
    var $scale;
    if (scale && $('[data-timescale=' + scale + ']').length > 0) {
      $scale = $('[data-timescale=' + scale + ']');
    } else {
      $scale = $(this);
      scale = $scale.attr('data-timeScale');
    }
    if (scale === _scale || scale === 'custom') {
      return;
    }
    if (from) {
      _from = from;
      _to = from;
    }
    $('.timeScale').removeClass('selected');
    $scale.addClass('selected');
    if (scale === 'day') {
      if ((_scale === 'custom') || (moment().unix() >= moment.unix(_from).unix() &&
          moment().unix() <= moment.unix(_to).unix())) {
        setTimeBounds(moment().startOf('day'), moment().endOf('day'));
      } else {
        setTimeBounds(moment.unix(_from).startOf('day'), moment.unix(_from).endOf('day'));
      }
      _scale = 'day';
    } else if (scale === 'week') {
      if ((_scale === 'custom') || (moment().unix() >= moment.unix(_from).unix() &&
          moment().unix() <= moment.unix(_to).unix())) {
        setTimeBounds(moment().startOf('week'), moment().endOf('week'));
      } else {
        setTimeBounds(moment.unix(_from).startOf('week'), moment.unix(_from).endOf('week'));
      }
      _scale = 'week';
    } else if (scale === 'month') {
      if ((_scale === 'custom') || (moment().unix() >= moment.unix(_from).unix() &&
          moment().unix() <= moment.unix(_to).unix())) {
        setTimeBounds(moment().startOf('month'), moment().endOf('month'));
      } else {
        setTimeBounds(moment.unix(_from).startOf('month'), moment.unix(_from).endOf('month'));
      }
      _scale = 'month';
    } else if (scale === 'year') {
      if ((_scale === 'custom') || (moment().unix() >= moment.unix(_from).unix() &&
          moment().unix() <= moment.unix(_to).unix())) {
        setTimeBounds(moment().startOf('year'), moment().endOf('year'));
      } else {
        setTimeBounds(moment.unix(_from).startOf('year'), moment.unix(_from).endOf('year'));
      }
      _scale = 'year';
    }
    _updateDateScale();
  };
  // set time frame to current month and highlight to now
  var _initTimeFrame = function () {
    _scale = 'week';
    setTimeBounds(moment().startOf('week'),
        moment().endOf('week'));

    _initHtml();
    _updateDateScale();
    $('.timeScale').click(_changeScale);
    $(window).resize(_.debounce(_updateDateScale, 500));

  };

  var marginOffset;
  var widthOffset;
  var _openHighlight = function () {
    if (_mode === 'highlight') {
      return;
    }
    _mode = 'highlight';
    var html = $('<div class="highlight popover bottom"><div class="arrow"></div>' +
        '<div class="content"></div><span class="fa fa-times"></span></div>');
    $('.timeItem.selected').append(html.fadeIn());
    $('.highlight').width(HIGHLIGHT_SIZE);
    $('.highlight .fa-times').off().click(_closeHighlight);
    $('#dates').css('overflow', 'visible');
    var containerWidth = $('#timeframe').width();
    var width = containerWidth - HIGHLIGHT_MARGIN.left - HIGHLIGHT_MARGIN.right;
    marginOffset = (width - DATE_SIZE[_scale].selected) / 2;
    widthOffset = width - DATE_SIZE[_scale].selected;
    $('.timeScale').fadeOut();
    $('.timeItem.selected').animate({
      width: width
    });
    $('#dates').animate({
      'margin-left': '-=' + marginOffset + 'px',
      'width': '+=' + widthOffset + 'px'
    });

    //init position of highlighter
    var left = 100 * (_highlight - _from) / (_to - _from);
    $('.highlight').css('left', left + '%');
    $('.highlight .content').text(moment.unix(_highlight).format('lll'));
    //init drag
    $('.highlight').draggable({containment: 'parent', axis: 'x', drag: _onHighlightDrag});
  };
  var _onHighlightDrag = function (e, object) {
    var left = object.position.left;
    var width = $('.timeItem.selected').width();
    var newHighlight = _from + ((left / width) * (_to - _from));
    setHighlight(moment.unix(newHighlight));
    $('.highlight .content').text(moment.unix(newHighlight).format('lll'));
  };
  var _closeHighlight = function (e) {
    if (_mode !== 'highlight') {
      return;
    }
    e.stopPropagation();
    _mode = 'timeline';
    $('.highlight').fadeOut(function () {
      $(this).remove();
    });
    $('.timeScale').fadeIn();
    $('.timeItem.selected').animate({
      width: DATE_SIZE[_scale].selected
    });
    $('#dates').animate({
      'margin-left': '+=' + marginOffset + 'px',
      'width': '-=' + widthOffset + 'px'
    });
  };
  var _updateHighlight = function () {
    var now = moment().unix();
    var highlight;
    if (now >= _from && now <= _to) {
      highlight = moment();
    } else if (now <= _from) {
      highlight = moment.unix(_from);
    } else if (now >= _to) {
      highlight = moment.unix(_to);
    }
    setHighlight(highlight);
  };
  var setScale = function (scale, from) {
    _changeScale(null, scale, from);
  };
  var setHighlight = function (time) {
    init();
    if (moment(time).isValid()) {
      _highlight = moment(time).unix();
      trigger('highlightChanged', _highlight);
    } else {
      console.warn('setHighlight(): invalid argument', time);
    }
  };
  var setTimeBounds = function (from, to) {
    init();
    if (moment(from).isValid() && moment(to).isValid() && moment(from).unix() < moment(to).unix()) {
      _from = moment(from).unix();
      _to = moment(to).unix();
      trigger('timeBoundsChanged', _from, _to);
      _updateHighlight();
    } else {
      console.warn('setTimeBounds(): invalid argument', from, to);
    }
  };
  var getTimeBounds = function () {
    return {
      from: _from,
      to: _to
    };
  };
  var on = function (event, callback) {
    init();
    if (event && typeof (event) === 'string' && callback && typeof (callback) === 'function') {
      if (!_callbacks[event]) {
        _callbacks[event] = [];
      }
      _callbacks[event].push(callback);
    }
  };
  var off = function (event, callback) {
    init();
    if (!event || typeof (event) !== 'string') {
      _callbacks = {};
    } else {
      if (callback && typeof (callback) === 'function' && _callbacks[event]) {
        for (var i = 0; i < _callbacks[event].length; ++i) {
          if (_callbacks[event][i] === callback) {
            _callbacks[event][i] = null;
          }
        }
      } else if (!callback && _callbacks[event]) {
        _callbacks[event] = [];
      }
    }
  };
  var trigger = function () {
    init();
    var event = arguments[0];
    var args = _.toArray(arguments).slice(1);
    if (_callbacks[event]) {
      _callbacks[event].forEach(function (cb) {
        if (cb && typeof (cb) === 'function') {
          cb.apply(null, args);
        }
      });
    }
  };


  var oPublic = {
    init: init,
    getScale: function () { return _scale; },
    setScale: setScale,
    setTimeBounds: setTimeBounds,
    getTimeBounds: getTimeBounds,
    setHighlight: setHighlight,
    on: on,
    off: off,
    trigger: trigger
  };
  return oPublic;
})();

},{"underscore":104}],119:[function(require,module,exports){

var _ = require('underscore'),
    TreeNode = require('./TreeNode'),
    StreamNode = require('./StreamNode'),
    VirtualNode = require('./VirtualNode.js'),
    Pryv = require('pryv'),
    streamUtils = require('../utility/streamUtils');

var STREAM_MARGIN = 20;
var SERIAL = 0;
var STREAM_COLORS = ['#1abc9c', '#2ecc71', '#3498db', '#9b59b6',
  '#34495e', '#f1c40f', '#e74c3c', '#e67e22', '#95a5a6'];
/**
 * Always call intStructure after creating a new ConnectionNode
 * @type {*}
 */
var ConnectionNode = module.exports = TreeNode.implement(
  function (parentnode, connection) {
    TreeNode.call(this, parentnode.treeMap, parentnode);
    this.connection = connection;
    this.streamNodes = {};
    this.virtNodeWaiting = {};
    this.waitForStream = {};
    this.waitForParentStream = {};
    this.margin = STREAM_MARGIN;
    this.offset = 25;
    this.uniqueId = 'node_connection_' + SERIAL;
    SERIAL++;
  }, {
    className: 'ConnectionNode',

    // ---------------------------------- //


    /**
     * Build Structure
     * @param callback
     * @param options
     */
    initStructure: function (options, callback) {

      options = options || {};
      this.streamNodes = {};


      /* Set color to root stream is none and connection is mine (i.e type=personal) */
      var usedColor = [];
      if (this.connection.accessInfo().type && this.connection.accessInfo().type === 'personal') {
        this.connection.streams.walkTree(options, function (stream) {
          var color = streamUtils.getColor(stream, false);
          if (! stream.parentId && color) {
            usedColor.push(color);
          }
        });
        var freeColors = _.difference(STREAM_COLORS, usedColor);
        if (freeColors.length === 0) {
          freeColors = STREAM_COLORS;
        }
        this.connection.streams.walkTree(options, function (stream) {
          if (! stream.parentId && ! streamUtils.getColor(stream, false)) {
            streamUtils.setColor(stream, freeColors.shift());
            this.connection.streams._updateWithData({id: stream.id, clientData: stream.clientData},
              console.log);
            if (freeColors.length === 0) {
              freeColors = _.difference(STREAM_COLORS, usedColor);
              if (freeColors.length === 0) {
                freeColors = STREAM_COLORS;
              }
            }
          }
        }.bind(this));
      }

      if (VirtualNode.nodeHas(this.connection)) {
        var vn = VirtualNode.getNodes(this.connection);
        console.log('Checking connection\'s virtual nodes', vn);

        // for each virtual node of stream
        _.each(vn, function (virtualNode) {
          // set the redirections to the children
          _.each(virtualNode.filters, function (s) {
            this.addRedirections(s.streamId, virtualNode.id, s.type);
          }.bind(this));

          this.createVirtualStreamNode(this, null, virtualNode.id, virtualNode.name, virtualNode);
        }.bind(this));
      }



      this.connection.streams.walkTree(options,
        function (stream) {  // eachNode
          var parentNode = this;
          if (stream.parent) {   // if not parent, this connection node is the parent
            parentNode = this.streamNodes[stream.parent.id];
          }
          stream.isVirtual = false;
          this.streamNodes[stream.id] = new StreamNode(this, parentNode, stream);
          if (VirtualNode.nodeHas(stream)) {
            var vn = VirtualNode.getNodes(stream);
            // for each virtual node of stream
            _.each(vn, function (virtualNode) {
              // set the redirections to the children
              _.each(virtualNode.filters, function (s) {
                this.addRedirections(s.streamId, virtualNode.id, s.type);
              }.bind(this));

              this.createVirtualStreamNode(this.streamNodes[stream.id],
                stream, virtualNode.id, virtualNode.name, virtualNode);
            }.bind(this));
          }
          // check for event redirection for the current stream
          this.setRedirections(stream.id);
        }.bind(this),
        function (error) {   // done
          if (error) { error = 'ConnectionNode failed to init structure - ' + error; }
          callback(error);
        });

    },

    /**
     * Advertise a structure change event
     * @param options {state : all, default}
     * @param callback
     */

    /*jshint -W098 */
    structureChange: function (callback, options) {

      // - load streamTree from connection
      // - create nodes
      // - redistribute events (if needed)
      // when implemented review "eventEnterScope" which creates the actual structure

      // warnings
      // - there is no list of events directly accessible.
      // Maybe this could be asked to the rootNode

      // possible optimization
      // - calculate the changes and rebuild only what's needed :)
      // - this would need cleverer StreamNodes

      console.log('Warning: Implement ConnectionNode.structureChange');
      callback();
    },

// ---------- Node -------------  //

    getChildren: function () {
      var children = [];
      _.each(this.streamNodes, function (node) {
        if (node.getParent() === this) { children.push(node); }
      }, this);
      return children;
    },


    eventEnterScope: function (event, reason, callback) {
      var node =  this.streamNodes[event.streamId]; // do we already know this stream?
      if (typeof node === 'undefined') {
        if (!this.waitForStream[event.streamId]) {
          this.waitForStream[event.streamId] = [];
        }
        this.waitForStream[event.streamId].push(event);
        if (typeof(callback) === 'function') {
          return callback();
        } else {
          return null;
        }
      }
      node.eventEnterScope(event, reason, callback);
    },
    streamEnterScope: function (stream, reason, callback) {
      if (this.streamNodes[stream.id]) {
        if (typeof(callback) === 'function') {
          return callback();
        } else {
          return null;
        }
      }
      if (!stream.parent) {
        this.streamNodes[stream.id] = new StreamNode(this, this, stream);
      }
      if (stream.parent && this.streamNodes[stream.parent.id]) {
        this.streamNodes[stream.id] =
          new StreamNode(this, this.streamNodes[stream.parent.id], stream);
      }
      if (stream.parent && !this.streamNodes[stream.parent.id]) {
        if (!this.waitForParentStream[stream.parent.id]) {
          this.waitForParentStream[stream.parent.id] = [];
        }
        this.waitForParentStream[stream.parent.id].push(stream);
        if (typeof(callback) === 'function') {
          return callback();
        } else {
          return null;
        }
      }
      _.each(this.waitForStream[stream.id], function (event) {
        this.eventEnterScope(event, null, function () {});
      }.bind(this));
      _.each(this.waitForParentStream[stream.id], function (stream) {
        this.streamEnterScope(stream, null, function () {});
      }.bind(this));
      if (typeof(callback) === 'function') {
        return callback();
      } else {
        return null;
      }
    },

    streamChange: function (stream, reason, callback) {
      if (this.streamNodes[stream.id]) {
        this._refreshViewModel();

        console.log('[PERKI AT WORK... should propagate streamChange further]');

      }
      if (typeof(callback) === 'function') {
        return callback();
      } else {
        return null;
      }
      console.log('[WARNING] ConnectionNode.streamChange on unkown stream: ' + stream.id);
    },

    eventLeaveScope: function (event, reason, callback) {
      var node = this.streamNodes[event.streamId];
      if (node) {
        node.eventLeaveScope(event, reason, callback);
      }
    },

    eventChange: function (event, reason, callback) {
      var node = this.streamNodes[event.streamId];
      if (node) {
        node.eventChange(event, reason, callback);
      }
    },

// ----------- connection attached virtual nodes ------------//
    updateConnectionVirtualNodes: function (a, b) {
      console.log('updateConnectionVirtualNodes', a, b);
      console.log('updateConnectionVirtualNodes', this);
    },

    addRedirections: function (from, to, type) {
    // if the source is already in the list:
      if (this.streamNodes[from]) {
        if (this.streamNodes[from].redirect) {
          this.streamNodes[from].redirect.push({to: to, type: type});
        } else {
          this.streamNodes[from].redirect = [{to: to, type: type}];
        }
      } else {
        if (this.virtNodeWaiting[from]) {
          this.virtNodeWaiting[from].push({to: to, type: type});
        } else {
          this.virtNodeWaiting[from] = [{to: to, type: type}];
        }
      }
    },

    setRedirections: function (streamId) {
      // check for event redirection
      if (this.virtNodeWaiting[streamId]) {
        if (this.streamNodes[streamId].redirect) {
          // for loop to add them all ?
          for (var i = 0, n = this.virtNodeWaiting[streamId].length; i < n; ++i) {
            this.streamNodes[streamId].redirect.push(this.virtNodeWaiting[streamId][i]);
          }
        } else {
          this.streamNodes[streamId].redirect = this.virtNodeWaiting[streamId];
        }
        delete this.virtNodeWaiting[streamId];
      }
    },

    /**
     * Creates a new Virtual node
     * @param parent the parent object
     * @param id the virtual node's id
     * @param name the virtual node's name
     */
    createVirtualStreamNode: function (parentNode, parent, id, name, vn) {

      // Warning MANIPULATING childrensIds is WRONG!! and logic must be reviewd

      var connectionNode =  this;
      var virtualStream = new Pryv.Stream(this.connection, {_parent: parent,
        parentId: parent ? parent.id : null, childrenIds: [], id: id, name: name,
        virtual: vn});

      this.streamNodes[id] = new StreamNode(connectionNode,
        parentNode, virtualStream);
      this.connection.datastore.streamsIndex[virtualStream.id] = virtualStream;
      if (parent) {
        parent.childrenIds.push(virtualStream.id);
      }
      console.log('Set up new virtual node as VirtualStream:', virtualStream);

      return {virtStream: virtualStream, virtStreamNode: this.streamNodes[id]};
    },

//----------- debug ------------//
    _debugTree : function () {
      var me = {
        name : this.connection.displayId
      };

      _.extend(me, TreeNode.prototype._debugTree.call(this));

      return me;
    }

  });
Object.defineProperty(ConnectionNode.prototype, 'id', {
  get: function () { return this.connection.id; },
  set: function () { throw new Error('ConnectionNode.id property is read only'); }
});

},{"../utility/streamUtils":135,"./StreamNode":122,"./TreeNode":124,"./VirtualNode.js":125,"pryv":50,"underscore":104}],120:[function(require,module,exports){
var TreeNode = require('./TreeNode'),
  RootNode = require('./RootNode'),
  Backbone = require('backbone'),
  NodeView = require('../view/NodeView.js'),
  _ = require('underscore');

/*
 If you want to bypass the plugin detection system (i.e not use EventsView.js)
 just remove EventsView = require... above and add to all the Events typed node:
 var EventsView = require( {path to the plugin view} );  as a global var
 pluginView: EventsView, as an instance var
 to create the view just do: new this.pluginView(params);
 */
/**
 * Holder for EventsNode
 * @type {*}
 */
var EventsNode = module.exports = TreeNode.implement(
  function (parentStreamNode) {
    TreeNode.call(this, parentStreamNode.treeMap, parentStreamNode);
    this.events = {};
    this.trashedEvents = {};
    this.eventDisplayed = null;
    this.eventView = null;
    this.model  = null;
    this.size = 0;
  },
  {
    className: 'EventsNode',
    aggregated: false,
    getChildren: function () {
      return null;
    },

    eventEnterScope: function (event, reason, callback) {
      this.size++;
      event.streamName =
        this.parent.connectionNode.connection.datastore.getStreamById(event.streamId).name;
      this.events[event.id] = event;
      if (!this.eventView) {
        this._createEventView();
      } else {
        this.eventView.eventEnter(event);
      }

      if (callback) {
        callback(null);
      }
    },
    eventLeaveScope: function (event/**, reason, callback*/) {
      if (this.events[event.id]) {
        this.size--;
        delete this.events[event.id];
        if (this.eventView) {
          this.eventView.eventLeave(event);
        }
      }
    },
    onDateHighLighted: function (time) {
      if (this.eventView) {
        this.eventView.OnDateHighlightedChange(time);
      }
    },
    /*jshint -W098 */
    eventChange: function (event, reason, callback) {
      this.events[event.id] = event;
      //console.log('eventChange', event);
      if (this.eventView) {
        this.eventView.eventChange(event);
      }

      if (callback) {
        callback(null);
      }
    },

    _refreshViewModel: function (recursive) {
      if (!this.model) {
        var BasicModel = Backbone.Model.extend({ });
        this.model = new BasicModel({
          containerId: this.parent.uniqueId,
          id: this.uniqueId,
          className: this.className,
          width: this.width,
          height: this.height,
          x: this.x,
          y: this.y,
          depth: this.depth,
          color: this.parent.stream.color,
          weight: this.getWeight(),
          content: this.events || this.stream || this.connection,
          eventView: this.eventView,
          streamId: this.parent.stream.id,
          streamName: this.parent.stream.name,
          connectionId: this.parent.connectionNode.id
        });
      } else {
        // TODO For now empty nodes (i.e streams) are not displayed
        // but we'll need to display them to create event, drag drop ...
        /*if (this.getWeight() === 0) {
         if (this.model) {
         this.model.set('width', 0);
         this.model.set('height', 0);
         }
         return;
         } */
        this.model.set('containerId', this.parent.uniqueId);
        this.model.set('id', this.uniqueId);
        this.model.set('name', this.className);
        this.model.set('width', this.width);
        this.model.set('height', this.height);
        this.model.set('x', this.x);
        this.model.set('y', this.y);
        this.model.set('depth', this.depth);
        this.model.set('weight', this.getWeight());
        this.model.set('streamId', this.parent.stream.id);
        this.model.set('connectionId', this.parent.connectionNode.id);
        if (this.eventView) {
          this.eventView.refresh({
            width: this.width,
            height: this.height
          });
        }
      }
      if (recursive && this.getChildren()) {
        _.each(this.getChildren(), function (child) {
          child._refreshViewModel(true);
        });
      }
    },

    _createEventView: function () {
      this.eventView = new this.pluginView(this.events, {
        width: this.width,
        height: this.height,
        id: this.uniqueId,
        treeMap: this.treeMap,
        stream: this.parent.stream
      }, this);
    },
    /**
     * Called on drag and drop
     * @param nodeId
     * @param streamId
     * @param connectionId
     */
    dragAndDrop: function (nodeId, streamId, connectionId) {

      if (!nodeId || !streamId || !connectionId) {
        return this;
      }

      var otherNode =  this.treeMap.getNodeById(nodeId, streamId, connectionId);
      var thisNode = this;

      if (thisNode.isVirtual() || otherNode.isVirtual()) {
        throw new Error('Creating virtual node out of virtual nodes currently not allowed.');
      }
      if (otherNode === thisNode) {
        throw new Error('Creating virtual node with the same node not allowed.');
      }

      this.treeMap.requestAggregationOfNodes(thisNode, otherNode);
    },
    isVirtual: function () {
      return (true && this.parent.stream.virtual);
    },
    getVirtual: function () {
      console.log('getVirtual', this.parent.stream.virtual);
      return this.parent.stream.virtual;
    },

    getSettings: function () {
      console.log('getSettings');
    }


  });


EventsNode.acceptThisEventType = function () {
  throw new Error('EventsNode.acceptThisEventType nust be overriden');
};





},{"../view/NodeView.js":137,"./RootNode":121,"./TreeNode":124,"backbone":5,"underscore":104}],121:[function(require,module,exports){
var TreeNode = require('./TreeNode'),
    ConnectionNode = require('./ConnectionNode'),
    _ = require('underscore');

var CONNECTION_MARGIN = 30;
/**
 * Holder for Connection Nodes.
 * @type {*}
 */
module.exports = TreeNode.implement(
  function (treemap, w, h) {
    TreeNode.call(this, treemap, null);
    if (w === null || h === null) {
      throw new Error('You must set width and height of the root node');
    }
    this.connectionNodes = {}; // Connections indexed by their token .. other index solution welcome
    this.width = w;
    this.height = h;
    this.margin = CONNECTION_MARGIN;
    this.offset = 0;
  },

  {
    className: 'RootNode',
    eventLeaveCount: 0,

    getChildren: function () {
      return _.values(this.connectionNodes);
    },

    eventEnterScope: function (event, reason, callback) {
      var connectionNode = this.connectionNodes[event.connection.id];
      if (typeof connectionNode !== 'undefined') {
        return connectionNode.eventEnterScope(event, reason, callback);
      }
      // we create a new connection Node
      connectionNode = new ConnectionNode(this, event.connection);
      this.connectionNodes[event.connection.id] = connectionNode;
      connectionNode.initStructure(null, function (error) {
        if (error) {
          return callback('RootNode.eventEnterScope Failed to init ConnectionNode - ' + error);
        }
        connectionNode.eventEnterScope(event, reason, callback);
      });
    },
    streamEnterScope: function (stream, reason, callback) {
      var connectionNode = this.connectionNodes[stream.connection.id];
      if (typeof connectionNode !== 'undefined') {
        return connectionNode.streamEnterScope(stream, reason, callback);
      }
      // we create a new connection Node
      connectionNode = new ConnectionNode(this, stream.connection);
      this.connectionNodes[stream.connection.id] = connectionNode;
      connectionNode.streamEnterScope(stream, reason, callback);
    },

    streamChange: function (stream, reason, callback) {
      var connectionNode = this.connectionNodes[stream.connection.id];
      if (typeof connectionNode !== 'undefined') {
        console.log('[WARNING] RootNode.streamChange stream: ' + stream.id +
          ' for an unkown connection:' + stream.connection.id);
        return connectionNode.streamChange(stream, reason, callback);
      }
      return false;
    },

    eventLeaveScope: function (event, reason, callback) {
      var node = this.connectionNodes[event.connection.id];
      if (node === 'undefined') {
        throw new Error('RootNode: can\'t find path to remove event' + event.id);
      }
      node.eventLeaveScope(event, reason, callback);

    },

    eventChange: function (event, reason, callback) {
      var node = this.connectionNodes[event.connection.id];
      if (node === 'undefined') {
        throw new Error('RootNode: can\'t find path to change event' + event.id);
      }
      node.eventChange(event, reason, callback);
    },

    getEventNode: function (nodeId, streamId, connectionId) {
      var node = null;
      node = this.connectionNodes[connectionId];
      if (node === 'undefined') {
        throw new Error('RootNode: can\'t find path to requested event by connection' +
          connectionId);
      }
      node = node.streamNodes[streamId];
      if (node === 'undefined') {
        throw new Error('RootNode: can\'t find path to requested event by stream' +
          connectionId + streamId);
      }
      var that = _.find(node.getChildren(), function (node) { return node.uniqueId === nodeId; });

      if (node === 'undefined') {
        throw new Error('RootNode: can\'t find path to requested event by nodeId' +
          connectionId + ' ' + streamId + ' ' + nodeId);
      }

      return that;
    }
  });


},{"./ConnectionNode":119,"./TreeNode":124,"underscore":104}],122:[function(require,module,exports){
var TreeNode = require('./TreeNode');
var _ = require('underscore');

/**
 * Holder for Connection Nodes.
 * @type {*}
 */

var StreamNode = module.exports = TreeNode.implement(
  function (connectionNode, parentNode, stream) {
    TreeNode.call(this, parentNode.treeMap, parentNode);
    this.stream = stream;
    this.connectionNode = connectionNode;
    this.oneLevelAggregation = true;
    /**
     * eventsNodes are stored by their key
     **/
    this.eventsNodes = {};
    this.eventsNodesAggregated = {};
  },
  {
    className: 'StreamNode',


    _needToAggregate: function () {
      if (this.oneLevelAggregation) {
        var focusedStreams = this.treeMap.getFocusedStreams();
        if (!focusedStreams.length && !this.stream.parent) {
          return true;
        }
        if (!focusedStreams.length && this.stream.parent) {
          return false;
        }
        var needToAggregate = false;
        _.each(focusedStreams, function (stream) {
          if (this.stream.parent && stream.serialId === this.stream.parent.serialId) {
            needToAggregate = true;
          }
        }.bind(this));
        return needToAggregate;
      } else {
        if (this.getWeight() > 0 &&
          (this.width <= this.minWidth || this.height <= this.minHeight)) {
          /* we don't need to aggregate if all the events are in the same stream
           so we need to walk all the child of this stream with 3 stop condition:
           - if a stream has more than one stream we aggregate it
           - if a stream has one stream and one or more eventsNode we aggregate it
           - if a stream has only eventsNode we don't aggregate it
           */

          var node = this, currentAggregated;
          var numberOfStreamNode, numberOfEventsNode;
          while (true) {
            numberOfEventsNode = _.size(node.eventsNodes);
            currentAggregated = node.aggregated;
            // force aggregated to false for getChildren to return nonAggregated node
            node.aggregated = false;
            numberOfStreamNode = _.size(node.getChildren()) - numberOfEventsNode;
            node.aggregated = currentAggregated;
            if (numberOfStreamNode === 0) {
              return false;
            }
            if (numberOfStreamNode > 1) {
              return true;
            }
            if (numberOfStreamNode > 0 && numberOfEventsNode > 0) {
              return true;
            }
            // at this point the node has only one stream as child
            node = node.getChildren()[0];
          }
        }  else {
          return false;
        }
      }
    },
    _aggregate: function () {
      _.each(this.getChildren(), function (child) {
        child._closeView(false);
      });
      this.aggregated = true;
      this.createEventsNodesFromAllEvents(this.getAllEvents());
      _.each(this.eventsNodesAggregated, function (node) {
        node._createView();
      });
    },
    _desaggregate: function () {
      _.each(this.eventsNodesAggregated, function (node) {
        node._closeView(false);
      });
      this.aggregated = false;
      _.each(this.getChildren(), function (child) {
        child._createView();
      });
    },
    getWeight: function () {
      var children = [];
      var weight = 0;
      // Streams
      _.each(this.stream.children, function (child) {
        var childTemp =  this.connectionNode.streamNodes[child.id];
        children.push(childTemp);
      }, this);

      // Events
      _.each(this.eventsNodes, function (eventNode) {
        children.push(eventNode);
      });

      children.forEach(function (child) {
        weight += child.getWeight();
      });

      return weight;
    },

    getChildren: function () {
      var children = [];

      if (this.aggregated) {
        var weight = this.getWeight();
        var aggregatedWeight = 0;
        _.each(this.eventsNodesAggregated, function (node) {
          if (!node.originalWeight) {
            node.originalWeight = node.getWeight;
          }
          aggregatedWeight += node.originalWeight();
        });
        _.each(this.eventsNodesAggregated, function (node) {
          node.getWeight = function () {
            return (node.originalWeight() / aggregatedWeight) * weight;
          };
          children.push(node);
        });
      } else {
        // Streams
        _.each(this.stream.children, function (child) {
          var childTemp =  this.connectionNode.streamNodes[child.id];
          children.push(childTemp);
        }, this);

        // Events
        _.each(this.eventsNodes, function (eventNode) {
          children.push(eventNode);
        });
      }
      return children;
    },
    getAllEvents: function () {
      var allEvents = [];
      _.each(this.stream.children, function (streamChild) {
        var streamChildNode = this.connectionNode.streamNodes[streamChild.id];
        allEvents = _.union(allEvents, streamChildNode.getAllEvents());
      }, this);

      _.each(this.eventsNodes, function (eventNodeChild) {
        _.each(eventNodeChild.events, function (event) {
          allEvents.push(event);
        });
      });
      return allEvents;
    },
    createEventsNodesFromAllEvents: function (events) {
      this.eventsNodesAggregated = {};
      _.each(events, function (event) {
        var key = this._findEventNodeType(event);
        var eventView = this._findEventNode(key, this.eventsNodesAggregated);
        if (eventView === null) {
          throw new Error('StreamNode: did not find an eventView for event: ' + event.id);
        }
        eventView.eventEnterScope(event);
      }, this);

    },
    eventEnterScope: function (event, reason, callback) {
      var key = this._findEventNodeType(event);
      var eventNode = this._findEventNode(key, this.eventsNodes);
      if (eventNode === null) {
        throw new Error('StreamNode: did not find an eventView for event: ' + event.id);
      }
      if (this.redirect) {
        for (var i = 0, n = this.redirect.length; i < n; ++i) {
          if (this.redirect[i].type === event.type &&
            this.stream.id === event.streamId) {
            this.connectionNode.streamNodes[this.redirect[i].to]
              .eventEnterScope(event, reason, callback);
          }
        }
      }
      eventNode.eventEnterScope(event, reason, callback);
      var aggregatedParent = this._findAggregatedParent();
      if (aggregatedParent) {
        eventNode =  aggregatedParent._findEventNode(key, aggregatedParent.eventsNodesAggregated);
        if (eventNode === null) {
          throw new Error('EventEnterScore: did not find an eventView for the aggregated stream');
        }
        eventNode.eventEnterScope(event, reason, callback);
      }
    },


    eventLeaveScope: function (event, reason, callback) {
      var key = this._findEventNodeType(event), eventNode = this.eventsNodes[key];
      if (!eventNode) {
        if (_.isFunction(callback)) {
          return callback();
        }
      }
      if (this.redirect) {
        for (var i = 0, n = this.redirect.length; i < n; ++i) {
          if (this.redirect[i].type === event.type &&
            this.stream.id === event.streamId) {
            this.connectionNode.streamNodes[this.redirect[i].to]
              .eventLeaveScope(event, reason, callback);
          }
        }
      }
      eventNode.eventLeaveScope(event, reason, callback);
      if (eventNode.size === 0) {
        eventNode._closeView();
        delete this.eventsNodes[key];
      }
      var aggregatedParent = this._findAggregatedParent();
      if (aggregatedParent) {
        eventNode =  aggregatedParent._findEventNode(key, aggregatedParent.eventsNodesAggregated);
        if (eventNode === null) {
          throw new Error('EventLeaveScore: did not find an eventView for the aggregated stream');
        }
        eventNode.eventLeaveScope(event, reason, callback);
        if (eventNode.size === 0) {
          eventNode._closeView();
          delete aggregatedParent.eventsNodesAggregated[key];
        }

      }
    },

    eventChange: function (event, reason, callback) {
      var key = this._findEventNodeType(event), eventNode = this.eventsNodes[key];
      if (!eventNode) {
        throw new Error('StreamNode: did not find an eventView for event: ' + event.id);
      }
      if (this.redirect) {
        for (var i = 0, n = this.redirect.length; i < n; ++i) {
          if (this.redirect[i].type === event.type &&
            this.stream.id === event.streamId) {
            this.connectionNode.streamNodes[this.redirect[i].to]
              .eventChange(event, reason, callback);
          }
        }
      }
      eventNode.eventChange(event, reason, callback);
      var aggregatedParent = this._findAggregatedParent();
      if (aggregatedParent) {
        eventNode =  aggregatedParent._findEventNode(key, aggregatedParent.eventsNodesAggregated);
        if (eventNode === null) {
          throw new Error('eventChange: did not find an eventView for the aggregated stream');
        }
        eventNode.eventChange(event, reason, callback);
      }
    },
    _findAggregatedParent: function () {
      var parent = this;
      while (parent) {
        if (parent.aggregated) {
          return parent;
        }
        parent = parent.parent;
      }
      return null;
    },
    _findEventNodeType: function (event) {
      var keys = _.keys(StreamNode.registeredEventNodeTypes);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (StreamNode.registeredEventNodeTypes[key].acceptThisEventType(event.type)) {
          return key;
        }
      }
      return;
    },
    _findEventNode: function (key, eventsNodeList) {
      var eventNode = null;
      if (key && _.has(eventsNodeList, key)) {
        eventNode =  eventsNodeList[key]; // found one
      }  else { // create is
        eventNode = new StreamNode.registeredEventNodeTypes[key](this);
        eventsNodeList[key] = eventNode;
      }
      return eventNode;
    },

    //----------- debug ------------//
    _debugTree : function () {
      var me = {
        name : this.stream.name,
        nullChildren : 0
      };

      _.extend(me, TreeNode.prototype._debugTree.call(this));


      return me;
    }
  });


StreamNode.registeredEventNodeTypes = {
  'NotesEventsNode' : require('./eventsNode/NotesEventsNode.js'),
  'ActivitiesEventsNode' : require('./eventsNode/ActivitiesEventsNode.js'),
  'PositionsEventsNode' : require('./eventsNode/PositionsEventsNode.js'),
  'PicturesEventsNode' : require('./eventsNode/PicturesEventsNode.js'),
  'NumericalsEventsNode' : require('./eventsNode/NumericalsEventsNode.js'),
  'TweetsEventsNode' : require('./eventsNode/TweetsEventsNode.js'),
  'GenericEventsNode' : require('./eventsNode/GenericEventsNode.js')
};
},{"./TreeNode":124,"./eventsNode/ActivitiesEventsNode.js":126,"./eventsNode/GenericEventsNode.js":127,"./eventsNode/NotesEventsNode.js":128,"./eventsNode/NumericalsEventsNode.js":129,"./eventsNode/PicturesEventsNode.js":130,"./eventsNode/PositionsEventsNode.js":131,"./eventsNode/TweetsEventsNode.js":132,"underscore":104}],123:[function(require,module,exports){
/* global $, window, location, localStorage, i18n, confirm */

var RootNode = require('./RootNode.js'),
  SIGNAL = require('../model/Messages').MonitorsHandler.SIGNAL,
  _ = require('underscore'),
  DetailView = require('../view/events-views/detailed/Controller.js'),
  SharingView = require('../view/sharings/Controller.js'),
  CreateEventView = require('../view/create/Controller.js'),
  CreateSharingView = require('../view/sharings/create/Controller.js'),
  SubscribeView = require('../view/subscribe/Controller.js'),
  SettingsView = require('../view/settings/Controller.js'),
  ConnectAppsView = require('../view/connect-apps/Controller.js'),
  FusionDialog = require('../view/events-views/draganddrop/Controller.js'),
  OnboardingView = require('../view/onboarding/View.js'),
  StreamView = require('../view/stream/Controller.js'),
  VirtualNode = require('./VirtualNode.js'),
  Pryv = require('pryv');

var MARGIN_TOP = 50;
var MARGIN_RIGHT = 40;
var MARGIN_BOTTOM = 80;
var MARGIN_LEFT = 40;
var IGNORE_TRASHED_EVENT  = true;
var IGNORE_PARAM_CHANGED = false;

var TreeMap = module.exports = function (model) {
  this.model = model;
  this.dialog = null;
  this.detailedView = null;
  this.sharingView = null;
  this.subscribeView = null;
  this.settingsView = null;
  this.connectAppsView = null;
  this.createSharingView = null;
  this.createEventView = null;
  this.onboardingView = null;
  this.focusedStreams = null;
  this.trashedEvents = {};
  this.events = {};
  var $tree = $('#tree');
  this.root = new RootNode(this, $tree.width() - MARGIN_LEFT - MARGIN_RIGHT,
    $tree.height() - MARGIN_BOTTOM - MARGIN_TOP);
  this.root.x =  MARGIN_LEFT;
  this.root.y =  MARGIN_TOP;
  $('#back-tree').hide();
  $('#back-tree').click(function (e) {
    e.preventDefault();
    if (this.model.sharingsConnections && this.model.loggedConnection &&
      this.model.urlUsername === this.model.loggedConnection.username) {
      this.model.removeConnections(this.model.sharingsConnections);
      this.model.sharingsConnections = null;
      this.model.loggedConnection.bookmarks.get(function (error, result) {
        if (!error) {
          this.model.bookmarksConnections = result;
          this.model.addConnections(this.model.bookmarksConnections);
        }
      }.bind(this));
      this.model.addConnection(this.model.loggedConnection);
    } else {
      this.focusOnStreams(null);
    }
  }.bind(this));

  $('nav #addEvent').click(function (e) {
    e.preventDefault();
    var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
      this.closeCreateEventView();
    }.bind(this));
    this.showCreateEventView($modal, this.model.connections,
      this.getFocusedStreams(), e.currentTarget);
  }.bind(this));

  $('nav #connectApps').click(function (e) {
    e.preventDefault();
    var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
      this.closeConnectAppsView();
    }.bind(this));
    this.showConnectAppsView($modal, this.model.loggedConnection, e.currentTarget);
  }.bind(this));

  Pryv.utility.request({
    method : 'GET',
    ssl : 'true',
    host : 'reg.' + Pryv.utility.urls.defaultDomain,
    path : '/service/infos',
    success : function (data) {
      if(data && data.support) {
        $('nav #requestHelp').click(function (e) {
          e.preventDefault();
          location.href = data.support;
        }.bind(data));
      } else {
        $('nav #requestHelp').hide();
      }
    }
  });

  $('nav #toCSV').click(function (e) {
    e.preventDefault();
    if (confirm('Download As CSV?')) {
      window.onmessage({data: 'toCSV'});
    }
  }.bind(this));


  $('.logo-sharing').click(function (e) {
    e.preventDefault();
    var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
      this.closeSharingView();
    }.bind(this));
    this.showSharingView($modal, this.model.loggedConnection, e.currentTarget);
  }.bind(this));

  $('nav #settings').click(function (e) {
    e.preventDefault();
    var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
      this.closeSettingsView();
    }.bind(this));
    this.showSettingsView($modal, this.model.loggedConnection, e.currentTarget);
  }.bind(this));

  $('.logo-subscribe').click(function (e) {
    e.preventDefault();
    var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
      this.closeSubscribeView();
    }.bind(this));
    if (this.model.loggedConnection) {
      this.showSubscribeView($modal, this.model.loggedConnection, this.model.sharingsConnections,
        e.currentTarget);
    } else {
      this.model.openLogin();
    }
  }.bind(this));

  $('.logo-create-sharing').click(function (e) {
    e.preventDefault();
    var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
      this.closeCreateSharingView();
    }.bind(this));
    var streams = [], streamsId = [],
      loggedUsername = this.model.loggedConnection.username;
    this.model.activeFilter.getStreams().forEach(function (stream) {
      if (stream.connection.username === loggedUsername) {
        if (streamsId.indexOf((stream.parentId)) === -1) {
          streams.push({id: stream.id, name: stream.name, children: stream.children});
        }
        streamsId.push(stream.id);
      }
    });
    if (streams.length === 0) {
      this.model.loggedConnection.datastore.getStreams().forEach(function (stream) {
        if (streamsId.indexOf((stream.parentId)) === -1) {
          streams.push({id: stream.id, name: stream.name, children: stream.children});
        }
        streamsId.push(stream.id);
      });
    }
    if (streams.length !== 0) {
      this.showCreateSharingView($modal, this.model.loggedConnection, streams,
        this.model.activeFilter.timeFrameST, e.currentTarget);
    }
  }.bind(this));

  this._onIgnoreParamChanged = function () {
    IGNORE_PARAM_CHANGED = false;
    if (IGNORE_TRASHED_EVENT) {
      var e = [];
      _.each(this.events, function (event) {
        if (event.trashed) {
          e.push(event);
          this.trashedEvents[event.id] = event;
        }
      }.bind(this));
      this.eventLeaveScope({events: e});
    } else {
      this.eventEnterScope({events: this.trashedEvents});
      this.trashedEvents = {};
    }
  };

  var refreshTree = window.PryvBrowser.refresh = _.throttle(function () {
    var start = new Date().getTime();
    if (IGNORE_PARAM_CHANGED) {
      this._onIgnoreParamChanged();
    }
    this.root._generateChildrenTreemap(0,
      0,
      this.root.width,
      this.root.height,
      true);
    this.root._refreshViewModel(true);
    this.root.renderView(true);
    this.model.updateTimeFrameLimits();
    var end = new Date().getTime();
    var time = end - start;
    console.log('refreshTree execution:', time);
  }.bind(this), 10);

  $(window).resize(_.debounce(function () {
    var $tree = $('#tree');
    this.root.width = $tree.width() - MARGIN_LEFT - MARGIN_RIGHT -
      ($tree.position().left || 0) - ($tree.position().right || 0);
    this.root.height = $tree.height() - MARGIN_BOTTOM - MARGIN_TOP;
    this.root.x =  MARGIN_LEFT;
    this.root.y =  MARGIN_TOP;
    this.root._createView();
    this.root._generateChildrenTreemap(0,
      0,
      this.root.width,
      this.root.height,
      true);
    this.root._refreshViewModel(true);
    this.root.renderView(true);
  }.bind(this), 100));

  //----------- init the model with all events --------//
  this.eventEnterScope = function (content) {
    var start = new Date().getTime();
    _.each(content.events, function (event) {
      if (!event.streamId) {
        return;
      }
      if (!IGNORE_TRASHED_EVENT || !event.trashed) {
        this.events[event.id] = _.extend({}, event);
        this.root.eventEnterScope(event, content.reason, function () {});
      } else {
        this.trashedEvents[event.id] = event;
      }
    }, this);
    this.root._createView();
    var end = new Date().getTime();
    var time = end - start;
    console.log('eventEnter execution:', time);
    refreshTree();
  }.bind(this);

  this.streamEnterScope = function (content) {
    var start = new Date().getTime();
    _.each(content.streams, function (stream) {
      this.root.streamEnterScope(stream, content.reason, function () {});
    }, this);
    this.getFocusedStreams(); // ? is this usefull??
    this.root._createView();
    var end = new Date().getTime();
    var time = end - start;
    console.log('eventEnter execution:', time);
    refreshTree();
  }.bind(this);
  this.streamLeaveScope = function (content) {
    console.log('streamLeave', content);
  }.bind(this);
  this.streamChange = function (content) {
    console.log('streamChange', content);
    _.each(content.streams, function (stream) {
      this.root.streamChange(stream, content.reason, function () {});
    }, this);
  }.bind(this);
  this.eventLeaveScope = function (content) {
    console.log('eventLeave', content);
    var start = new Date().getTime();
    _.each(content.events, function (event) {
      this.root.eventLeaveScope(event, content.reason, function () {});
    }, this);
    var end = new Date().getTime();
    var time = end - start;
    console.log('eventLeave execution:', time);
    refreshTree();
  }.bind(this);

  this.eventChange = function (content) {
    var start = new Date().getTime();
    var isStreamChanged = function (oldEvent, newEvent) {
      return oldEvent.streamId !== newEvent.streamId;
    };
    var isTrashedChanged = function (oldEvent, newEvent) {
      return oldEvent.trashed !== newEvent.trashed;
    };
    _.each(content.events, function (event) {
      var oldEvent = this.events[event.id];
      if (!oldEvent) {
        try {
          this.root.eventEnterScope(event, content.reason, function () {
          });
        } catch (e) {
          console.warn('EventLeave error:', e);
        }
        return;
      }
      if (isTrashedChanged(oldEvent, event) && IGNORE_TRASHED_EVENT) {
        this.trashedEvents[event.id] = event;
      }
      if (!isStreamChanged(oldEvent, event) && !isTrashedChanged(oldEvent, event)) {
        try {
          this.root.eventChange(event, content.reason, function () {
          });
        } catch (e) {
          console.warn('EventChange error:', e);
        }
      }
      if ((isTrashedChanged(oldEvent, event) && IGNORE_TRASHED_EVENT) ||
        isStreamChanged(oldEvent, event))   {
        try {
          this.root.eventLeaveScope(oldEvent, content.reason, function () {
          });
        } catch (e) {
          console.warn('EventLeave error:', e);
        }
      }
      if (isStreamChanged(oldEvent, event) &&
        (!IGNORE_TRASHED_EVENT || !isTrashedChanged(oldEvent, event))) {
        try {
          this.root.eventEnterScope(event, content.reason, function () {
          });
        } catch (e) {
          console.warn('EventLeave error:', e);
        }
      }
      this.events[event.id] = _.extend({}, event);
    }, this);
    var end = new Date().getTime();
    var time = end - start;
    console.log('eventChange execution:', time);
    refreshTree();
  }.bind(this);

  this.model.activeFilter.triggerForAllCurrentEvents(this.eventEnterScope);
  //--------- register the TreeMap event Listener ----------//
  this.model.activeFilter.addEventListener(SIGNAL.EVENT_SCOPE_ENTER,
    this.eventEnterScope);
  this.model.activeFilter.addEventListener(SIGNAL.EVENT_SCOPE_LEAVE,
    this.eventLeaveScope);
  this.model.activeFilter.addEventListener(SIGNAL.EVENT_CHANGE,
    this.eventChange);
  this.model.activeFilter.addEventListener(SIGNAL.STREAM_SCOPE_ENTER,
    this.streamEnterScope);
  this.model.activeFilter.addEventListener(SIGNAL.STREAM_SCOPE_LEAVE,
    this.streamLeaveScope);
  this.model.activeFilter.addEventListener(SIGNAL.STREAM_CHANGE,
    this.streamChange);
};

TreeMap.prototype.isOnboarding = function () {
  if (localStorage && localStorage.getItem('skipOnboarding')) {
    this.model.loggedConnection.streams.get({state: 'all'}, function (error, result) {
      if (!error && result.length === 0 &&
        this.model.urlUsername === this.model.loggedConnection.username) {
        this.model.loggedConnection.streams.create(
          {id: 'diary', name: i18n.t('onboarding.defaultStreamName')},
          function () {});
      }
    }.bind(this));
  } else {
    this.model.loggedConnection.streams.get({state: 'all'}, function (error, result) {
      if (!error && result.length === 0 &&
        this.model.urlUsername === this.model.loggedConnection.username) {
        this.showOnboarding();
      }
    }.bind(this));
  }
};

TreeMap.prototype.focusOnConnections = function (connection) {
  this.model.activeFilter.focusOnConnections(connection);
  this.setFocusedStreams(null);
  $('#back-tree').show();
};

TreeMap.prototype.focusOnStreams = function (stream) {
  this.model.activeFilter.focusOnStreams(stream);
  this.setFocusedStreams(stream);
  if (!stream) {
    $('#back-tree').hide();
  } else {
    $('#back-tree').show();
  }
};

TreeMap.prototype.setFocusedStreams = function (stream) {
  this.focusedStreams = stream;
};

TreeMap.prototype.getFocusedStreams = function () {
  return this.model.activeFilter.getStreams();
};

TreeMap.prototype.onDateHighLighted = function (time) {
  if (this.root) {
    this.root.onDateHighLighted(time);
  }
};

TreeMap.prototype.destroy = function () {
  this.model.activeFilter.removeEventListener(SIGNAL.EVENT_SCOPE_ENTER,
    this.eventEnterScope);
  this.model.activeFilter.removeEventListener(SIGNAL.EVENT_SCOPE_LEAVE,
    this.eventLeaveScope);
  this.model.activeFilter.removeEventListener(SIGNAL.EVENT_CHANGE,
    this.eventChange);
};


/** The treemap's utility functions **/

/**
 * Search for the node matching the arguments and returns it.
 * @param nodeId the unique id in the DOM of the node
 * @param streamId  the unique id of the stream associated with the node
 * @param connectionId the unique id of the connection associated with the node
 * @returns {find|*} returns the uniquely identifiable by the passed arguments
 */
TreeMap.prototype.getNodeById = function (nodeId, streamId, connectionId) {
  var node = this.root;
  node = node.connectionNodes[connectionId];
  if (node === 'undefined') {
    throw new Error('RootNode: can\'t find path to requested event by connection' +
      connectionId);
  }
  node = node.streamNodes[streamId];
  if (node === 'undefined') {
    throw new Error('RootNode: can\'t find path to requested event by stream' +
      connectionId + streamId);
  }
  var that = _.find(node.getChildren(), function (node) { return node.uniqueId === nodeId; });

  if (node === 'undefined') {
    throw new Error('RootNode: can\'t find path to requested event by nodeId' +
      connectionId + ' ' + streamId + ' ' + nodeId);
  }
  return that;
};

/**
 * Sets up all the controlling to aggregate two nodes.
 * @param node1 the first node
 * @param node2 the second node
 */
TreeMap.prototype.requestAggregationOfNodes = function (node1, node2) {
  var events = { };
  var attrname = null;
  for (attrname in node1.events) {
    if (node1.events.hasOwnProperty(attrname)) {
      events[attrname] = node1.events[attrname];
    }
  }
  for (attrname in node2.events) {
    if (node2.events.hasOwnProperty(attrname)) {
      events[attrname] = node2.events[attrname];
    }
  }
  this.dialog = new FusionDialog($('#pryv-modal').on('hidden.bs.modal', function () {
    if (this.dialog) {
      this.dialog.close();
      this.dialog = null;
    }
  }.bind(this)), events, this);
  this.dialog.show();
};

TreeMap.prototype.getFiltersFromNode = function (node) {
  var streams = [];
  var u = {}, s;
  for (var attribute in node.events) {
    if (node.events.hasOwnProperty(attribute)) {
      s = {stream: node.events[attribute].stream, type: node.events[attribute].type};
      if (!u.hasOwnProperty(s.streamId)) {
        u[s.streamId] = {};
        if (!u[s.streamId].hasOwnProperty(s.type)) {
          u[s.streamId][s.type] = 1;
          streams.push(s);
        }
      }
    }
  }
  return s;
};

//======== MODALS VIEW ========\\

TreeMap.prototype.closeViews = function () {
  this.closeSharingView();
  this.closeCreateSharingView();
  this.closeDetailedView();
  this.closeCreateEventView();
  this.closeSettingsView();
  this.closeSubscribeView();
  this.closeConnectAppsView();
  this.closeOnboardingView();
  this.closeStreamView();
};

//======== Detailed View ========\\

TreeMap.prototype.hasDetailedView = function () {
  return typeof this.detailedView !== 'undefined' && this.detailedView !== null;
};

/**
 * @param $modal
 * @param {Object} model Must have `events`, `stream` and `highlightedTime` properties
 * @param target
 */
TreeMap.prototype.showDetailedView = function ($modal, model, target) {
  this.closeViews();
  if (! this.hasDetailedView()) {
    this.detailedView = new DetailView($modal, this.model.connections, model.stream, target);
    this.addEventsDetailedView(model.events);
    this.detailedView.show();
    this.highlightDateDetailedView(model.highlightedTime);
  }
};

TreeMap.prototype.closeDetailedView = function () {
  if (this.hasDetailedView()) {
    this.detailedView.close();
    this.detailedView = null;
  }
};

TreeMap.prototype.addEventsDetailedView = function (events) {
  if (this.hasDetailedView()) {
    this.detailedView.addEvents(events);
  }
};

TreeMap.prototype.deleteEventDetailedView = function (event) {
  if (this.hasDetailedView()) {
    this.detailedView.deleteEvent(event);
  }
};

TreeMap.prototype.updateEventDetailedView = function (event) {
  if (this.hasDetailedView()) {
    this.detailedView.updateEvent(event);
  }
};

TreeMap.prototype.highlightDateDetailedView = function (time) {
  if (this.hasDetailedView()) {
    this.detailedView.highlightDate(time);
  }
};

/*=================================*/
//======= CREATE EVENT VIEW ======\\

TreeMap.prototype.hasCreateEventView = function () {
  return typeof this.createEventView !== 'undefined' && this.createEventView !== null;
};

TreeMap.prototype.showCreateEventView = function ($modal, connection, focusedStream, target) {
  this.closeViews();
  if ($modal && connection && !this.hasCreateEventView()) {
    this.createEventView = new CreateEventView($modal, connection, focusedStream, target);
    this.createEventView.show();
  }
};

TreeMap.prototype.closeCreateEventView = function () {
  if (this.hasCreateEventView()) {
    this.createEventView.close();
    this.createEventView = null;
  }
};

/*=================================*/
//======= CONFIG STREAM VIEW ======\\

TreeMap.prototype.hasStreamView = function () {
  return typeof this.streamView !== 'undefined' && this.streamView !== null;
};

TreeMap.prototype.showStreamView = function ($modal, stream, target) {
  this.closeViews();
  if ($modal && stream && !this.hasStreamView()) {
    this.streamView = new StreamView($modal, stream, target);
    this.streamView.show();
  }
};

TreeMap.prototype.closeStreamView = function () {
  if (this.hasStreamView()) {
    this.streamView.close();
    this.streamView = null;
  }
};

/*=================================*/
//========== SHARING VIEW =========\\

TreeMap.prototype.hasSharingView = function () {
  return typeof this.sharingView !== 'undefined' && this.sharingView !== null;
};

TreeMap.prototype.showSharingView = function ($modal, connection, target) {
  this.closeViews();
  if ($modal && connection) {
    this.sharingView = new SharingView($modal, connection, target);
    this.sharingView.show();
  }
};

TreeMap.prototype.closeSharingView = function () {
  if (this.hasSharingView()) {
    this.sharingView.close();
    this.sharingView = null;
  }
};

/*=================================*/
//========== SETTINGS VIEW =========\\

TreeMap.prototype.hasSettingsView = function () {
  return typeof this.settingsView !== 'undefined' && this.settingsView !== null;
};

TreeMap.prototype.showSettingsView = function ($modal, connection, target) {
  this.closeViews();
  if ($modal && connection) {
    this.settingsView = new SettingsView($modal, connection, target);
    this.settingsView.show();
  }
};

TreeMap.prototype.closeSettingsView = function () {
  if (this.hasSettingsView()) {
    this.settingsView.close();
    this.settingsView = null;
  }
};

/*=================================*/
//========== CONNECT APPS VIEW =========\\

TreeMap.prototype.hasConnectAppsView = function () {
  return typeof this.connectApps !== 'undefined' && this.connectApps !== null;
};

TreeMap.prototype.showConnectAppsView = function ($modal, connection, target) {
  this.closeViews();
  if ($modal && connection) {
    this.connectApps = new ConnectAppsView($modal, connection, target);
    this.connectApps.show();
  }
};

TreeMap.prototype.closeConnectAppsView = function () {
  if (this.hasConnectAppsView()) {
    this.connectApps.close();
    this.connectApps = null;
  }
};

/*=================================*/
//========== CREATE SHARING VIEW =========\\

TreeMap.prototype.hasCreateSharingView = function () {
  return typeof this.createSharingView !== 'undefined' && this.createSharingView !== null;
};

TreeMap.prototype.showCreateSharingView = function ($modal, connection, timeFilter, streams,
                                                    target) {
  this.closeViews();
  if ($modal && timeFilter && streams) {
    this.createSharingView = new CreateSharingView($modal, connection, timeFilter, streams, target);
    this.createSharingView.show();
  }
};

TreeMap.prototype.closeCreateSharingView = function () {
  if (this.hasCreateSharingView()) {
    this.createSharingView.close();
    this.createSharingView = null;
  }
};

/*=================================*/
//========== SUBSCRIBE VIEW =========\\

TreeMap.prototype.hasSubscribeView = function () {
  return typeof this.subscribeView !== 'undefined' && this.subscribeView !== null;
};

TreeMap.prototype.showSubscribeView = function ($modal, loggedConnection, sharingsConnections,
                                                target) {
  this.closeViews();
  if ($modal && loggedConnection) {
    this.subscribeView = new SubscribeView($modal, loggedConnection, sharingsConnections, target);
    this.subscribeView.show();
  }
};

TreeMap.prototype.closeSubscribeView = function () {
  if (this.hasSubscribeView()) {
    this.subscribeView.close();
    this.subscribeView = null;
  }
};

/*=================================*/
//========== ONBOARDING VIEW =========\\

TreeMap.prototype.showOnboarding = function () {
  localStorage.setItem('welcome', true);
  location.href = location.origin + '/onboarding';
 /*
  var $timeframeContainer = $('#timeframeContainer');
  this.model.hideLoggedInElement();
  $timeframeContainer.animate({'bottom': -$timeframeContainer.height() + 'px'});
  this.onboardingView = new OnboardingView();
  var view = this.onboardingView;
  view.connection = this.model.loggedConnection;
  view.render();
  view.on('clickAdd', function () {
    this.model.showLoggedInElement();
    $('nav #addEvent').click();
    this.closeOnboardingView();
  }.bind(this));
  view.on('clickConnect', function () {
    this.model.showLoggedInElement();
    $('nav #connectApps').click();
    this.closeOnboardingView();
  }.bind(this));
  view.on('clickSkip', function () {
    this.model.showLoggedInElement();
    this.closeOnboardingView();
  }.bind(this));
   */
};
TreeMap.prototype.closeOnboardingView = function () {
  if (this.onboardingView) {
    this.onboardingView.close();
    $('#onboarding').addClass('hidden');
    $('#timeframeContainer').animate({'bottom': '0px'});
    this.onboardingView = null;
  }
};
/*=================================*/
/* jshint -W098 */

/**
 * Creates a virtual node from a certain number of events.
 * @param eventsNodes is an array of events nodes you want to aggregate permanently.
 */
TreeMap.prototype.createVirtualNode = function (filters, name) {
  var streams = [];
  var f = [];
  for (var i = 0, n = filters.length; i < n; ++i) {
    streams.push(filters[i].stream);
    f.push({streamId: filters[i].stream.id, type: filters[i].type});
  }
  var parent = this.getFirstCommonParent(_.uniq(streams));
  console.log('parent', parent);

  var vn = new VirtualNode(parent, name);
  vn.addFilters(f);
  if (parent instanceof Pryv.Connection) {
    console.log('Setting new Virtual node in connection', parent, 'with filters', f);
  } else if (parent instanceof Pryv.Stream) {
    console.log('Setting new Virtual node in stream', parent, 'with filters', f);
  }
};

TreeMap.prototype.getFirstCommonParent = function (eventsNodes) {

  /* TODO:
   * create the node, don't remove the already existing
   * make sure the update follows at both places
   */

  // Depth first search for goal, starting from parent
  var hasChild = function (parent, goal) {
    var found = false;
    if (parent.id === goal.id) {
      found = true;
    } else if (parent.children.length !== 0) {
      _.each(parent.children, function (c) {
        found = found || hasChild(c, goal);
      });
    }
    return found;
  };


  // returns common parent of start and goal
  var matchChild = function (start, goal) {
    var found = false;
    var depth = start;
    while (found === false) {
      found = hasChild(depth, goal);
      if (!found) {
        if (depth.parent) {
          depth = depth.parent;
        } else {
          return depth.connection;
        }
      }
    }
    return depth;
  };


  // start contains the common parent of all arguments in the end.
  var start = eventsNodes[0];
  console.log(start);
  for (var i = 1, n = eventsNodes.length; i < n; ++i) {
    start = matchChild(start, eventsNodes[i]);
  }
  return start;
};


/**
 * Remove a existing virtual node.
 * @param node the virtual node you want to remove
 */
TreeMap.prototype.removeVirtualNode = function (node) {
  /* TODO:
   * just remove the indicated node
   */
};

try {
  Object.defineProperty(window.PryvBrowser, 'hideTrashedEvents', {
    set: function (value) {
      value = !!value;
      if (_.isBoolean(value)) {
        this.customConfig = true;
        IGNORE_TRASHED_EVENT = value;
        IGNORE_PARAM_CHANGED = true;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return IGNORE_TRASHED_EVENT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}

},{"../model/Messages":114,"../view/connect-apps/Controller.js":139,"../view/create/Controller.js":140,"../view/events-views/detailed/Controller.js":149,"../view/events-views/draganddrop/Controller.js":164,"../view/onboarding/View.js":188,"../view/settings/Controller.js":190,"../view/sharings/Controller.js":198,"../view/sharings/create/Controller.js":203,"../view/stream/Controller.js":206,"../view/subscribe/Controller.js":209,"./RootNode.js":121,"./VirtualNode.js":125,"pryv":50,"underscore":104}],124:[function(require,module,exports){
/* global $, window */
var _ = require('underscore'),
  NodeView = require('../view/NodeView.js'),
  Backbone = require('backbone'),
  TreemapUtil = require('../utility/treemap.js');

/**
 * The model for all Nodes
 * @param parent
 * @constructor
 */
var DEFAULT_OFFSET = 18;
var DEFAULT_MARGIN = 2;
var DEFAULT_MIN_WIDTH = 350;
var DEFAULT_MIN_HEIGHT = 300;
var MAIN_CONTAINER_ID = 'tree';
var TreeNode = module.exports = function (treemap, parent) {
  //Init all the instance variables
  this.treeMap = treemap;
  this.parent = parent;
  this.uniqueId = _.uniqueId('node_');
  this.width = null;
  this.height = null;
  this.x = 0;
  this.y = 0;
  this.aggregated = false;
  this.view = null;
  this.model = null;
  this.offset = DEFAULT_OFFSET;
  this.margin = DEFAULT_MARGIN;
  this.minWidth = this.parent ? this.parent.minWidth : DEFAULT_MIN_WIDTH;
  this.minHeight = this.parent ? this.parent.minHeight : DEFAULT_MIN_HEIGHT;
};


TreeNode.implement = function (constructor, members) {
  var newImplementation = constructor;

  if (typeof Object.create === 'undefined') {
    Object.create = function (prototype) {
      function C() { }
      C.prototype = prototype;
      return new C();
    };
  }
  newImplementation.prototype = Object.create(this.prototype);
  _.extend(newImplementation.prototype, members);
  newImplementation.implement = this.implement;
  return newImplementation;
};

_.extend(TreeNode.prototype, {
  className: 'TreeNode',
  /** TreeNode parent or null if rootNode **/

  //---------- view management ------------//

  _createView: function () {
    if (this.getWeight() === 0) {
      return;
    }
    if (!this.view && typeof(document) !== 'undefined') {
      this._refreshViewModel(false);
      this.view = new NodeView({model: this.model});
    }
    if (this.getChildren()) {
      _.each(this.getChildren(), function (child) {
        child._createView();
      });
    }
  },
  _closeView: function (recursive) {
    if (recursive) {
      _.each(this.getChildren(), function (child) {
        child._closeView(recursive);
      });
    }
    if (this.view) {
      this.view.close();
      this.view = null;
    }
  },
  /**
   * Generate the size and position of each child of this node
   * @param x
   * @param y
   * @param width
   * @param height
   * @param recursive
   * @private
   */
  _generateChildrenTreemap: function (x, y, width, height, recursive) {
    if (window.PryvBrowser && window.PryvBrowser.customConfig) {
      this.minWidth = DEFAULT_MIN_WIDTH > 0 && DEFAULT_MIN_WIDTH <= 1 ?
        DEFAULT_MIN_WIDTH * $(window).width() : DEFAULT_MIN_WIDTH;
      this.minHeight = DEFAULT_MIN_HEIGHT > 0 && DEFAULT_MIN_HEIGHT <= 1 ?
        DEFAULT_MIN_HEIGHT * $(window).height() : DEFAULT_MIN_HEIGHT;
    }
    if (this.getWeight() === 0) {
      return;
    }
    if (this._needToAggregate() && !this.aggregated) {
      this._aggregate();
    }
    if (!this._needToAggregate() && this.aggregated) {
      this._desaggregate();
    }
    var children = this.getChildren();
    if (children) {
      // we need to normalize child weights by the parent weight
      var weight = this.getWeight();
      _.each(children, function (child) {
        child.normalizedWeight = (child.getWeight() / weight);
      }, this);

      // we squarify all the children passing a container dimension and position
      // no recursion needed
      var squarified =  TreemapUtil.squarify({
        x: x,
        y: y + this.offset,
        width: width,
        height: height - this.offset
      }, children);
      _.each(children, function (child) {
        var w = squarified[child.uniqueId].width,
            h = squarified[child.uniqueId].height;
        child.x = squarified[child.uniqueId].x;
        child.y = squarified[child.uniqueId].y;
        child.width = w;
        child.height = h;
        if (w !== this.width) {
          child.width -= this.margin / 2;
        }
        if (h !== this.height - this.offset) {
          child.height -= this.margin / 2;
        }
        if (child.x !== 0 && child.x + w !== this.width) {
          child.width -= this.margin / 2;
        }
        if (child.y !== this.offset && child.y + h !== this.height) {
          child.height -= this.margin / 2;
        }
        if (child.x !== 0) { child.x += this.margin / 2; }
        if (child.y !== this.offset) { child.y += this.margin / 2; }
      }, this);

      _.each(children, function (child) {
        if (recursive) {
          child._generateChildrenTreemap(0, 0, child.width, child.height, true);
        }
      }, this);
    }
  },
  _needToAggregate: function () {
    this.aggregated = false;
    return this.aggregated;
  },
  _aggregate: function () {
    return;
  },
  _desaggregate: function () {
    return;
  },
  /** Render or close the view if needed
   For more performance we need to render or close views once all processing are done
   i.e: when eventLeaveScope is trigged and a eventsNode becomes empty if we close it right away
   it result with a unpleasant visual with div disappears randomly.
   So we need to close all the view at the same time.
   */
  renderView: function (recurcive) {
    /** If the node has no events to display (getWeight = 0) we close it **/
    if (this.getWeight() === 0) {
      this.aggregated = false; // Reset the aggregation to false;
      if (this.eventView) {
        this.eventView.close();
        this.eventView = null;
      }
      if (this.view) {
        this.view.close();
        this.view = null;
      }
    } else {
      // Test is the view is not already displayed and the view is not null
      if ($('#' + this.uniqueId).length === 0 && this.view) {
        this.view.renderView();
        // event listenner for focus on stream when clicked on it
        // i.e display only this stream when clicked on it
        this.view.on('headerClicked', function () {
          if (this.stream) {
            this.treeMap.focusOnStreams(this.stream);
          }
          else if (this.connection) {
            this.treeMap.focusOnConnections(this.connection);
          }
        }, this);
        this.view.on('streamConfigClicked', function () {
          var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
            this.treeMap.closeStreamView();
          }.bind(this));
          this.treeMap.showStreamView($modal, this.stream, this.view.$el);
        }, this);
      }
    }
    if (recurcive) {
      _.each(this.getChildren(), function (child) {
        child.renderView(true);
      });
    }
  },
  /**
   * Refresh the model of the view and create it if there is no
   * If the model change this will automatically update the view thanks to backbone
   * @param recursive
   * @private
   */
  _refreshViewModel: function (recursive) {
    if (!this.model) {
      var BasicModel = Backbone.Model.extend({ });
      this.model = new BasicModel({
        containerId: this.parent ? this.parent.uniqueId : MAIN_CONTAINER_ID,
        id: this.uniqueId,
        className: this.className,
        width: this.width,
        height: this.height,
        x: this.x,
        y: this.y,
        depth: this.depth,
        weight: this.getWeight(),
        content: this.events || this.stream || this.connection,
        eventView: this.eventView
      });
    } else {
      // TODO For now empty nodes (i.e streams) are not displayed
      // but we'll need to display them to create event, drag drop ...
      /*if (this.getWeight() === 0) {
       if (this.model) {
       this.model.set('width', 0);
       this.model.set('height', 0);
       }
       return;
       } */
      this.model.set('containerId', this.parent ? this.parent.uniqueId : MAIN_CONTAINER_ID);
      this.model.set('id', this.uniqueId);
      this.model.set('name', this.className);
      this.model.set('width', this.width);
      this.model.set('height', this.height);
      this.model.set('x', this.x);
      this.model.set('y', this.y);
      this.model.set('depth', this.depth);
      this.model.set('weight', this.getWeight());
      if (this.eventView) {
        this.eventView.refresh({
          width: this.width,
          height: this.height
        });
      }
    }
    if (recursive && this.getChildren()) {
      _.each(this.getChildren(), function (child) {
        child._refreshViewModel(true);
      });
    }
  },



  //-------------- Tree Browsing -------------------//

  /**
   * @return TreeNode parent or null if root
   */
  getParent: function () {
    return this.parent;
  },

  /**
   * @return Array of TreeNode or null if leaf
   */
  getChildren: function () {
    throw new Error(this.className + ': getChildren must be implemented');
  },


  /**
   * Return the total weight (in TreeMap referential) of this node and it's children
   * This should be overwritten by Leaf nodes
   * @return Number
   */
  getWeight: function () {
    if (this.getChildren() === null) {
      throw new Error(this.className + ': Leafs must overwrite getWeight');
    }
    var weight = 0;
    this.getChildren().forEach(function (child) {
      weight += child.getWeight();
    });
    return weight;
  },



  //----------- event management ------------//
  onDateHighLighted: function (time) {
    _.each(this.getChildren(), function (child) {
      child.onDateHighLighted(time);
    });
  },
  /**
   * Add an Event to the Tree
   * @param event Event
   * @return TreeNode the node in charge of this event. To be handled directly,
   * next event addition or renderView() call can modify structure, and change
   * the owner of this Event. This is designed for animation. .. add event then
   * call returnedNode.currentWarpingDOMObject()
   */
  eventEnterScope: function () {
    throw new Error(this.className + ': eventEnterScope must be implemented');
  },

  /**
   * the Event changed from the Tree
   * @param event Event or eventId .. to be discussed
   */
  eventChange: function () {
    throw new Error(this.className + ': eventChange must be implemented');
  },

  /**
   * Event removed
   * @parma eventChange
   */
  eventLeaveScope: function () {
    throw new Error(this.className + ': eventLeaveScope must be implemented');
  },
  //----------- debug ------------//
  _debugTree : function () {
    var me = {
      className : this.className,
      weight : this.getWeight()
    };
    if (this.getChildren()) {
      me.children = [];
      _.each(this.getChildren(), function (child) {
        me.children.push(child._debugTree());
      });
    }
    return me;
  }
});

try {
  window.PryvBrowser = _.extend({}, window.PryvBrowser);
  Object.defineProperty(window.PryvBrowser, 'minWidth', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_MIN_WIDTH = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      if (DEFAULT_MIN_WIDTH > 0 && DEFAULT_MIN_WIDTH <= 1) {
        return 'ratio: ' + DEFAULT_MIN_WIDTH + ' absolute: ' +
          DEFAULT_MIN_WIDTH * $(window).width();
      } else {
        return 'absolute: ' + DEFAULT_MIN_WIDTH;
      }
    }
  });
  Object.defineProperty(window.PryvBrowser, 'minHeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_MIN_HEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      if (DEFAULT_MIN_HEIGHT > 0 && DEFAULT_MIN_HEIGHT <= 1) {
        return 'ratio: ' + DEFAULT_MIN_HEIGHT + ' absolute: ' +
          DEFAULT_MIN_HEIGHT * $(window).height();
      } else {
        return 'absolute: ' + DEFAULT_MIN_HEIGHT;
      }
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}

},{"../utility/treemap.js":136,"../view/NodeView.js":137,"backbone":5,"underscore":104}],125:[function(require,module,exports){
var Pryv = require('pryv');
var _ = require('underscore');


/* Definition of a virtual node attached to a stream as its child
 *  stream: <streamId>, // the node where it's attached to
 *  name: <my name>,    // the name of that virtual node
 *  filters: [          // an array of filter/setting pairs contained in this virtual node
 *    { filter: f1,
 *      settings:             // settings of that filter, such as color,
 *        [{ color: 'green', // style, ... (especially for charts)
 *        style: 'bar',
 *         ... }, {}]
 *    },
 *    { filter: f2, settings: {...}},
 *    ...
 *   ]
 *   Note:
 *   The filters are ofa special kind. Each filter concerns exactly one type.
 *   The settings override the stream/type pair's default one. Numerical data
 *   would contain style (line, bar, ..), color, transform.
 */

var KEY = 'browser:virtualnode';
var SERIAL = 0;
var VirtualNode = module.exports = function VirtualNode(node, name) {
  this._node = node;
  this._name = name;
  this.id = 'vn_' + SERIAL;
  SERIAL++;

  this._createIfNotExist();
  this._emptyData();
};

VirtualNode.prototype._emptyData = function () {
  if (this._node instanceof Pryv.Connection) {
    this._node.privateProfile()[KEY] = [];
  } else if (this._node instanceof Pryv.Stream) {
    this._node.clientData[KEY] = [];
  }
  this._pushChanges();
};

VirtualNode.prototype._integrity = function () {
  if (!this._node) {
    throw new Error('_integrity: Node does not exists');
  }
};

VirtualNode.prototype._createIfNotExist = function () {
  var data = null;
  if (this._node instanceof Pryv.Connection) {
    data = this._node.privateProfile();
  } else if (this._node instanceof Pryv.Stream) {
    data = this._node.clientData;
  }

  if (!data[KEY]) {
    data[KEY] = [];
  }
  data = data[KEY];

  var found = false;
  for (var i = 0; i < data.length; ++i) {
    if (data[i].name === this._name) {
      found = true;
      break;
    }
  }
  if (!found) {
    data.push({name: this._name, filters: []});
  }
};

VirtualNode.prototype._getDataPointer = function () {
  var data = null;
  if (this._node instanceof Pryv.Connection) {
    data = this._node.privateProfile()[KEY];
  } else if (this._node instanceof Pryv.Stream) {
    data = this._node.clientData[KEY];
  }
  return data;
};

VirtualNode.prototype._pushChanges = function () {
  this._integrity();
  var changes = null;
  if (this._node instanceof Pryv.Connection) {
    changes = {'browser:virtualnode': this._getDataPointer()};
    console.log('Pushing these changes in privateProfile', changes);
    this._node.profile.setPrivate(changes, function (error, result) {
      console.log('privateProfile for', KEY, 'has been pushed:', error, result);
    });
  } else if  (this._node instanceof Pryv.Stream) {
    changes = {id: this._node.id, clientData: this._node.clientData};
    console.log('Pushing these changes in clientData', changes);
    this._node.connection.streams._updateWithData(changes, function (error, result) {
      console.log('clientData for', KEY, 'has been pushed:', error, result);
    });
  }
};

Object.defineProperty(VirtualNode.prototype, 'filters', {
  get: function () {
    var d = this._getDataPointer();
    for (var i = 0; i < d.length; ++i) {
      if (d[i].name === this._name) {
        return d[i].filters;
      }
    }
    return [];
  },
  set: function (filters) {
    var d = this._getDataPointer();
    for (var i = 0; i < d.length; ++i) {
      if (d[i].name === this._name) {
        d[i].filters = filters;
        this._pushChanges();
        break;
      }
    }
  }
});


Object.defineProperty(VirtualNode.prototype, 'name', {
  get: function () {
    return this._name;
  },
  set: function (name) {
    var d = this._getDataPointer();
    for (var i = 0; i < d.length; ++i) {
      if (d[i].name === this._name) {
        d[i].name = name;
        this._name = name;
        this._pushChanges();
        break;
      }
    }
  }
});

Object.defineProperty(VirtualNode.prototype, 'parent', {
  get: function () {
    return this._node;
  },
  set: function () {
    throw new Error('Virtual nodes having connection as parent not supported.');
  }
});

VirtualNode.prototype.addFilters = function (filter) {
  this._integrity();
  var d = this._getDataPointer();
  if (filter && filter.length !== 0) {
    var found = false;
    filter = (filter instanceof Array) ? filter : [filter];
    for (var i = 0, n = d.length; i < n; ++i) {
      if (d[i].name === this._name) {
        found = true;
        break;
      }
    }

    if (found) {
      if (!d[i].filters) {
        d[i].filters = [filter];
      } else {
        for (var j = 0; j < filter.length; ++j) {
          d[i].filters.push(filter[j]);
        }
      }
    } else {
      d.push({name: this._name, filters: filter});
    }
    this._pushChanges();
  }
};





/*
 * Static testing and accessing functions
 */


/**
 * Extracts and creates an interface between the node and its virtual nodes
 * @param node the node, can be a stream or a connection
 * @returns {*}
 */
VirtualNode.getNodes = function (node) {
  var vn = [];
  var data = null;
  if (node instanceof Pryv.Connection) {
    data = node.privateProfile()[KEY];
    if (!data) {
      return vn;
    }
  } else if (node instanceof Pryv.Stream) {
    if (node.clientData && node.clientData[KEY]) {
      data = node.clientData[KEY];
    } else {
      return vn;
    }
  }
  _.each(data, function (e) {
    if (e.name) {
      vn.push(new VirtualNode(node, e.name));
    }
  });
  return vn;
};


/**
 * Checks if node has virtual children.
 * @param node a connection or stream
 * @returns {*}
 */
VirtualNode.nodeHas = function (node) {
  if (node instanceof Pryv.Connection) {
    var pp = node.privateProfile();
    return (pp[KEY] ? true : false);
  } else if (node instanceof Pryv.Stream) {
    return (node.clientData) && (node.clientData[KEY]) &&
      (node.clientData[KEY].length !== 0);
  } else {
    return false;
  }
};

},{"pryv":50,"underscore":104}],126:[function(require,module,exports){
/* global window */
var EventsNode = require('../EventsNode'),
  EventsView = require('../../view/events-views/activities/Model.js'),
  _ = require('underscore'),
  DEFAULT_WEIGHT = 1;

/**
 * Holder for EventsNode
 * @type {*}
 */
var ActivitiesEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'ActivityEventsNode EventsNode',
    pluginView: EventsView,
    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
ActivitiesEventsNode.acceptThisEventType = function (eventType) {
  return (
    eventType === 'activity/pryv' ||
    eventType === 'activity/plain'
    );
};
try {
  Object.defineProperty(window.PryvBrowser, 'activityWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}


},{"../../view/events-views/activities/Model.js":144,"../EventsNode":120,"underscore":104}],127:[function(require,module,exports){
/* global window */
var EventsNode = require('../EventsNode'),
  _ = require('underscore'),
  EventsView = require('../../view/events-views/generics/Model.js');


/**
 * Holder for EventsNode
 * @type {*}
 */
var DEFAULT_WEIGHT = 1;
var GenericEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'GenericEventsNode EventsNode',
    pluginView: EventsView,
    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
GenericEventsNode.acceptThisEventType = function (/*eventType*/) {
  return true;
};
try {
  Object.defineProperty(window.PryvBrowser, 'genericWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}

},{"../../view/events-views/generics/Model.js":167,"../EventsNode":120,"underscore":104}],128:[function(require,module,exports){
/* global window */
var EventsNode = require('../EventsNode'),
  EventsView = require('../../view/events-views/notes/Model.js'),
  _ = require('underscore'),
  DEFAULT_WEIGHT = 1;

/**
 * Holder for EventsNode
 * @type {*}
 */
var NotesEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'NotesEventsNode EventsNode',
    pluginView: EventsView,
    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
NotesEventsNode.acceptThisEventType = function (eventType) {
  return (eventType === 'note/txt' || eventType === 'note/text');
};
try {
  Object.defineProperty(window.PryvBrowser, 'noteWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}


},{"../../view/events-views/notes/Model.js":169,"../EventsNode":120,"underscore":104}],129:[function(require,module,exports){
/* global window */
var EventsNode = require('../EventsNode'),
  EventsView = require('../../view/events-views/numericals/Model.js'),
  _ = require('underscore'),
  DEFAULT_WEIGHT = 1;

/**
 * Holder for EventsNode
 * @type {*}
 */
var NumericalsEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'NumericalsEventsNode EventsNode',
    pluginView: EventsView,
    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
NumericalsEventsNode.acceptThisEventType = function (eventType) {
  return window.PryvBrowser.eventTypes.isNumerical(eventType);
};
try {
  Object.defineProperty(window.PryvBrowser, 'numericalWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}


},{"../../view/events-views/numericals/Model.js":173,"../EventsNode":120,"underscore":104}],130:[function(require,module,exports){
/*global window */
var EventsNode = require('../EventsNode'),
  EventsView = require('../../view/events-views/pictures/Model.js'),
  _ = require('underscore'),
  DEFAULT_WEIGHT = 1;

/**
 * Holder for EventsNode
 * @type {*}
 */
var PicturesEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'PicturesEventsNode EventsNode',
    pluginView: EventsView,

    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
PicturesEventsNode.acceptThisEventType = function (eventType) {
  return (eventType === 'picture/attached');
};
try {
  Object.defineProperty(window.PryvBrowser, 'pictureWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}


},{"../../view/events-views/pictures/Model.js":178,"../EventsNode":120,"underscore":104}],131:[function(require,module,exports){
/* global window */
var EventsNode = require('../EventsNode'),
  EventsView = require('../../view/events-views/positions/Model.js'),
  _ = require('underscore'),
  DEFAULT_WEIGHT = 1;

/**
 * Holder for EventsNode
 * @type {*}
 */
var PositionsEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'PositionsEventsNode EventsNode',
    pluginView: EventsView,
    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
PositionsEventsNode.acceptThisEventType = function (eventType) {
  return (eventType === 'position/wgs84');
};
try {
  Object.defineProperty(window.PryvBrowser, 'positionWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}


},{"../../view/events-views/positions/Model.js":180,"../EventsNode":120,"underscore":104}],132:[function(require,module,exports){
/* global window */
var EventsNode = require('../EventsNode'),
  EventsView = require('../../view/events-views/tweet/Model.js'),
  _ = require('underscore'),
  DEFAULT_WEIGHT = 1;

/**
 * Holder for TweetsNode
 * @type {*}
 */
var TweetsEventsNode = module.exports = EventsNode.implement(
  function (parentStreamNode) {
    EventsNode.call(this, parentStreamNode);
  },
  {
    className: 'TweetsEventsNode EventsNode',
    pluginView: EventsView,
    getWeight: function () {
      return DEFAULT_WEIGHT;
    }

  });

// we accept all kind of events
TweetsEventsNode.acceptThisEventType = function (eventType) {
  return (eventType === 'message/twitter');
};
try {
  Object.defineProperty(window.PryvBrowser, 'tweetWeight', {
    set: function (value) {
      value = +value;
      if (_.isFinite(value)) {
        this.customConfig = true;
        DEFAULT_WEIGHT = value;
        if (_.isFunction(this.refresh)) {
          this.refresh();
        }
      }
    },
    get: function () {
      return DEFAULT_WEIGHT;
    }
  });
} catch (err) {
  console.warn('cannot define window.PryvBrowser');
}


},{"../../view/events-views/tweet/Model.js":183,"../EventsNode":120,"underscore":104}],133:[function(require,module,exports){
/* global moment */
var _ = require('underscore');

var dateTime = module.exports = {};

/**
 * Returns human-readable text for the given time.
 *
 * @param {number} unixTime
 * @returns {string}
 */
dateTime.getTimeText = function (unixTime) {
  return moment ?
      moment.unix(unixTime).calendar() : new Date(unixTime * 1000).toLocalDateString();
};

/**
 * Returns human-readable HTML text for the given duration.
 *
 * @param {number} unixDuration
 * @param {object} options `nbValues` (number): max number of date parts to include (default: all),
 *                         `html` (boolean): enable HTML formatting (default: false),
 *                         `separateLines` (boolean): if HTML formatting enabled, adds line breaks
 *                                                    between parts (default: false)
 * @returns {string}
 * @example HTML: "<strong>1</strong> hour <strong>33</strong> minutes"
 */
dateTime.getDurationText = function (unixDuration, options) {
  if (! options) { options = {}; }

  var words = moment.preciseDiff(moment.unix(0), moment.unix(unixDuration))
      .split(' ')
      .splice(0, (options.nbValues || 2) * 2);
  if (options.html) {
    words = words.map(function (s, i) {
      return i % 2 === 0 ?
          '<strong>' + s + '</strong>' : options.separateLines ? s + '<br>' : s;
    });
  }
  return words.join(' ');
};

var TickIntervalForScale = {
  day: 'hour',
  week: 'dayOfWeek',
  month: 'week',
  year: 'month',
  custom: null // dynamically determined
};

var TickIntervals = {
  hour: {
    format: 'H',
    momentKey: 'h',
    interval: 1000 * 60 * 60
  },
  dayOfWeek: {
    format: 'ddd',
    momentKey: 'd',
    interval: 1000 * 60 * 60 * 24
  },
  week: {
    format: 'ddd D.M',
    momentKey: 'w',
    interval: 1000 * 60 * 60 * 24 * 7
  },
  month: {
    format: 'MMM',
    momentKey: 'M'
  },
  year: {
    format: 'YYYY',
    momentKey: 'y'
  }
};

var TickSettings = {};
_.each(TickIntervals, function (iValue, iKey) {
  TickSettings[iKey] = {
    getLabel: function (msTime) {
      return moment(msTime || this.value).format(iValue.format);
    },
    getValues: function (fromMsTime, toMsTime) {
      var values = [fromMsTime],
          currentM = moment(fromMsTime);
      while (+currentM <= toMsTime) {
        values.push(+currentM);
        currentM.add(1, iValue.momentKey);
      }
      return values;
    }
  };
});

/**
 * Returns time series tick settings for the given scale and time frame.
 * The returned object has functions:
 *
 * - `getLabel(msTime)` (argument `msTime` can be replaced by binding the value to `this.value`)
 * - `getValues(fromMsTime, toMsTime)`
 *
 * @param {string} timeScale The scale name (as used in the time selector)
 * @param {number} fromMsTime Start of time frame
 * @param {number} toMsTime End of time frame
 * @returns {object}
 */
dateTime.getTickSettings = function (timeScale, fromMsTime, toMsTime) {
  var interval = TickIntervalForScale[timeScale];
  if (! interval) {
    // custom scale
    var duration = moment.duration(toMsTime - fromMsTime);
    if (duration.years() >= 2) {
      interval = 'year';
    } else if (duration.months() >= 2) {
      interval = 'month';
    } else if (duration.days() >= 14) {
      interval = 'week';
    } else if (duration.days() >= 2) {
      interval = 'dayOfWeek';
    } else {
      interval = 'hour';
    }
  }
  return TickSettings[interval];
};

},{"underscore":104}],134:[function(require,module,exports){
var dateTime = require('./dateTime'),
    streamUtils = require('./streamUtils');

/**
 * To hold temporary refactored utility functions, until we have proper file structure with
 * fully separate modules for each event type (cf. https://trello.com/c/0P6lmhsS/299).
 */
var eventUtils = module.exports = {};

eventUtils.getActivityPreview = function (event) {
  var html =  '<span class="pins-color 1" style="background-color: ' +
      streamUtils.getColor(event.stream) + '"></span> ' +
      event.stream.name + '<br>';
  if (event.duration !== null) {
    html += dateTime.getDurationText(event.duration, {
      html: true,
      nbValues: 2
    });
  } else {
    html += '(running time)';
  }
  return html;
};

},{"./dateTime":133,"./streamUtils":135}],135:[function(require,module,exports){
var streamUtils = module.exports = {};

var BgColorClientDataKey = streamUtils.BgColorClientDataKey = 'pryv-browser:bgColor',
    ChartClientDataKey = streamUtils.ChartClientDataKey = 'pryv-browser:charts';

/**
 * Gets the stream's color (if any) from its client data.
 *
 * @param {Stream} stream
 * @param {boolean} lookupAncestors If true, the stream's color will fall back to that of the
 *                                  nearest ancestor, if any (default: true)
 * @returns {string} The hex color code (e.g. "#FFF")
 */
streamUtils.getColor = function (stream, lookupAncestors) {
  if (! stream) { return ''; }

  if (stream.clientData && stream.clientData[BgColorClientDataKey]) {
    return stream.clientData[BgColorClientDataKey];
  }
  if (lookupAncestors !== false && stream.parent) {
    return streamUtils.getColor(stream.parent);
  }
  return '';
};

/**
 * Sets the stream's color (initializing client data if needed).
 *
 * @param stream
 * @param {string} color Hex color code
 * @returns {string} The color
 */
streamUtils.setColor = function (stream, color) {
  if (! stream.clientData) {
    stream.clientData = {};
  }
  stream.clientData[BgColorClientDataKey] = color;
  return color;
};

/**
 * Gets the stream's chart settings for the given event type, if any.
 *
 * @param {Stream} stream
 * @param {string} type
 * @returns {object} The chart settings object, or null if not found
 */
streamUtils.getChartSettingsForType = function (stream, type) {
  if (! stream || ! stream.clientData || ! stream.clientData[ChartClientDataKey] ||
      ! stream.clientData[ChartClientDataKey][type]) {
    return null;
  }

  return stream.clientData[ChartClientDataKey][type].settings || null;
};

/**
 * Sets the stream's chart settings for the given event type (initializing client data if needed).
 *
 * @param {Stream} stream
 * @param {string} type
 * @param {object} settings
 * @returns {object} The settings
 */
streamUtils.setChartSettingsForType = function (stream, type, settings) {
  if (! stream.clientData) {
    stream.clientData = {};
  }
  if (! stream.clientData[ChartClientDataKey]) {
    stream.clientData[ChartClientDataKey] = {};
  }
  if (! stream.clientData[ChartClientDataKey][type]) {
    stream.clientData[ChartClientDataKey][type] = {};
  }
  stream.clientData[ChartClientDataKey][type].settings = settings;
  return settings;
};

},{}],136:[function(require,module,exports){

var _ = require('underscore');
var TreemapUtils = module.exports = TreemapUtils || {};
TreemapUtils.sumArray = function (nodes) {
  // Use one adding function rather than create a new one each
  // time sumArray is called.
  return _.reduce(TreemapUtils._extractWeight(nodes), function (memo, num) {
    return memo + num;
  }, 0);

};
TreemapUtils._getMaxWeight = function (nodes) {
  return Math.max.apply(null, TreemapUtils._extractWeight(nodes));
};
TreemapUtils._getMinWeight = function (nodes) {
  return Math.min.apply(null, TreemapUtils._extractWeight(nodes));
};
TreemapUtils._extractWeight = function (nodes) {
  var result = [];
  _.each(nodes, function (node) {
    result.push(node.normalizedWeight);
  });
  return result;
};
//
// Treemap squarify layout function.
//  rect - containing rectangle; an array of 4 values x, y, width, height
//  vals - array of (normalized) float values each representing percent contribution to
//  total area of containing rectangle
//
// Non-recursive implementation of the squarify treemap layout algorithm published in:
// "Squarified Treemaps" by Mark Bruls, Kees Huizing and Jarke J. van Wijk
// http://www.win.tue.nl/~vanwijk/stm.pdf
//
// Includes tips and tricks from:
// http://ejohn.org/blog/fast-javascript-maxmin/#postcomment
//
TreemapUtils.squarify = function (rect, vals) {
  // console.log('squrify begin');

  var Subrectangle = function (rect) {
    this.setX = function (x) {
      rect.width -= x - rect.x;
      rect.x = x;
    };
    this.setY = function (y) {
      rect.height -= y - rect.y;
      rect.y = y;
    };
    this.getX = function () {
      return rect.x;
    };
    this.getY = function () {
      return rect.y;
    };
    this.getW = function () {
      return rect.width;
    };
    this.getH = function () {
      return rect.height;
    };
    this.getWidth = function () {
      return Math.min(rect.width, rect.height);
    };
  };
  //
  // The function worst() gives the highest aspect ratio of a list
  // of rectangles, given the length of the side along which they are to
  // be laid out.
  // Let a list of areas R be given and let s be their total sum. Then the function worst is
  // defined by:
  // worst(R,w) = max(max(w^2r=s^2; s^2=(w^2r)))
  //              for all r in R
  // Since one term is increasing in r and the other is decreasing, this is equal to
  //              max(w^2r+=(s^2); s^2=(w^2r-))
  // where r+ and r- are the maximum and minimum of R.
  // Hence, the current maximum and minimum of the row that is being laid out.
  //
  var worst = function (r, w) {
    var rMax = TreemapUtils._getMaxWeight(r);
    var rMin = TreemapUtils._getMinWeight(r);

    var s = TreemapUtils.sumArray(r);
    var sSqr = s * s;
    var wSqr = w * w;
    return Math.max((wSqr * rMax) / sSqr, sSqr / (wSqr * rMin));
  };

  // Take row of values and calculate the set of rectangles
  // that will fit in the current subrectangle.
  var layoutrow = function (row) {
    var x = subrect.getX(),
      y = subrect.getY(),
      maxX = x + subrect.getW(),
      maxY = y + subrect.getH(),
      rowHeight,
      i,
      w;

    if (subrect.getW() < subrect.getH()) {
      rowHeight = Math.ceil(TreemapUtils.sumArray(row) / subrect.getW());
      if (y + rowHeight >= maxY) { rowHeight = maxY - y; }
      for (i = 0; i < row.length; i++) {
        w = Math.ceil(row[i].normalizedWeight  / rowHeight);
        if (x + w > maxX || i + 1 === row.length) { w = maxX - x; }
        layout[row[i].uniqueId] = {x: x, y: y, width: w, height: rowHeight};

        x = (x + w);
      }
      subrect.setY(y + rowHeight);
    } else {
      rowHeight = Math.ceil(TreemapUtils.sumArray(row) / subrect.getH());
      if (x + rowHeight >= maxX) { rowHeight = maxX - x; }
      for (i = 0; i < row.length; i++) {
        w = Math.ceil(row[i].normalizedWeight  / rowHeight);
        if (y + w > maxY || i + 1 === row.length) { w = maxY - y; }
        // layout.push({x: x, y: y, width: rowHeight, height: w});
        layout[row[i].uniqueId] = {x: x, y: y, width: rowHeight, height: w};

        y = (y + w);
      }
      subrect.setX(x + rowHeight);
    }
  };

  // Pull values from input array until the aspect ratio of rectangles in row
  // under construction degrades.
  var buildRow = function (children) {
    var row = [];
    row.push(children.shift()); // descending input
    //row.push(children.pop()); // ascending input
    if (children.length === 0) {
      return row;
    }
    var newRow = row.slice();
    var w = subrect.getWidth();
    do {
      newRow.push(children[0]); // descending input
      //newRow.push(children[children.length-1]); // ascending input
      //  console.log('worst');
//      console.log(worst(row, w));
      if (worst(row, w) > worst(newRow, w)) {
        row = newRow.slice();
        children.shift(); // descending input
        //children.pop(); // ascending input
      }
      else {
        break;
      }
    } while (children.length > 0);
    return row;
  };

  // Non recursive version of Bruls, Huizing and van Wijk
  // squarify layout algorithim.
  // While values exist in input array, make a row with good aspect
  // ratios for its values then caclulate the row's geometry, repeat.
  var nrSquarify = function (children) {
    do {
      layoutrow(buildRow(children));
    } while (children.length > 0);
  };


  var layout = {};
  var newVals;

  newVals =  _.clone(_.sortBy(vals, function (num) {
    return num.normalizedWeight;
  }).reverse());

  var i;

  // if either height or width of containing rect are <= 0
  // simply copy containing rect to layout rects
  if (rect.width <= 0 || rect.height <= 0) {
    for (i = 0; i < vals.length; i++) {
      layout[vals[i].uniqueId] = rect;
    }
  } else { // else compute squarified layout
    _.each(newVals, function (val) {
      val.normalizedWeight = Math.round(val.normalizedWeight * rect.width * rect.height);

    });
    // vals come in normalized. convert them here to make them relative to containing rect
    // newVals = vals.map(function(item){return item*(rect.width*rect.height);});
    var subrect = new Subrectangle(rect);
    nrSquarify(newVals);
  }
  return layout;
};
},{"underscore":104}],137:[function(require,module,exports){
/* global $ */
var  Marionette = require('backbone.marionette');
 /* TODO This a the view for each node, with dynamic animation
 we can't re-render on change because animation would no be done
 If the model is a event Node we must include a new typed view
 */
module.exports = Marionette.ItemView.extend({
  template: '#nodeView',
  initialize: function () {
    this.listenTo(this.model, 'change', this.change);

    this.$el.attr('id', this.model.get('id'));
    this.$el.attr('data-streamId', this.model.get('streamId'));
    this.$el.attr('data-streamName', this.model.get('streamName'));
    this.$el.attr('data-connectionId', this.model.get('connectionId'));
    this.$el.addClass('node animated  fadeIn');
    this.$el.addClass(this.model.get('className'));

  },
  triggers: {
    'click .nodeHeader': 'headerClicked',
    'click .streamConfig' : 'streamConfigClicked'
  },
  change: function () {

    this._refreshStyle();
  },

  renderView: function () {

    this.render();
  },
  render: function () {
    if (this.beforeRender) { this.beforeRender(); }
    this.trigger('before:render', this);
    this.trigger('item:before:render', this);
    this._refreshStyle();
    var data = this.serializeData();
    var template = this.getTemplate();
    var html = Marionette.Renderer.render(template, data);
    this.$el.html(html);

    $('#' + this.model.get('containerId')).prepend(this.$el);
    if (this.model.get('eventView')) {
      this.model.get('eventView').render(this.model.get('id'));
    }
    this.bindUIElements();

    if (this.onRender) { this.onRender(); }
    this.trigger('render', this);
    this.trigger('item:rendered', this);
    return this;

  },
  _refreshStyle: function () {
    if (this.model.get('weight') === 0) {
      this.close();
      return;
    }
    this.$el.attr('weight', this.model.get('weight'));
    this.$el.attr('className', this.model.get('className'));
    this.$el.css('width', this.model.get('width'));
    this.$el.css('height', this.model.get('height'));
    this.$el.css('left', this.model.get('x'));
    this.$el.css('top', this.model.get('y'));


  },
  close: function () {

    this.$el.removeClass('animated  fadeIn');
    this.$el.addClass('animated  fadeOut');
    this.remove();
  }
});
},{"backbone.marionette":3}],138:[function(require,module,exports){
/* global window, i18n, $, localStorage, location*/
var Marionette = require('backbone.marionette');
var Backbone = require('backbone');
var _ = require('underscore');

var GridRow = Marionette.ItemView.extend({
  template: '#other-apps-item-settings-template',
  tagName: 'div',
  className: 'col-sm-6 col-md-4'
});



var App = Backbone.Model.extend({});

var AppList = Backbone.Collection.extend({
  model: App
});

var allList = new AppList([]);


// The grid view
module.exports = Marionette.CompositeView.extend({
  tagName: 'div',
  template: '#other-apps-list-template',
  itemView: GridRow,
  connection: null,
  myAppsId: null,
  apps: null,
  initialize: function () {
    this.myAppsId = [];
    this.apps = [];
    var sync = false;
    this.collection =  this.options.collection || allList;
    this.listenTo(allList, 'change', this.debounceRender);
    this.connection = this.options.connection;
    if (this.connection) {
      this.connection.accesses.get(function (error, result) {
        if (error) {
          window.PryvBrowser.showAlert('.modal-content',
            i18n.t('error.manageApps.' + error.id));
        } else {
          result.forEach(function (access) {
            if (access.type === 'app') {
              this.myAppsId.push(access.name);
            }
          }.bind(this));
          if (sync) {
            this.showAppList();
          } else {
            sync = true;
          }
        }
      }.bind(this));
      //var baseHref = $('base').attr('href');
      var domain = localStorage.getItem('domain') || 'pryv.me';
      var url = 'https://reg.' + domain + '/apps';
      $.get(url)
        .done(function (result) {
          result = result.apps || [];
          result.forEach(function (app) {
            this.apps.push(app);
          }.bind(this));
          if (sync) {
            this.showAppList();
          } else {
            sync = true;
          }
        }.bind(this))
        .fail(function () {
          window.PryvBrowser.showAlert('.modal-content',
            i18n.t('error.manageApps.cannot-load-app-list'));
        });

    }
  },
  showAppList: function () {
    this.apps.forEach(function (app) {
      if (this.myAppsId.indexOf(app.id) === -1) {
        if (app.appURL && app.appURL.length > 0 && app.trustedConnection) {
          app.appURL += '?username=' + this.connection.username + '&auth=' + this.connection.auth +
            '&domain=' + this.connection.settings.domain + '&returnUrl=' + location.href;
        }
        var m = new App({
          app: app
        });
        allList.add(m);
      }
    }.bind(this));
    this.debounceRender();
  },
  appendHtml: function (collectionView, itemView) {
    collectionView.$('#appList .panel-body').append(itemView.el);
  },
  onRender: function () {
    $('body').i18n();
  },
  reset: function () {
    this.collection.reset();
    allList.reset();
  },
  debounceRender: _.debounce(function () {
    this.render();
  }, 10)
});


},{"backbone":5,"backbone.marionette":3,"underscore":104}],139:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
    AppListView = require('./AppListView.js'),
    _ = require('underscore');

var Layout = Marionette.Layout.extend({
  template: '#apps-modal-template',

  regions: {
    otherApps: '#settings-other-apps'
  },
  initialize: function () {
    this.$el =  $('.modal-content');
  }
});
var Controller = module.exports  = function ($modal, connection, target) {
  this.connection = connection;
  this.$modal = $modal;
  this.target = target;
  this.view  = null;
  this.appList = null;


};
_.extend(Controller.prototype, {
  show: function () {
    this.$modal.modal({currentTarget: this.target});
    setTimeout(function () {
      $('.modal-content').fadeIn();
    }.bind(this), 500);
    this.view = new Layout();
    this.view.on('close', this.close.bind(this));
    this.appList = new AppListView({connection: this.connection});
    this.view.render();
    this.view.otherApps.show(this.appList);
  },
  close: function () {
    if (this.view) {
      this.view = null;
      $('.modal-content').empty();
      $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
      $('.modal-backdrop').remove();
      this.$modal.trigger('hidden.bs.modal');
      this.appList.reset();
    }
  }
});

},{"./AppListView.js":138,"backbone.marionette":3,"underscore":104}],140:[function(require,module,exports){
/* global $ */
var _ = require('underscore'),
  View = require('./View.js'),
  Model = require('./EventModel.js'),
  _ = require('underscore');

var Controller = module.exports = function ($modal, connection, focusedStream, target) {
  this.connection = connection;
  this.focusedStream = _.size(focusedStream) !== 1 ? null : focusedStream[0];
  if (!this.focusedStream) {
    _.each(this.connection._connections, function (c) {
      if (c._accessInfo && c._accessInfo.name === 'pryv-browser') {
        this.focusedStream = c.datastore.getStreamById('diary');
      }
    }.bind(this));
  }
  this.$modal = $modal;
  this.target = target;
  this.container = '.modal-content';
  this.view = null;
  this.newEvent = null;
};
_.extend(Controller.prototype, {
  show: function () {
    this.newEvent = new Model({event: this._defaultEvent()});
    this.$modal.modal({currentTarget: this.target});
    $(this.container).empty().hide();
    setTimeout(function () {
      $(this.container).fadeIn();
    }.bind(this), 500);
    $(this.container).append('<div class="modal-header">  ' +
      '<button type="button" class="close" data-dismiss="modal" aria-hidden="true">' +
      '&times;</button> ' +
      '<h4 class="modal-title" id="myModalLabel" ' +
      'data-i18n="events.common.labels.addEventTitle"></h4>' +
      '<div class="modal-close"></div> ' +
      '</div>' +
      '<div id="modal-content"></div>');
    this.view = new View({model: this.newEvent});
    this.view.connection = this.connection;
    this.view.focusedStream = this.focusedStream;
    this.view.render();
    this.view.on('close', this.close.bind(this));
    $('body').i18n();
  },
  close: function () {
    this.newEvent = null;
    if (this.view) {
      this.view.close();
      this.view = null;
      $(this.container).empty();
      $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
      $('.modal-backdrop').remove();
      this.$modal.trigger('hidden.bs.modal');
    }

  },
  _defaultEvent: function () {
    var result = {};
    result.time = new Date().getTime() / 1000;
    result.tags = [];
    result.content = null;
    result.desctiption = '';
    return result;
  }
});

},{"./EventModel.js":141,"./View.js":142,"underscore":104}],141:[function(require,module,exports){
/* global FormData */
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  defaults: {
    event: null
  },
  save: function () {
    var event = this.get('event'),
      file = event.file;
    if (file) {
      this.get('event').addAttachment(file, function () {
        //  console.log('trash event callback', arguments);
      });
    }
    event.update(function () {
      //  console.log('update event callback', arguments);
    });
  },
  create: function (callback, progressCallback) {
    var event = this.get('event'),
      file = event.file;
    if (file) {
      event.connection.events.createWithAttachment(event, file, callback, progressCallback);
    }  else {
      event.connection.events.create(event, callback);
    }
  },
  addAttachment: function (file) {
    var data = new FormData();
    data.append(file.name.split('.')[0], file);
    this.get('event').file = data;
    this.get('event').previewFile = file;
  },
  removeAttachment: function (fileName, callback) {
    this.get('event').removeAttachment(fileName, callback);
  }
});
},{"backbone":5}],142:[function(require,module,exports){
/* global $, FileReader, document, window, i18n, navigator*/
var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  Model = require('./EventModel.js'),
  MapLoader = require('google-maps'),
  creationStep = {typeSelect: 'typeSelect', streamSelect: 'streamSelect',
    pictureSelect: 'pictureSelect', eventEdit: 'eventEdit'},
  validType = ['note/txt', 'picture/attached', 'position/wgs84'],
  UNIQUE_ID = 0;

module.exports = Marionette.ItemView.extend({
  type: 'Creation',
  step: creationStep.typeSelect,
  className: 'full-height',
  pictureFile: null,
  focusedStream: null,
  newEvents: null,
  eventTime: null,
  eventType: null,
  google: null,
  connectionSelected: null,
  streamSelected: null,
  canPublish : true,
  getTemplate: function () {
    if (this.step === creationStep.typeSelect) {
      return '#template-detail-creation-type';
    } else if (this.step === creationStep.streamSelect) {
      return '#template-detail-creation-stream';
    } else if (this.step === creationStep.pictureSelect) {
      return '#template-detail-picture-select';
    } else if (this.step === creationStep.eventEdit) {
      return '#template-detail-creation-event';
    }
  },
  templateHelpers: function () {
    return {
      getStream: function () {
        return this.getStream();
      }.bind(this),
      getEventType: function () {
        return this.eventType.split('/')[0] || '';
      }.bind(this),
      getTypedView: function () {
        if (this.eventType === validType[2]) {
          this._initPositionView();
          return this._getPositionView();
        }
        if (this.eventType === validType[1]) {
          return this._getPictureView();
        }
        if (this.eventType === validType[0]) {
          return this._getNoteView();
        }
      }.bind(this)
    };
  },
  itemViewContainer: '#modal-content',
  ui: {
    type: '#type-select',
    fileElem: '#fileElem',
    fileSelect: '#fileSelect',
    stream: '.stream-tree-summary',
    inputStream: 'input.create-stream',
    selectStreamRadio: 'input.select-stream',
    publish: '#publish',
    cancel: '#cancel',
    spin: '.fa-spin',
    createStreamFrom: '.create-stream'
  },
  initialize: function () {
    this.step = creationStep.typeSelect;
  },
  onRender: function () {
    $(this.itemViewContainer).html($(this.el).fadeIn());
    this.ui.type.bind('click', this.onTypeClick.bind(this));
    this.ui.stream.bind('click', this.onStreamClick.bind(this));
    this.ui.fileSelect.bind('click', this.onFileSelectClick.bind(this));
    this.ui.fileElem.bind('change', this.onFileSelected.bind(this));
    this.ui.publish.bind('click', this.onPublishClick.bind(this));
    this.ui.cancel.bind('click', this.onCancelClick.bind(this));
    this.ui.inputStream.bind('keypress past', this.onInputStreamChange.bind(this));
    this.ui.createStreamFrom.bind('submit', function (e) {
      e.preventDefault();
      this.onPublishClick();
    }.bind(this));
    this.ui.spin.hide();
    this.ui.publish.prop('disabled', false);
    $('.td-progress').hide();
    if (this.step === creationStep.typeSelect) {
      _.each(this.connection._connections, function (conn) {
        if (conn._accessInfo && conn._accessInfo.type === 'personal') {
          conn.accesses.get(function (error, result) {
            if (!error) {
              result.forEach(function (access) {
                if (access.type === 'app' && access.name === 'pryv-csv-importer' &&
                  this.step === creationStep.typeSelect) {
                  this.$el.append('<div id="add-csv-importer">' +
                    '<a class="btn btn-default" target="_blank" ' +
                    'href="http://pryv.github.io/dev-tools/csv-importer">' +
                    i18n.t('events.common.actions.importCSV') +
                    '</a></div>');
                }
              }.bind(this));
            }
          }.bind(this));
        }
      }.bind(this));
    }
    else {
      $('#add-csv-importer').remove();
    }
    $('body').i18n();
  },
  _close: function () {
    this.trigger('close');
  },
  onInputStreamChange: function (e) {
    var currentValue = e.target.value;
    this.ui.selectStreamRadio.each(function (i, elem) {
      elem.checked = false;
    });
    this.ui.inputStream.val('');
    this.streamSelected = null;
    this.connectionSelected = null;
    $(e.target).parent().parent().find('input[type="radio"]').prop('checked', true);
    e.target.value = currentValue;
  },
  onPublishClick: function () {
    if (this.streamSelected && this.connectionSelected) {
      this.ui.spin.show();
      this.ui.publish.removeClass('btn-pryv-alizarin');
      this.ui.publish.prop('disabled', true);
      if (this.eventType === validType[2]) {
        this._publishPosition();
      }
      else if (this.eventType === validType[1]) {
        this._publishPicture();
      }
      else if (this.eventType === validType[0]) {
        this._publishNote();
      }
    } else {
      var input, parentId, name;
      /*jshint -W083 */
      for (var i = 0; i < this.ui.inputStream.length; i++) {
        input = $(this.ui.inputStream[i]);
        if (input.val().length > 0) {
          this.ui.spin.show();
          this.ui.publish.removeClass('btn-pryv-alizarin');
          this.ui.publish.prop('disabled', true);
          name = input.val().trim();
          parentId = input.attr('data-parentId') || null;
          this.connectionSelected = this.connection.get(input.attr('data-connection'));
          this.connectionSelected.streams.create({parentId: parentId, name: name},
            function (err, res) {
              if (err) {
                var errMsg;
                switch (err.id) {
                  case 'item-already-exists':
                    errMsg = i18n.t('events.common.messages.errStreamNameAlreadyExists');
                    break;
                  default:
                    errMsg = i18n.t('common.messages.errUnexpected');
                    window.PryvBrowser.reportError(err, {
                      component: 'event creation',
                      action: 'create stream'
                    });
                    break;
                }

                this.ui.publish.addClass('btn-pryv-alizarin');
                this.ui.spin.hide();
                this.ui.publish.prop('disabled', false);
                window.PryvBrowser.showAlert(this.itemViewContainer, errMsg);
                return;
              }

              this.streamSelected = res.id;
              this.onPublishClick();
            }.bind(this));
          break;
        }
      }
      if (! name) {
        window.PryvBrowser.showAlert(this.itemViewContainer,
          i18n.t('events.common.messages.errNoStreamSelected'));
      }
    }
  },

  _publishNote: function () {
    var event = this.newEvents.get('event');
    var tags = $('#tags-0').val().trim().split(',');
    var description = $('#description-0').val().trim();
    var content = $('#content-0').val();
    var time = new Date($('#edit-time-0').val()).getTime() / 1000;
    event.content = content;
    event.tags = tags;
    event.description = description;
    event.time = time;
    event.streamId = this.streamSelected;
    event.connection = this.connectionSelected;
    this.newEvents.create(function (err) {
      this.ui.spin.hide();
      this.ui.publish.prop('disabled', false);

      if (err) {
        window.PryvBrowser.reportError(err, {
          component: 'event creation',
          action: 'create note'
        });
        this.ui.publish.addClass('btn-pryv-alizarin');
        window.PryvBrowser.showAlert(this.itemViewContainer,
          i18n.t('common.messages.errUnexpected'));
        return;
      }

      this.ui.publish.removeClass('btn-pryv-alizarin');
      this._close();
    }.bind(this));
  },

  _publishPosition: function () {
    var event = this.newEvents.get('event');
    var tags = $('#tags-0').val().trim().split(',');
    var description = $('#description-0').val().trim();
    var time = new Date($('#edit-time-0').val()).getTime() / 1000;
    event.tags = tags;
    event.description = description;
    event.time = time;
    event.streamId = this.streamSelected;
    event.connection = this.connectionSelected;
    this.newEvents.create(function (err) {
      this.ui.spin.hide();
      this.ui.publish.prop('disabled', false);
      if (err) {
        window.PryvBrowser.reportError(err, {
          component: 'event creation',
          action: 'create position'
        });
        this.ui.publish.addClass('btn-pryv-alizarin');
        window.PryvBrowser.showAlert(this.itemViewContainer,
          i18n.t('common.messages.errUnexpected'));
        return;
      }

      this.ui.publish.removeClass('btn-pryv-alizarin');
      this._close();
    }.bind(this));
  },

  _publishPicture: function () {
    var self = this;
    if (!this.canPublish) {
      return;
    }
    this.canPublish = false;
    var asyncCount = this.newEvents.length;
    var create = function (model, $progressBar) {
      var error = false;
      model.create(function (err) {
          asyncCount--;
          $progressBar.removeClass('progress-striped', 'active');
          if (err) {
            error = true;
            window.PryvBrowser.reportError(err, {
              component: 'event creation',
              action: 'create picture'
            });
            window.PryvBrowser.showAlert(this.itemViewContainer,
              i18n.t('common.messages.errUnexpected'));
            $progressBar.find('.progress-bar')
              .css({'background-color': '#e74c3c', 'width' : '100%'});
          } else {
            $progressBar.find('.progress-bar')
              .css({'background-color': '#2ecc71', 'width' : '100%'});
            model.set('published', true);
          }
          if (error && asyncCount === 0) {
            self.ui.spin.hide();
            self.canPublish = true;
          } else if (!error && asyncCount === 0) {
            self.ui.spin.hide();
            self._close();
          }
        },
        function (e) {
          $progressBar.find('.progress-bar').css(
            {'width' : Math.ceil(100 * (e.loaded / e.total)) + '%'}
          );
        });
    };
    var tags, description, time, event, $progressBar;
    $('.td-tags, .td-time, .td-description').hide();
    $('.td-progress').show();
    for (var i = 0; i < this.newEvents.length; i++) {
      if (!this.newEvents[i].get('published')) {
        event = this.newEvents[i].get('event');
        $progressBar = $('#progress-' + i);
        $progressBar.addClass('progress-striped', 'active');
        $progressBar.find('.progress-bar').css({'background-color': '#2980b9', 'width' : '0%'});
        tags = $('#tags-' + i).val().trim().split(',');
        description = $('#description-' + i).val().trim();
        time = new Date($('#edit-time-' + i).val()).getTime() / 1000;
        event.tags = tags;
        event.description = description;
        event.time = time;
        event.streamId = this.streamSelected;
        event.connection = this.connectionSelected;
        create(this.newEvents[i], $progressBar);
      }
    }
  },

  onCancelClick: function () {
    this._close();
  },

  onStreamClick: function (e) {
    var streamSelected = $(e.target).attr('data-stream') ||
        $(e.target).parent().attr('data-stream') ||
        $(e.target).parent().parent().attr('data-stream'),
      connectionSelected = this.connection.get($(e.target).attr('data-connection') ||
        $(e.target).parent().attr('data-connection') ||
        $(e.target).parent().parent().attr('data-connection'));
    if (streamSelected && connectionSelected) {
      this.ui.inputStream.val('');
      $(e.target).find('input[type="radio"]').prop('checked', true);
    }
    this.streamSelected = streamSelected;
    if (connectionSelected) {
      this.connectionSelected = connectionSelected;
    }
    return true;
  },
  onTypeClick: function (e) {
    var typeSelected =  $(e.target).attr('data-type') || $(e.target).parent().attr('data-type'),
      event = this.model.get('event');

    if (validType.indexOf(typeSelected) !== -1) {
      event.type = this.eventType =  typeSelected;
      $('#myModalLabel').attr('data-i18n',
          'events.' + this.eventType.split('/')[0] + '.labels.addTitle');
      if (typeSelected === validType[1]) {
        this.step = creationStep.pictureSelect;
      } else  if (typeSelected === validType[2]) {
        MapLoader.KEY = 'AIzaSyCWRjaX1-QcCqSK-UKfyR0aBpBwy6hYK5M';
        MapLoader.load().then(function (google) {
          this.google = google;
        }.bind(this));
        this.step = creationStep.eventEdit;
      } else {
        this.step = creationStep.eventEdit;
      }
      this.render();
    }
    return true;
  },
  onFileSelectClick: function () {
    this.ui.fileElem.click();
  },
  onFileSelected: function (e) {
    var files = e.target.files;
    if (!files) {
      return false;
    }
    this.newEvents = [];
    _.each(files, function (file) {
      if (file.type.indexOf('image') !== -1) {
        var time = new Date().getTime() / 1000;
        if (file.lastModifiedDate) {
          time = file.lastModifiedDate.getTime() / 1000;
        }
        var model = new Model({event: {
          time: time,
          type: this.eventType,
          tags: [],
          content: null,
          description: ''
        }});
        model.addAttachment(file);
        this.newEvents.push(model);
      }
    }.bind(this));
    if (this.newEvents.length > 0) {
      this.step = creationStep.eventEdit;
      this.render();
      return true;
    } else {
      return false;
    }
  },
  getStream: function () {
    this.streamSelected  = this.focusedStream ? this.focusedStream.id : null;
    this.connectionSelected  = this.focusedStream ? this.focusedStream.connection : null;
    var result = '<div id="stream-select"><form>',
      connections  = this.connection._connections,
      open = '';
    if (this.focusedStream) {
      this.focusedStream.ancestor = this._getStreamAncestor(this.focusedStream);
    }
    _.each(connections, function (c) {
      if (!this._isWritePermission(c)) {
        return;
      }
      if (this.focusedStream && this.focusedStream.ancestor && this.focusedStream.ancestor[0] &&
        this.focusedStream.ancestor[0].serialId === c.serialId) {
        open = 'in';
        this.focusedStream.ancestor.shift();
      } else {
        open = '';
      }

      UNIQUE_ID++;
      result += '<li class="stream-tree-summary connection" data-toggle="collapse" ' +
        'data-target="#collapse-create' + UNIQUE_ID + '">' +
        '<label for="selectStream' + UNIQUE_ID + '">' +
        c.username;
      if (c._accessInfo.name !== 'pryv-browser') {
        result += ' / ' + c._accessInfo.name;
      }
      result += '</label></li>';
      result += '<ul id="collapse-create' + UNIQUE_ID +
        '" class="panel-collapse  collapse in stream-tree-children">' +
        '<div class="panel-body">';
      result += this.getStreamStructure(c);
      if (this._isManagePermission(c)) {
        UNIQUE_ID++;
        result +=  '<li class="stream-tree-summary"><div class="pryv-radio">' +
          '<input type="radio" name="selectStream" id="selectStream' + UNIQUE_ID +
          '" class="select-stream"><label for="selectStream' + UNIQUE_ID + '">' +
          '<input type="text" class="form-control create-stream" ' +
          'data-i18n="[placeholder]events.common.actions.addNewStream;"' +
          ' data-parentId="" data-connection="' + c.serialId + '">' +
          '</label></div></li>';
      }
      result += '</div></ul>';

    }.bind(this));
    return result + '</form></div>';
  },
  getStreamStructure: function (connection) {
    var rootStreams = connection.datastore.getStreams(),
      result = '', open = '', checked = '';
    for (var i = 0; i < rootStreams.length; i++) {
      if (this._isWritePermission(connection, rootStreams[i])) {
        if (this.focusedStream && this.focusedStream.ancestor && this.focusedStream.ancestor[0] &&
          this.focusedStream.ancestor[0].id === rootStreams[i].id) {
          open = 'in';
          this.focusedStream.ancestor.shift();
          if (this.focusedStream.ancestor.length === 0) {
            checked = 'checked';
          }
        } else {
          checked = '';
          open = '';
        }
        result += this._walkStreamStructure(rootStreams[i], checked, open);
      }
    }
    return result;

  },
  _walkStreamStructure: function (stream, checked, open) {
    UNIQUE_ID++;
    var disclosure = 'disclosure';
    if (stream.children.length > 0) {
      disclosure = 'disclosure';
    }
    var result = '<li data-connection="' +
      stream.connection.serialId + '" data-stream="' +
      stream.id + '" class="stream-tree-summary collapsed ' + disclosure +
      '" data-toggle="collapse" ' +
      'data-target="#collapse-create' + UNIQUE_ID + '">' +
      '<div class="pryv-radio">' +
      '<input type="radio" name="selectStream" id="selectStream' + UNIQUE_ID +
      '" class="select-stream" ' +
      checked + '><label for="selectStream' + UNIQUE_ID + '">' +
      stream.name + '</label></div></li>';
    result += '<ul id="collapse-create' + UNIQUE_ID +
      '" class="panel-collapse  collapse ' + open + ' stream-tree-children">' +
      '<div class="panel-body">';
    open = '';
    checked = '';
    for (var j = 0; j < stream.children.length; j++) {
      if (this._isWritePermission(stream.connection, stream.children[j])) {
        if (this.focusedStream && this.focusedStream.ancestor && this.focusedStream.ancestor[0] &&
          this.focusedStream.ancestor[0].id === stream.children[j].id) {
          open = 'in';
          this.focusedStream.ancestor.shift();
          if (this.focusedStream.ancestor.length === 0) {
            checked = 'checked';
          }
        } else {
          open = '';
          checked = '';
        }
        result += this._walkStreamStructure(stream.children[j], checked, open);
      }
    }
    if (this._isManagePermission(stream.connection, stream)) {
      UNIQUE_ID++;
      result += '<li class="stream-tree-summary"><div class="pryv-radio">' +
        '<input type="radio" name="selectStream" id="selectStream' + UNIQUE_ID +
        '" class="select-stream"><label for="selectStream' + UNIQUE_ID + '">' +
        '<input type="text" class="form-control create-stream" ' +
        'data-i18n="[placeholder]events.common.actions.addNewStream;"' +
        ' data-parentId="' + stream.id + '" data-connection="' + stream.connection.serialId + '">' +
        '</label></div></li>';
    }
    result += '</div></ul>';
    return result;
  },
  _isManagePermission: function (connection, stream) {
    if (!connection._accessInfo) {
      return false;
    }

    if (connection._accessInfo.type === 'personal') {
      return true;
    }
    if (!stream) {
      if (connection._accessInfo.permissions &&
        connection._accessInfo.permissions[0].level === 'manage') {
        return true;
      } else {
        return false;
      }
    }
    if (stream) {
      if (connection._accessInfo.permissions &&
        connection._accessInfo.permissions[0].streamId === '*' &&
        connection._accessInfo.permissions[0].level === 'manage') {
        return true;
      }
      return !!_.find(connection._accessInfo.permissions, function (p) {
        return p.streamId === stream.id && p.level === 'manage';
      });
    }
    return false;
  },
  _isWritePermission: function (connection, stream) {
    if (!connection._accessInfo) {
      return false;
    }

    if (connection._accessInfo.type === 'personal') {
      return true;
    }
    if (!stream) {
      if (connection._accessInfo.permissions &&
        connection._accessInfo.permissions[0].level !== 'read') {
        return true;
      } else {
        return false;
      }
    }
    if (stream) {
      if (connection._accessInfo.permissions &&
        connection._accessInfo.permissions[0].streamId === '*' &&
        connection._accessInfo.permissions[0].level !== 'read') {
        return true;
      }
      return !!_.find(connection._accessInfo.permissions, function (p) {
        return p.streamId === stream.id && p.level !== 'read';
      });
    }
    return false;
  },
  _getStreamAncestor: function (stream) {
    var result = [];
    var ancestor = stream.parent;
    result.unshift(stream);
    while (ancestor) {
      result.unshift(ancestor);
      ancestor = ancestor.parent;
    }
    result.unshift(stream.connection);
    return result;
  },
  _initPositionView: function () {

    if (!this.google) {
      _.delay(this._initPositionView.bind(this), 100);
      return;
    }
    var map, elevator, marker, lat, lng;


    var initMap = function () {

      this.newEvents.get('event').content.latitude = lat;
      this.newEvents.get('event').content.longitude = lng;

      map = new this.google.maps.Map(document.getElementById('creation-position'), {
        zoom: 16,
        center: new this.google.maps.LatLng(lat, lng),
        mapTypeId: this.google.maps.MapTypeId.ROADMAP
      });
      elevator = new this.google.maps.ElevationService();
      marker = new this.google.maps.Marker({
        position: new this.google.maps.LatLng(lat, lng),
        draggable: true
      });

      this.google.maps.event.addListener(marker, 'dragend', function (evt) {
        var event = this.newEvents.get('event');
        event.content.latitude = evt.latLng.lat();
        event.content.longitude = evt.latLng.lng();
        var positionalRequest = {
          'locations': [evt.latLng]
        };
        elevator.getElevationForLocations(positionalRequest, function (results, status) {
          if (status === this.google.maps.ElevationStatus.OK) {
            // Retrieve the first result
            if (results[0]) {
              var event = this.newEvents.get('event');
              event.content.altitude = results[0].elevation;
            }
          }
        }.bind(this));
      }.bind(this));
      map.setCenter(marker.position);
      marker.setMap(map);
    };


    this.newEvents = new Model({event: {
      time: new Date().getTime() / 1000,
      type: this.eventType,
      tags: [],
      content: {},
      description: ''
    }});
    if (this.newEvents.get('event')) {
      // default position of LaForge
      lat = 46.51759;
      lng = 6.56267;
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function (position) {
          var coords = position.coords;
          lat = coords.latitude;
          lng = coords.longitude;
          initMap.apply(this);
        }.bind(this), function () {
          initMap.apply(this);
        }.bind(this));
      }
      else {
        initMap.apply(this);
      }
    }
  },
  _getNoteView: function () {
    this.newEvents = new Model({event: {
      time: new Date().getTime() / 1000,
      type: this.eventType,
      tags: [],
      content: null,
      description: ''
    }});
    var result = '';
    result += '<form id="creation-form" role="form">' +
      '      <div class="form-group td-content">' +
      '        <label class="sr-only" for="content">Content</label>' +
      '        <textarea rows="15" class="form-control" id="content-0" ' +
      'data-i18n="[placeholder]events.note.labels.contentPlaceholder"></textarea>' +
      '      </div>' +
      '  <div class="form-group td-tags">' +
      '    <label class="sr-only" for="tags">Tags</label>' +
      '    <input type="text" class="form-control" id="tags-0" ' +
      'data-i18n="[placeholder]events.common.labels.tagsPlaceholder">' +
      '    </div>' +
      '    <div class="form-group td-time">' +
      '      <label class="sr-only" for="edit-time">Time</label>' +
      '      <input type="datetime-local" class="edit" id="edit-time-0" ' +
      'value="' + new Date().toISOString().slice(0, -5) +
      '">' +
      '      </div>' +
      '      <div class="form-group td-description">' +
      '        <label class="sr-only" for="description">Description</label>' +
      '        <textarea rows="3" class="form-control" id="description-0" ' +
      'data-i18n="[placeholder]events.common.labels.descriptionPlaceholder"></textarea>' +
      '      </div>' +
      '    </form>';
    return result;
  },
  _getPositionView: function () {
    var result = '';
    result += '<div id="creation-position" class="col-md-12"></div>';
    result += '<form id="creation-form" role="form">' +
      '  <div class="form-group td-tags">' +
      '    <label class="sr-only" for="tags">Tags</label>' +
      '    <input type="text" class="form-control" id="tags-0" ' +
      'data-i18n="[placeholder]events.common.labels.tagsPlaceholder">' +
      '    </div>' +
      '    <div class="form-group td-time">' +
      '      <label class="sr-only" for="edit-time">Time</label>' +
      '      <input type="datetime-local" class="edit" id="edit-time-0" ' +
      'value="' + new Date().toISOString().slice(0, -5) +
      '">' +
      '      </div>' +
      '      <div class="form-group td-description">' +
      '        <label class="sr-only" for="description">Description</label>' +
      '        <textarea rows="3" class="form-control" id="description-0" ' +
      'data-i18n="[placeholder]events.common.labels.descriptionPlaceholder;"></textarea>' +
      '      </div>' +
      '    </form>';
    return result;
  },
  _getPictureView: function () {
    var reader = new FileReader();
    var toRead = [];
    var  readFile = function (elems) {
      var elem = elems.shift(), file, selector;
      if (elem) {
        file = elem.file;
        selector = elem.selector;
        reader.onload = function (e) {
          $(selector).attr('src', e.target.result).load(function () {
            readFile(elems);
          });
        };
        reader.readAsDataURL(file);
      }
    };
    var result = '';
    if (this.newEvents.length === 1) {
      var event = this.newEvents[0].get('event');
      result += '<div id="creation-picture" class="col-md-12">' +
        '<img src="#" id="preview-0"></div>';
      result += '<form id="creation-form" role="form">' +
        '<div id="progress-0' +
        '" class="td-progress progress progress-striped active" >' +
        '<div class="progress-bar" role="progressbar" aria-valuenow="" aria-valuemin="0" ' +
        'aria-valuemax="100" style="width: 0%"></div></div>' +
        '  <div class="form-group td-tags">' +
        '    <label class="sr-only" for="tags">Tags</label>' +
        '    <input type="text" class="form-control" id="tags-0" ' +
        'data-i18n="[placeholder]events.common.labels.tagsPlaceholder;">' +
        '    </div>' +
        '    <div class="form-group td-time">' +
        '      <label class="sr-only" for="edit-time">Time</label>' +
        '      <input type="datetime-local" class="edit" id="edit-time-0" ' +
        'value="' + new Date(Math.round(event.time * 1000)).toISOString().slice(0, -5) +
        '">' +
        '      </div>' +
        '      <div class="form-group td-description">' +
        '        <label class="sr-only" for="description">Description</label>' +
        '        <textarea rows="3" class="form-control" id="description-0" ' +
        'data-i18n="[placeholder]events.common.labels.descriptionPlaceholder;"></textarea>' +
        '      </div>' +
        '    </form>';
      toRead.push({file: event.previewFile, selector: '#preview-0'});
    } else {
      result = '<table id="creation-picture-table" class="table table-striped">';
      for (var i = 0; i < this.newEvents.length; i++) {
        var model = this.newEvents[i];
        result += '<tr>' +
          '<td class="td-preview"><div class="preview"><img src="#" id="preview-' + i +
          '"></div></td>' +
          '<td class="td-progress"><div id="progress-' + i +
          '" class="progress progress-striped active" >' +
          '<div class="progress-bar" role="progressbar" aria-valuenow="" aria-valuemin="0" ' +
          'aria-valuemax="100" style="width: 0%"></div></div></td>' +
          '<td class="td-tags"><div class="form-group"><label class="sr-only" ' +
          'for="tags">Tags</label>' +
          '<input type="text" class="form-control" id="tags-' + i +
          '" data-i18n="[placeholder]events.common.labels.tagsPlaceholder;">' +
          '</div></td>' +
          '<td class="td-time"><div class="form-group"><label class="sr-only" ' +
          'for="edit-time">Time</label>' +
          '<input type="datetime-local" class="edit" id="edit-time-' + i + '" value="' +
          new Date(Math.round(model.get('event').time * 1000)).toISOString().slice(0, -5) +
          '"></div></td>' +
          '<td class="td-description"><div class="form-group"><label class="sr-only" ' +
          'for="description">Description' +
          '</label><textarea row="3" class="form-control" id="description-' + i + '" ' +
          'data-i18n="[placeholder]events.common.labels.descriptionPlaceholder;"></textarea>' +
          '</div></td></tr>';
        toRead.push({file: model.get('event').previewFile, selector: '#preview-' + i});
      }
      result += '</table>';
    }
    _.delay(function () { readFile(toRead); }, 1000);
    return result;
  }
});

},{"./EventModel.js":141,"backbone.marionette":3,"google-maps":14,"underscore":104}],143:[function(require,module,exports){
module.exports = '<div id="main-container">' +
  '<nav class="navbar navbar-inverse navbar-static-top" role="navigation" style="top: 0px;">' +
    '<div id="logo-reload" class="logo">Pryv</div>' +
    '<div id="logo-beta-mention"><a href="http://pryv.com/beta-roadmap/">Beta</a></div>' +
  '</nav>' +
  '<div class="container center-block text-center">' +
    '<h1 data-i18n="error.unknownUser.labels.title"></h1>' +
    '<a href="http://pryv.com" class="btn btn-default" ' +
  'data-i18n="error.unknownUser.labels.goToPryv"></a>' +
  '</div>' +
'</div> ';
},{}],144:[function(require,module,exports){
/* global $*/
var _ = require('underscore'),
    ActivityView = require('./View.js'),
    CommonModel = require('../common/Model.js'),
    streamUtils = require('../../../utility/streamUtils');

module.exports = CommonModel.implement(
  function (events, params) {
    CommonModel.call(this, events, params);
    this.typeView = ActivityView;
    this.eventDisplayed = null;
    this.modelContent = {};
    this.data = [];
    this.options = {};
    this.totalTime = 0;
    this.updateEachSecond = false;

    this.debounceUpdateTime = _.debounce(this.updateTime.bind(this), 2000);

    this.debounceFullRefresh = _.debounce(this.fullRefresh.bind(this), 30000);
  },
  {
    beforeRefreshModelView: function () {
      this.sumTime();

      this.modelContent = {
        options: this.options,
        data: this.data,
        content: this.eventDisplayed.content,
        description: this.eventDisplayed.description,
        id: this.eventDisplayed.id,
        modified: this.eventDisplayed.modified,
        streamId: this.eventDisplayed.streamId,
        tags: this.eventDisplayed.tags,
        time: this.eventDisplayed.time,
        type: this.eventDisplayed.type,
        eventsNbr: _.size(this.events),
        dimensions: this.computeDimensions(),
        totalTime: this.totalTime
      };

      if (this.updateEachSecond) {
        this.debounceUpdateTime();
        this.debounceFullRefresh();
      }
    },

    computeDimensions: function () {
      var chartSizeWidth = null;
      var chartSizeHeight = null;

      if (this.width !== null) {
        chartSizeWidth = this.width;
      } else if ($('#' + this.container).length)  {
        chartSizeWidth = $('#' + this.container).width();
      } else if ($('#' + this.container).length)  {
        chartSizeWidth = parseInt($('#' + this.container).prop('style').width.split('px')[0], 0);
      }

      if (this.height !== null) {
        chartSizeHeight = this.height;
      } else if ($('#' + this.container).length)  {
        chartSizeHeight = $('#' + this.container).height();
      } else if ($('#' + this.container).length)  {
        chartSizeHeight = parseInt($('#' + this.container).prop('style').height.split('px')[0], 0);
      }
      return {width: chartSizeWidth, height: chartSizeHeight};
    },

    sumTime: function () {
      this.updateEachSecond = false;
      var timeSumByStream = {};

      // group by stream
      _.each(this.events, function (e) {
        if (! e.hasOwnProperty('duration')) { return; }

        if (! timeSumByStream[e.streamId]) {
          timeSumByStream[e.streamId] = {
            stream: e.stream,
            time: 0
          };
        }

        var toAdd = 0;
        if (e.duration !== null) {
          toAdd = e.duration;
        } else {
          this.updateEachSecond = true;
          toAdd = (((new Date()).getTime() / 1000) - e.time);
        }
        timeSumByStream[e.streamId].time += toAdd;
      }.bind(this));

      // Merge childs into parent, such that all are a the same level

      this.data = [];
      for (var s in timeSumByStream) {
        if (timeSumByStream.hasOwnProperty(s)) {
          var stream = timeSumByStream[s].stream;
          var pt = {
            name: stream.name,
            y: timeSumByStream[s].time
          };
          var settings = streamUtils.getChartSettingsForType(stream, 'activity/plain'),
              color = (settings ? settings.color : '') || streamUtils.getColor(stream, false);
          if (color) {
            pt.color = color;
          }
          this.data.push(pt);
        }
      }

      this.totalTime = 0;
      _.each(this.data, function (e) {
        this.totalTime += e.y;
      }.bind(this));
    },

    updateTime: function () {
      if (this.container && $('#' + this.container).length !== 0  && this.updateEachSecond) {
        this.sumTime();
        if (this.modelView) {
          this.modelView.set('totalTime', this.totalTime);
        }
        this.debounceUpdateTime();
      }
    },

    fullRefresh: function () {
      if (this.container && $('#' + this.container).length !== 0 && this.updateEachSecond) {
        this.refresh();
        this.debounceFullRefresh();
      }
    }
  }
);

},{"../../../utility/streamUtils":135,"../common/Model.js":146,"./View.js":145,"underscore":104}],145:[function(require,module,exports){
/* global $, Highcharts */
var Marionette = require('backbone.marionette'),
    dateTime = require('../../../utility/dateTime');

var View = {
  template: '#activityView',
  container: null,
  animation: null,
  chartContainer: null,
  options: null,
  data: null
};

View.initialize = function () {
  this.listenTo(this.model, 'change:totalTime', this._updateTotalTime);
  this.listenTo(this.model, 'change:dimensions', this.change);
  this.listenTo(this.model, 'change:data', this.change);
  this.$el.css('height', '100%');
  this.$el.css('width', '100%');
  this.$el.addClass('animated node');

  this.chart = null;
  this.options = this.model.get('options');
  this.data = this.model.get('data');
};

View.change = function () {
  this.chart = null;
  this.options = this.model.get('options');
  this.data = this.model.get('data');
  $('#' + this.container).removeClass('animated ' + this.animation);
  this.animation = 'tada';
  this.$el.attr('id', this.model.get('id'));
  this.render();
};

View.resize = function () {
  if (! this.model.get('dimensions')) {
    return;
  }
  if (this.chart) {
    this.chart.reflow();
    this._updateTotalTime();
  } else { // TODO: may not be needed
    this.render();
  }
};

View.renderView = function (container) {
  this.container = container;
  this.animation = 'bounceIn';
  this.render();
};

View.onRender = function () {
  if (! this.container) { return; }

  var $container = $('#' + this.container);
  $container.removeClass('animated fadeIn');
  $container.html(this.el);

  this.chartContainer = this.container + '-chart';
  $('#' + this.container + ' .chartContainer').attr('id', this.chartContainer);
  this.chartTotalLabel = '#' + this.container + ' .chart-total-label';

  // HACK: delay actual rendering until we get why resizing goes wrong on data changes
  setTimeout(function () {
    var d = this.model.get('dimensions');
    $(this.chartContainer).css(d);

    if (this.model.get('totalTime') === 0) {
      this.data[0].data = 1;
    }

    this.chart = new Highcharts.Chart({
      chart: {
        // transparent to let total duration label show through
        backgroundColor: null,
        reflow: false,
        renderTo: this.chartContainer,
        type: 'pie'
      },
      credits: {enabled: false},
      plotOptions: {
        pie: {
          innerSize: '60%',
          dataLabels: {
            enabled: false
          },
          showInLegend: true
        },
        series : {
          turboThreshold: 0
        }
      },
      legend: {
        verticalAlign: 'top',
        itemStyle: {
          fontSize: '10px',
          fontWeight: 'normal'
        }
      },
      tooltip: {
        borderColor: '#BDC3C7',
        shadow: false,
        formatter: function () {
          return '<span style="color:' + this.point.color + '">\u25CF</span> ' + this.point.name +
              '<br>' + dateTime.getDurationText(this.y, { nbValues: 2, html: true }) +
              ' (' + (+ (this.percentage).toFixed(2)) + ' %)';
        }
      },
      title: {text: ''},
      series: [{
        data: this.data
      }]
    });
    this._updateTotalTime();

    this.chart.container.onmousedown = null;
    this.chart.container.onclick = function () {
      this.trigger('nodeClicked');
    }.bind(this);
  }.bind(this), 1000);
};

View.close = function () {
  this.remove();
};

View._updateTotalTime = function () {
  if (! this.chart) { return; }

  var textX = this.chart.plotLeft + (this.chart.plotWidth  * 0.5),
      textY = this.chart.plotTop  + (this.chart.plotHeight * 0.5);

  var $label = $(this.chartTotalLabel);
  $label.html(dateTime.getDurationText(this.model.get('totalTime'), {
    nbValues: 2,
    html: true,
    separateLines: true
  }));
  $label.css({
    left: textX - $label.width() * 0.5,
    top: textY - $label.height() * 0.5
  });
};

module.exports = Marionette.ItemView.extend(View);

},{"../../../utility/dateTime":133,"backbone.marionette":3}],146:[function(require,module,exports){
/* global $*/
var _ = require('underscore'),
  Backbone = require('backbone');
var Model = module.exports = function (events, params) {
  this.verbose = false;
  this.events = {};
  this.modelContent = {};
  _.each(events, function (event) {
    this.events[event.id] = event;
  }, this);
  this.highlightedTime = Infinity;
  this.modelView = null;
  this.view = null;
  this.eventDisplayed = null;
  this.container = null;
  this.needToRender = null;
  this.typeView = null;
  this.animationIn = null;
  this.animationOut = null;
  this.hasDetailedView = false;
  _.extend(this, params);
  this.debounceRefresh = _.debounce(function () {
    if (!_.isEmpty(this.events)) {
      this._refreshModelView();
    }
  }, 100);
  this.debounceRefresh();
};

Model.implement = function (constructor, members) {
  var newImplementation = constructor;
  if (typeof Object.create === 'undefined') {
    Object.create = function (prototype) {
      function C() { }
      C.prototype = prototype;
      return new C();
    };
  }
  newImplementation.prototype = Object.create(this.prototype);
  _.extend(newImplementation.prototype, members);
  newImplementation.implement = this.implement;
  return newImplementation;
};

_.extend(Model.prototype, {
  eventEnter: function (event) {
    if (this.events[event.id] && this.verbose) {
      console.log(this.container, 'eventEnter: this eventId already exist:', event.id,
        'current:', this.events[event.id], 'new:', event);
    }
    this.events[event.id] = event;
    if (this.hasDetailedView) {
      this.treeMap.addEventsDetailedView(event);
    }

    this.debounceRefresh();
  },
  eventLeave: function (event) {
    if (!this.events[event.id] && this.verbose) {
      console.log(this.container, 'eventLeave: this eventId dont exist:', event.id,
        'event:', event);
    }
    delete this.events[event.id];
    if (this.hasDetailedView) {
      this.treeMap.deleteEventDetailedView(event);
    }
    //if (!_.isEmpty(this.events)) {
    this.debounceRefresh();
    //}
  },
  eventChange: function (event) {
    if (!this.events[event.id] && this.verbose) {
      console.log(this.container, 'eventChange: this eventId dont exist:', event.id,
        'event:', event);
    }
    this.events[event.id] = event;
    if (this.hasDetailedView) {
      this.treeMap.updateEventDetailedView(event);
    }
    this.debounceRefresh();
  },
  OnDateHighlightedChange: function (time) {
    this.animationIn = time < this.highlightedTime ? 'fadeInLeftBig' : 'fadeInRightBig';
    this.animationOut = time < this.highlightedTime ? 'fadeOutRightBig' : 'fadeOutLeftBig';
    this.highlightedTime = time;
    if (this.hasDetailedView) {
      this.treeMap.highlightDateDetailedView(this.highlightedTime);
    }
    this.debounceRefresh();
  },
  render: function (container) {
    this.container = container;
    if (this.view) {
      this.view.renderView(this.container, this.animationIn);
    } else {
      this.needToRender = true;
    }
  },
  refresh: function (newParams) {
    _.extend(this, newParams);
    this.debounceRefresh();
  },
  close: function () {
    if (this.view) {
      this.view.close(this.animationOut);
    }
    this.view = null;
    this.events = null;
    this.highlightedTime = Infinity;
    this.modelView = null;
    this.eventDisplayed = null;
  },
  beforeRefreshModelView: function () {},
  afterRefreshModelView: function () {},
  _refreshModelView: function () {
    this._findEventToDisplay();
    this.beforeRefreshModelView();
    if (!this.modelView) {
      var BasicModel = Backbone.Model.extend({});
      this.modelView = new BasicModel({});
    }

    // Update the model
    _.each(_.keys(this.modelContent), function (key) {
      this.modelView.set(key, this.modelContent[key]);
    }, this);

    if (!this.view) {
      if (typeof(document) !== 'undefined')  {
        this.view = new this.typeView({model: this.modelView});
        this.view.on('nodeClicked', function () {
          if (!this.hasDetailedView) {
            this.hasDetailedView = true;
            var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
              this.treeMap.closeDetailedView();
              this.hasDetailedView = false;
            }.bind(this));
            this.treeMap.showDetailedView($modal, {
              events: this.events,
              stream: this.stream,
              highlightedTime: this.highlightedTime
            }, this.view.$el);
          }
        }.bind(this));
      }
    }
    this.view.off('nodeClicked');
    this.view.on('nodeClicked', function () {
      if (!this.hasDetailedView) {
        this.hasDetailedView = true;
        var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
          this.treeMap.closeDetailedView();
          this.hasDetailedView = false;
        }.bind(this));
        this.treeMap.showDetailedView($modal, {
          events: this.events,
          stream: this.stream,
          highlightedTime: this.highlightedTime
        }, this.view.$el);
      }
    }.bind(this));
    if (this.needToRender) {
      this.view.renderView(this.container, this.animationIn);
      this.needToRender = false;
    }
    this.afterRefreshModelView();
  },

  _findEventToDisplay: function () {
    if (this.highlightedTime === Infinity) {
      var oldestTime = 0;
      _.each(this.events, function (event) {
        if (event.time >= oldestTime) {
          oldestTime = event.time;
          this.eventDisplayed = event;
        }
      }, this);

    } else {
      var timeDiff = Infinity, debounceRefresh = 0;
      _.each(this.events, function (event) {
        debounceRefresh = Math.abs(event.time - this.highlightedTime);
        if (debounceRefresh <= timeDiff) {
          timeDiff = debounceRefresh;
          this.eventDisplayed = event;
        }
      }, this);
    }
  }

});

},{"backbone":5,"underscore":104}],147:[function(require,module,exports){
/* global $, i18n */
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({
  template: '#template-detail-batch-action-view',
  itemViewContainer: '.modal-panel-left',
  id: 'batch-action-view',
  ui: {
    itemsSelectedLabel: '#batch-action-items-selected',
    selectAll: '#select-all',
    unselectAll: '#unselect-all',
    trash: '#trash',
    cancel: '#cancel',
    spinner: '#trash fa-spinner'
  },

  initialize: function () {
  },

  onRender: function () {
    $(this.itemViewContainer).append(this.el);
    this.ui.cancel.bind('click', function () {
      this.trigger('close');
    }.bind(this));
    this.ui.selectAll.bind('click', this.selectAll.bind(this));
    this.ui.unselectAll.bind('click', this.unselectAll.bind(this));
    this.ui.trash.bind('click', this.trash.bind(this));
    $('body').i18n();
    this.updateItemsSelectedLabel();
  },

  updateItemsSelectedLabel: function () {
    this.ui.itemsSelectedLabel.html(i18n.t('events.common.labels.batchActionItemsSelected', {
      count: countChecked(this.collection)
    }));
  },

  trash: function () {
    var i = 0;
    this.ui.spinner.show();
    this.ui.trash.prop('disabled', true);
    this.collection.each(function (model) {
      if (model.get('checked')) {
        i++;
        model.trash(function () {
          i--;
          if (i === 0) {
            this.ui.spinner.hide();
            this.ui.trash.prop('disabled', false);
          }
        }.bind(this));
      }
    }.bind(this));
    if (i === 0) {
      this.ui.spinner.hide();
      this.ui.trash.prop('disabled', false);
    }
  },

  selectAll: function () {
    this.collection.each(function (model) {
      model.check(true);
      model.trigger('change:checked');
    }.bind(this));
    this.updateItemsSelectedLabel();
  },

  unselectAll: function () {
    this.collection.each(function (model) {
      model.check(false);
      model.trigger('change:checked');
    }.bind(this));
    this.updateItemsSelectedLabel();
  },

  onClose: function () {
    $('#' + this.id).remove();
  }
});

function countChecked(collection) {
  var count = 0;
  collection.each(function (model) {
    if (model.get('checked')) {
      count++;
    }
  });
  return count;
}

},{"backbone.marionette":3}],148:[function(require,module,exports){
/* global $, moment, window, i18n */
var Marionette = require('backbone.marionette'),
    dateTime = require('../../../utility/dateTime');

module.exports = Marionette.ItemView.extend({
  template: '#template-detail-full',
  itemViewContainer: '#detail-common',
  tagName: 'div',
  id: 'detail-full',
  // addAttachmentContainer: '#add-attachment',
  waitSubmit: false,
  timer: null,
  ui: {
    editBtn: '#edit-button',
    editForm: '#edit-form',
    editOff: '#edit-off',
    editOn: '#edit-on',
    editStopEditing: '#edit-stop-editing',
    saveSpin: '#edit-save .fa-spin',
    saveBtn: '#edit-save',
    editStream: '#edit-stream',
    editTime: '#edit-time',
    editTimePicker: '#edit-time-picker',
    editTags: '#edit-tags',
    editDescription: '#edit-description',
    addDuration: '#add-duration',
    stopDuration: '#stop-duration',
    editDuration: '#edit-duration',
    removeDuration: '#remove-duration',
    duration: '.duration',
    durationRunning: '#duration-running',
    durationStopped: '#duration-stopped',
    durationStoppedClock: '#duration-end-clock',
    durationNone: '#duration-none'
  },
  templateHelpers: function () {
    return {
      getStreamStructure: function () {
        return this.getStreamStructure();
      }.bind(this),
      getDurationControl: function () {
        return this.getDurationControl();
      }.bind(this),
      displayDuration: function () {
        return this.displayDuration();
      }.bind(this)
    };
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.modelChanged);
  },
  modelChanged: function () {
    var event = this.model.get('event');
    if (event) {
      event.newDuration = event.duration;
    }
    this.render();
  },
  onClose: function () {
    $('.popover-duration').remove();
    this.stopTimer();
  },
  onBeforeRender: function () {
    $('.popover-duration').remove();
    this.stopTimer();
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);

    this.ui.duration.hide();
    this.initAddDuration();
    this.initEditDuration();
    this.ui.removeDuration.bind('click', this.removeDuration.bind(this));
    this.ui.stopDuration.bind('click', this.stopDuration.bind(this));
    var event = this.model.get('event');
    if (event) {
      if (! event.hasOwnProperty('newDuration')) {
        event.newDuration = event.duration;
      }
      if (event.newDuration === null) {
        this.startTimer();
        this.ui.durationRunning.show();
      } else if (event.newDuration && event.newDuration > 0) {
        this.ui.durationStopped.show();
        this.ui.durationStoppedClock.html(
            dateTime.getDurationText(event.newDuration, {nbValues: 2}) +
            ' (end: ' + dateTime.getTimeText(event.time + event.newDuration) + ')'
        );
      } else if (!event.newDuration || event.newDuration === 0) {
        this.ui.durationNone.show();
      }
    }
    this.ui.editBtn.bind('click', this.showEdit.bind(this));
    this.ui.editStopEditing.bind('click', this.hideEdit.bind(this));
    this.ui.editForm.bind('submit', this.submit.bind(this));
    if ($('#modal-left-content').hasClass('editing')) {
      this.showEdit();
    } else {
      this.hideEdit();
    }
    // Can cause problem if custom time selector is open
    $('.bootstrap-datetimepicker-widget.dropdown-menu').remove();
    this.ui.editTimePicker.datetimepicker({
      direction: 'auto',
      language: i18n.lng()
    });
    if (this.model.get('event')) {
      var evtDate = moment.unix(this.model.get('event').time);
      this.ui.editTimePicker.data('DateTimePicker').setDate(evtDate);
      if (!this.model.isEditPermission()) {
        this.ui.editBtn.hide();
      }
    }

    $('body').i18n();
  },
  showEdit: function () {
    $('#modal-left-content').addClass('editing');
    $('#modal-left-content').trigger('editing:on');
    this.ui.editOff.hide();
    this.ui.editOn.show();
  },
  hideEdit: function () {
    $('#modal-left-content').removeClass('editing');
    $('#modal-left-content').trigger('editing:off');
    this.ui.editOn.hide();
    this.ui.editOff.show();
  },
  submit: function (e) {
    e.preventDefault();
    this.ui.saveBtn.prop('disabled', true);
    this.ui.saveSpin.show();
    var event = this.model.get('event');
    var tags = this.ui.editTags.val();
    tags = tags.split(',');
    tags = tags.map(function (e) {return e.trim(); })
      .filter(function (e) {return e.length > 0; });
    event.tags = tags;
    event.description = this.ui.editDescription.val().trim();
    event.streamId = this.ui.editStream.val().trim();
    event.time = moment(this.ui.editTimePicker.data('DateTimePicker').getDate()).unix();
    event.duration = event.newDuration;
    this.model.set('event', event).save(function (err) {
      this.ui.saveBtn.prop('disabled', false);
      this.ui.saveSpin.hide();
      if (err) {
        window.PryvBrowser.showAlert('.modal-content', i18n.t('error.detailed.update.' + err.id));
      }
    }.bind(this));
  },
  getStreamStructure: function () {
    var rootStreams = this.model.get('event').connection.datastore.getStreams(),
      currentStreamId = this.model.get('event').streamId,
      result = '';
    for (var i = 0; i < rootStreams.length; i++) {
      result += this._walkStreamStructure(rootStreams[i], 0, currentStreamId);
    }
    return result;

  },
  startTimer: function () {
    this.stopTimer();
    this.timer = setInterval(function () {
      var duration = (new Date()).getTime() / 1000 - this.model.get('event').time;
      if (this.model && this.model.get('event') && this.model.get('event').isRunning()) {
        $('#duration-clock').html(dateTime.getDurationText(duration));
      }
      if (this.model.get('event').newDuration === null) {
        $('#duration-edit-clock').html(dateTime.getDurationText(duration));
      }
    }.bind(this), 500);
  },
  stopTimer: function () {
    if (this.timer) {
      clearInterval(this.timer);
    }
  },
  /* jshint ignore:start */
  removeDuration: function () {
    this.model.get('event').newDuration = 0;
    this.render();
  },
  stopDuration: function () {
    var event = this.model.get('event');
    if (event.newDuration === null) {
      event.newDuration = moment().unix() - event.time;
      this.render();
    }
  },
  initAddDuration: function () {
    var that = this;
    $('#add-duration').popover('destroy');
    $('#add-duration').popover({
      html: true,
      placement: 'top',
      container: 'body',
      template: '<div class="popover popover-duration" role="tooltip"><div class="arrow"></div><div class="popover-content"></div></div>',
      content: function () {
        return $('<form class="form-horizontal">' +
          '<div class="form-group">' +
          '  <label for="endDatePicker">' + i18n.t('events.common.labels.endDatePicker') + '</label>' +
          '  <div class="input-group date picker" id="endDatePicker">' +
          '    <input type="text" class="form-control"/> ' +
          '    <span id="endDateButton" class="input-group-addon">' +
          '      <span class="fa fa-calendar"></span>' +
          '    </span>' +
          '  </div>' +
          '</div>' +
          '<button type="button" id="cancel-add-duration" ' +
          'class="btn btn-default col-md-4"  style="float: none" >' +
          i18n.t('common.actions.cancel') + '</button>' +

          '<button type="button" id="ok-add-duration" class="btn btn-default col-md-7 col-md-offset-1"' +
          ' style="float: none">' +
          i18n.t('common.actions.ok') + '</button>' +
          '<hr>' +
          '<label>Or...</label>' +
          '<button type="button" id="start-add-duration" class="btn btn-default btn-block">' +
          i18n.t('common.actions.start') + '</button>' +
          '</form>').html();
      }
    });
    $('#add-duration').on('hidden.bs.popover', function () {
      $('.bootstrap-datetimepicker-widget.dropdown-menu').remove();
    });
    $('#add-duration').on('shown.bs.popover', function () {
      var endDate = moment();
      $(document.body).off('click', '#ok-add-duration');
      $(document.body).on('click', '#ok-add-duration', function () {
        endDate = moment(endDate);
        if (endDate.isValid()) {
          $('#add-duration').popover('toggle');
          var event = that.model.get('event');
          event.newDuration = endDate.unix() - event.time;
          that.render();
        }
      });
      $(document.body).off('click', '#cancel-add-duration');
      $(document.body).on('click', '#cancel-add-duration', function () {
        $('#add-duration').popover('toggle');
      });
      $(document.body).off('click', '#start-add-duration');
      $(document.body).on('click', '#start-add-duration', function () {
        that.model.get('event').newDuration = null;
        $('#add-duration').popover('toggle');
        that.render();
      });
      $(document.body).off('click', '#endDateButton');
      $(document.body).on('click', '#endDateButton', function () {
        endDate = moment();
        $('#endDateButton').trigger('click');
      });

      $(document.body).off('click', '#endDatePicker input');
      $(document.body).on('click', '#endDatePicker input', function () {
        endDate = moment();
        $('#endDateButton').trigger('click');
      });
      $('#endDatePicker').datetimepicker({
        direction: 'auto',
        language: i18n.lng()
      });
      $('#endDatePicker').on('dp.change', function (e) {
        endDate = e.date;
      });
      $('#endDatePicker').data('DateTimePicker').setDate(endDate);
    });
  },
  initEditDuration: function () {
    var that = this;
    $('#edit-duration').popover('destroy');
    $('#edit-duration').popover({
      html: true,
      placement: 'top',
      container: 'body',
      template: '<div class="popover popover-duration" role="tooltip"><div class="arrow"></div><div class="popover-content"></div></div>',
      content: function () {
        return $('<form class="form-horizontal">' +
          '<div class="form-group">' +
          '  <label for="endDatePicker">' + i18n.t('events.common.labels.endDatePicker') + '</label>' +
          '  <div class="input-group date picker" id="endDatePicker">' +
          '    <input type="text" class="form-control"/> ' +
          '    <span id="endDateButton" class="input-group-addon">' +
          '      <span class="fa fa-calendar"></span>' +
          '    </span>' +
          '  </div>' +
          '</div>' +
          '<button type="button" id="cancel-add-duration" ' +
          'class="btn btn-default col-md-4"  style="float: none">' +
          i18n.t('common.actions.cancel') + '</button>' +

          '<button type="button" id="ok-add-duration" class="btn btn-default col-md-7 col-md-offset-1"' +
          ' style="float: none">' +
          i18n.t('common.actions.ok') + '</button>' +
          '</form>').html();
      }
    });
    $('#edit-duration').attr('title', i18n.t('events.common.labels.endDatePicker'));
    $('#edit-duration').on('hidden.bs.popover', function () {
      $('.bootstrap-datetimepicker-widget.dropdown-menu').remove();
    });
    $('#edit-duration').on('shown.bs.popover', function () {
      var event = that.model.get('event');
      var endDate = moment.unix(event.time + event.newDuration);
      $(document.body).off('click', '#ok-add-duration');
      $(document.body).on('click', '#ok-add-duration', function () {
        endDate = moment(endDate);
        if (endDate.isValid()) {
          $('#edit-duration').popover('toggle');
          event.newDuration = endDate.unix() - event.time;
          that.render();
        }
      });
      $(document.body).off('click', '#cancel-add-duration');
      $(document.body).on('click', '#cancel-add-duration', function () {
        $('#edit-duration').popover('toggle');
      });
      $(document.body).off('click', '#endDateButton');
      $(document.body).on('click', '#endDateButton', function () {
        endDate = moment();
        $('#endDateButton').trigger('click');
      });

      $(document.body).off('click', '#endDatePicker input');
      $(document.body).on('click', '#endDatePicker input', function () {
        endDate = moment.unix(event.time + event.newDuration);
        $('#endDateButton').trigger('click');
      });
      $('#endDatePicker').datetimepicker({
        direction: 'auto',
        language: i18n.lng()
      });
      $('#endDatePicker').on('dp.change', function (e) {
        endDate = e.date;
      });
      $('#endDatePicker').data('DateTimePicker').setDate(endDate);
    });
  },
  displayDuration: function () {
    var event = this.model.get('event');
    if (event.isRunning()) {
      this.startTimer();
      return '<span id="duration-clock"></span>';
    } else if (event.duration && event.duration > 0) {
      return '<span>' + dateTime.getDurationText(event.duration, {nbValues: 2}) +
        ' (end: ' + dateTime.getTimeText(event.time + event.duration) + ' )</span>';
    }
  },
  getDurationControl: function () {
    var event = this.model.get('event');
    var html = '';
    html += '<div id="duration-running" class="duration"><span id="duration-edit-clock"></span>' +
      '<button id="stop-duration" class="btn btn-default" data-i18n="common.actions.stop" type="button"></button></div>';
    html += '<div id="duration-stopped" class="duration"><span id="duration-end-clock"></span>' +
        '<span class="btn-group">' +
      '<button class="btn btn-default" id="edit-duration" type="button" title="' + i18n.t('events.common.labels.endDatePicker') + '"><i class="fa fa-calendar"></i></button>' +
      '<button class="btn btn-danger" id="remove-duration" type="button" title="' +  i18n.t('events.common.labels.removeDuration') + '"><i class="fa fa-times"></i></button>' +
        '</span></div>';
    html += '<div id="duration-none" class="duration"><button class="btn btn-default" id="add-duration" type="button">Add duration</button></div>';
    return html;
  },
  /* jshint ignore:end */
  _walkStreamStructure: function (stream, depth, currentStreamId) {
    var indentNbr = 4,
      result = '<option ';
    result += stream.id === currentStreamId ? 'selected="selected" ' : '';
    result += 'value="' + stream.id + '" >';
    for (var i = 0; i < depth * indentNbr; i++) {
      result += '&nbsp;';
    }
    result += stream.name;
    result += '</option>';
    depth++;
    for (var j = 0; j < stream.children.length; j++) {
      result += this._walkStreamStructure(stream.children[j], depth, currentStreamId);
    }
    return result;
  }
});

},{"../../../utility/dateTime":133,"backbone.marionette":3}],149:[function(require,module,exports){
/* global $, i18n, window */
var _ = require('underscore'),
    Collection = require('./EventCollection.js'),
    Model = require('./EventModel.js'),
    ListView = require('./ListView.js'),
    CommonView = require('./CommonView.js'),
    BatchActionView = require('./BatchActionView.js'),
    GenericContentView = require('./contentView/Generic.js'),
    ActivityContentView = require('./contentView/Activity.js'),
    TweetContentView = require('./contentView/Tweet.js'),
    NoteContentView = require('./contentView/Note.js'),
    NumericalContentView = require('./contentView/numerical/Controller.js'),
    PictureContentView = require('./contentView/Picture.js'),
    PositionContentView = require('./contentView/Position.js'),
    CreationView = require('./contentView/Creation.js');

var EVENTS_PER_SCROLL = 20;

var Controller = module.exports = function ($modal, connections, stream, target) {
  this.events = {};
  this.eventsToAdd = [];
  this.eventsToAddToListView = [];
  this.connection = connections;
  this.stream = stream;
  this.newEvent = null;
  this.collection =  new Collection();
  this.listViewcollection =  new Collection();
  this.highlightedDate = null;
  this.listView = null;
  this.commonView = null;
  this.contentView = null;
  this.batchActionView = null;
  this.$modal = $modal;
  this.target = target;
  this.container = '.modal-content';
  var once = true;
  this.debounceAdd = _.debounce(function () {
    if (!this.collection) {
      this.collection = new Collection();
    }
    this.collection.add(this.eventsToAdd, {sort: false});
    this.collection.sort();
    this.eventsToAddToListView = _.sortBy(this.eventsToAddToListView, function (model) {
      return -model.get('event').time;
    });
    if (!this.listViewcollection) {
      this.listViewcollection = new Collection();
    }
    this.listViewcollection.add(this.eventsToAddToListView.splice(0, EVENTS_PER_SCROLL),
      {sort: false});
    this.eventsToAdd = [];
    if (once && this.highlightedDate) {
      this.highlightDate(this.highlightedDate);
      once = false;
    }

    $('#myModalLabel').html(this._getModalTitle());
  }.bind(this), 100);
  $(window).resize(this.resizeModal);
};

_.extend(Controller.prototype, {
  show: function () {
    this.$modal.modal({currentTarget: this.target});
    $(this.container).empty().hide();
    setTimeout(function () {
      $(this.container).fadeIn();
    }.bind(this), 500);
    if (!this.listView) {
      this.commonView = new CommonView({model: new Model({})});
      this.listView = new ListView({
        collection: this.listViewcollection
      });
      this.listView.on('showMore', this.debounceAdd.bind(this));
      this.listView.on('itemview:item:checked', function () {
        this.updateBatchActionView();
      }.bind(this));
      this.listView.on('itemview:date:clicked', function (evt) {
        this.collection.setCurrentElement(evt.model);
        this.listViewcollection.setCurrentElement(evt.model);
        this.updateSingleView(this.collection.getCurrentElement());
      }.bind(this));
    }
    /* jshint -W101 */
    $(this.container).append('<div class="modal-header">' +
      '  <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button> ' +
      '  <h4 class="modal-title" id="myModalLabel">' + this._getModalTitle() + '</h4>' +
      '  <div class="modal-close"></div>' +
      '</div>' +
      '<div class="modal-panel-left"><div id="modal-left-content"><div id="detail-content"></div><div id="detail-common"></div></div></div>');
    this.listView.render();
    if (!_.isEmpty(this.events)) {
      this.commonView.render();
    }
    this.resizeModal();
    $(this.$modal).keydown(function (e) {
      if ($('.editing').length !== 0) {
        return true;
      }
      var LEFT_KEY = 37;
      var UP_KEY = 38;
      var RIGHT_KEY = 39;
      var DOWN_KEY = 40;
      if (e.which === LEFT_KEY || e.which === UP_KEY) {
        this.updateSingleView(this.collection.prev().getCurrentElement());
        this.listViewcollection.prev();
        return false;
      }
      if (e.which === RIGHT_KEY || e.which === DOWN_KEY) {
        this.updateSingleView(this.collection.next().getCurrentElement());
        this.listViewcollection.next();
        return false;
      }
    }.bind(this));
    $('body').i18n();
  },

  close: function () {
    if (this.commonView && this.contentView) {
      if (this.commonView) {this.commonView.close(); this.commonView = null; }
      if (this.contentView) {this.contentView.close(); this.contentView = null; }
      $(this.container).empty();
      if (this.collection) {this.collection.reset(); }
      this.collection = null;
      if (this.listViewcollection) {this.listViewcollection.reset(); }
      this.listViewcollection = null;
      this.events = {};
      $(this.$modal).unbind('keydown');
      $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
      $('.modal-backdrop').remove();
      this.$modal.trigger('hidden.bs.modal');
    }
  },
  updateBatchActionView: function () {
    if (!this.batchActionView) {
      this.batchActionView = new BatchActionView({collection: this.collection});
      this.batchActionView.render();
      this.batchActionView.on('close', function () {
        this.batchActionView.close();
        this.batchActionView = null;
      }.bind(this));
    } else {
      this.batchActionView.render();
    }
  },
  getEventById: function (event) {
    return [this.collection.getEventById(event.id),
      this.listViewcollection.getEventById(event.id)];
  },

  addEvents: function (event) {
    if (!event) {
      return;
    }
    if (event.streamId) {
      //we have only one event so we put it on a each for the next each
      event = [event];
    }
    if (!this.collection) {
      this.collection = new Collection();
    }
    if (!this.listViewcollection) {
      this.listViewcollection = new Collection();
    }
    _.each(event, function (e) {
      var m = new Model({
        event: e
      });
      this.events[e.id] = e;
      this.eventsToAdd.push(m);
      this.eventsToAddToListView.push(m);
    }, this);
    this.debounceAdd();
  },

  deleteEvent: function (event) {
    delete this.events[event.id];
    var currentElement = this.collection.getCurrentElement();
    if (currentElement.get('event').id === event.id) {
      var next = this.collection.next().getCurrentElement();
      if (next.get('event').id === event.id) {
        next = this.collection.prev().getCurrentElement();
        if (next.get('event').id === event.id) {
          return this.close();
        }
      }
      this.updateSingleView(next);
    }
    var toDelete = this.getEventById(event);
    if (toDelete.length > 0) {
      toDelete.forEach(function (e) {e.destroy(); });
    }
  },

  updateEvent: function (event) {
    this.events[event.id] = event;
    var toUpdate = this.getEventById(event);
    if (toUpdate.length > 0) {
      _.each(toUpdate, function (e) {e.set('event', event); e.trigger('change:content'); });
      this.collection.sort();
      this.listViewcollection.sort();
      this.commonView.model.trigger('change');
      this.contentView.model.trigger('change');
      this.contentView.model.trigger('collectionChanged');
    }
  },

  highlightDate: function (time) {
    this.highlightedDate = time;
    var model = this.collection.highlightEvent(time);
    this.listViewcollection.highlightEvent(time);
    this.updateSingleView(model);

  },

  updateSingleView: function (model) {
    if (model) {
      if (model.get('event').type !== 'Creation') {
        this.commonView.model.set('event', model.get('event'));
      }
      var newContentView = this._getContentView(model);
      if (this.contentView === null || this.contentView.type !== newContentView.type) {
        if (this.contentView !== null) {
          this.contentView.close();
          this.contentView.off();
        }
        this.contentView = new newContentView.view({model: new Model({collection:
          this.collection, virtual: this.virtual})});
        this.contentView.on('previous', function () {
          this.updateSingleView(this.collection.prev().getCurrentElement());
          this.listViewcollection.prev();
        }.bind(this));
        this.contentView.on('next', function () {
          this.updateSingleView(this.collection.next().getCurrentElement());
          this.listViewcollection.next();
        }.bind(this));
        if (newContentView.type === 'Creation') {
          $('.modal-panel-right').hide();
          this.contentView.connection = this.connection;
          this.commonView.close();
          var currentElement = this.collection.getCurrentElement();
          if (currentElement) {
            // The creation view was called while a detailed view is open
            // we preset the stream;
            this.contentView.streamId = currentElement.get('event').streamId;
            this.contentView.connectionId = currentElement.get('event').connection.serialId;
          }
          this.contentView.on('endOfSelection', function () {
            $('.modal-panel-right').show();
            this.addEvents(this.newEvent.get('event'));
            this.commonView.model.set('event', this.newEvent.get('event'));
            this.commonView.model.set('collection', this.collection);
            this.commonView.render();
            this.updateSingleView(this.newEvent);
          }.bind(this));
        }
        this.contentView.render();
      }
      this.contentView.model.set('event', model.get('event'));
      this.contentView.model.set('collection', this.collection);
    }
  },

  createNewEvent: function () {
    this.newEvent = new Model({event: this._defaultEvent()});
    this.updateSingleView(this.newEvent);
  },

  _defaultEvent: function () {
    var result = {};
    result.type = 'Creation';
    result.time = new Date().getTime() / 1000;
    result.tags = [];
    result.content = null;
    result.desctiption = '';
    return result;
  },

  /* jshint -W101 */
  // TODO (this & next method): type-specific stuff must be properly abstracted in type plugins
  // follow up: https://trello.com/c/0P6lmhsS/299-as-a-dev-i-need-event-type-specific-components-to-be-properly-abstracted
  _getContentView: function (model) {
    var evt = model.get('event');
    var t = evt.type;
    if (t === 'note/txt' || t === 'note/text') {
      return {type: 'Note', view: NoteContentView};
    } else if (t === 'picture/attached') {
      return {type: 'Picture', view: PictureContentView};
    } else if (t === 'position/wgs84') {
      return {type: 'Position', view: PositionContentView};
    } else if (t === 'message/twitter') {
      return {type: 'Tweet', view: TweetContentView};
    } else if (t === 'activity/plain') {
      return {type: 'Activity', view: ActivityContentView};
    } else if (t === 'Creation') {
      return {type: 'Creation', view: CreationView};
    } else if (window.PryvBrowser.eventTypes.isNumerical(evt)) {
      return {type: 'Numerical', view: NumericalContentView};
    } else {
      return {type: 'Generic', view: GenericContentView};
    }
  },
  _getModalTitle: function () {
    var eModel = this.collection.length > 0 ? this.collection.getCurrentElement() : null;
    var evt = eModel ? eModel.get('event') : null;
    var t = evt ? evt.type : null;
    var tKey;
    if (t === 'note/txt' || t === 'note/text') {
      tKey = 'note';
    } else if (t === 'picture/attached') {
      tKey = 'picture';
    } else if (t === 'position/wgs84') {
      tKey = 'position';
    } else if (t === 'message/twitter') {
      tKey = 'message';
    } else if (window.PryvBrowser.eventTypes.isNumerical(evt)) {
      tKey = 'numerical';
    } else {
      tKey = 'generic';
    }
    $('#myModalLabel').html(i18n.t('events.common.labels.detailViewTitle', {
      count: this.collection.length,
      type: i18n.t('events.' + tKey + '.labels.items'),
      stream: this.stream.name
    }));
  },

  resizeModal: _.debounce(function () {
    $('.modal-panel-left').css({
      width: $('.modal-content').width() - $('.modal-panel-right').width()
    });
  }.bind(this), 1000)
});

},{"./BatchActionView.js":147,"./CommonView.js":148,"./EventCollection.js":150,"./EventModel.js":151,"./ListView.js":153,"./contentView/Activity.js":154,"./contentView/Creation.js":155,"./contentView/Generic.js":156,"./contentView/Note.js":157,"./contentView/Picture.js":158,"./contentView/Position.js":159,"./contentView/Tweet.js":160,"./contentView/numerical/Controller.js":161,"underscore":104}],150:[function(require,module,exports){
var Backbone = require('backbone'),
  Model = require('./EventModel.js');

module.exports = Backbone.Collection.extend({
  url: '#',
  model: Model,
  highlightedDate: null,
  currentElement: null,
  comparator: function (a, b) {
    var aTime = a.get('event').time;
    var bTime = b.get('event').time;
    return aTime > bTime ? -1
      : aTime < bTime ? 1
      : 0;
  },
  highlightEvent: function (time) {
    var next =  this.getEventhighlighted(time);
    if (!next || next === Infinity) {
      return;
    }
    this.setCurrentElement(next);
    return next;
  },
  getEventhighlighted: function (time) {
    this.highlightedDate = time === Infinity ? 99999999999 : time;
    return this.min(this._getTimeDifference.bind(this));
  },
  getTrashed: function () {
    return this.filter(this._getTrashed);
  },
  getEventById: function (id) {
    return this.find(function (e) {
      return e.get('event').id === id;
    });
  },
  getActive: function () {
    return this.reject(this._getTrashed);
  },
  _getTimeDifference: function (event) {
    return event.getTimeDifference(this.highlightedDate);
  },
  _getTrashed: function (event) {
    return event.isTrashed();
  },
  getCurrentElement: function () {
    return this.currentElement;
  },
  setCurrentElement: function (model) {
    if (!model) {
      return;
    }
    if (!this.currentElement || this.currentElement.get('event').id !== model.get('event').id) {
      if (this.currentElement) {
        this.currentElement.setHighlighted(false);
      }
      if (model) {
        model.setHighlighted(true);
        this.trigger('highlightIndex');
      }
    }
    this.currentElement = model;
  },
  next: function () {
    this.setCurrentElement(this.at(this.indexOf(this.getCurrentElement()) + 1));
    return this;
  },
  prev: function () {
    this.setCurrentElement(this.at(this.indexOf(this.getCurrentElement()) - 1));
    return this;
  }
});
},{"./EventModel.js":151,"backbone":5}],151:[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  defaults: {
    event: null,
    collection: null,
    highlighted: false,
    checked: false
  },
  check: function (state) {
    if (this.isEditPermission) {
      this.set('checked', state);
    }
  },
  isEditPermission: function () {
    var event = this.get('event');
    if (!event.connection._accessInfo) {
      return false;
    }

    if (event.connection._accessInfo.type === 'personal') {
      return true;
    }
    if (event.connection._accessInfo.permissions &&
      event.connection._accessInfo.permissions[0].level !== 'read') {
      return true;
    } else {
      return false;
    }

    return false;
  },
  getTimeDifference: function (time) {
    return Math.abs(time - this.get('event').time);
  },
  isTrashed: function () {
    return this.get('event').trashed;
  },
  setHighlighted: function (highlight) {
    this.set('highlighted', highlight);
  },
  save: function (callback) {
    var event = this.get('event'),
      file = event.file;
    if (file) {
      this.get('event').addAttachment(file, callback);
    }
    event.update(callback);
  },
  create: function (callback) {
    var event = this.get('event'),
      file = event.file;
    if (file) {
      event.connection.events.createWithAttachment(event, file, callback);
    }  else {
      event.connection.events.create(event, callback);
    }
  },
  addAttachment: function (file) {
    this.get('event').file = file;
    console.log('addAttachment', file, this);
  },
  removeAttachment: function (fileName, callback) {
    this.get('event').removeAttachment(fileName, callback);
  },
  trash: function (callback) {
    this.get('event').trash(callback);
  }
});
},{"backbone":5}],152:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
    Pryv = require('pryv'),
    eventUtils = require('../../../utility/eventUtils'),
    _ = require('underscore');

var UNIQUE_ID = 0;
var MAX_TEXT_CHAR = 140;

module.exports = Marionette.ItemView.extend({

  tagName: 'li',
  className: 'detail-item',
  template: '#template-detailItemView',
  templateHelpers: {
    getPreview: function () {
      var type = this.event.type;
      var result = '<div class="Center-Container is-Table">' +
          '<div class="Table-Cell">' +
          '<div class="Center-Block">';
      if (type.indexOf('picture') === 0) {
        return '';
      } else if (type.indexOf('note') === 0 && typeof(this.event.content) === 'string') {
        var text = this.event.content;
        if (text.length > MAX_TEXT_CHAR) {
          text = text.slice(0, MAX_TEXT_CHAR) + '...';
        }
        result += text;
      } else if (Pryv.eventTypes.extras(type)) {
        var unity =   Pryv.eventTypes.extras(type).symbol ||
          Pryv.eventTypes.extras(type).name.en || '';
        result += '<span class="value">' + this.event.content + '</span>' +
            '<span class="unity">' + unity + '</span>';
      } else  if (type === 'message/twitter') {
        result += this.event.content.text;
      } else if (type === 'activity/plain') {
        result += eventUtils.getActivityPreview(this.event);
      } else if (type === 'position/wgs84') {
        result += '<span id="' + this.event.id + '" class="fa fa-spinner fa-spin"></span>';
        var url = 'https://nominatim.openstreetmap.org/reverse?format=json&lat=' +
          this.event.content.latitude + '&lon=' +
          this.event.content.longitude + '&zoom=15&addressdetails=0';
        setTimeout(function () {
          $.get(url, function () {
          })
              .done(function (data) {
                if (data.error_message) {
                  $('#' + this.event.id).addClass('bg-danger').text(data.error_message);
                } else {
                  $('#' + this.event.id).text(data.display_name);
                }
              }.bind(this))
              .fail(function () {
                $('#' + this.event.id).addClass('bg-danger').text('Error getting address');
              }.bind(this))
              .always(function () {
                $('#' + this.event.id).removeClass('fa fa-spinner fa-spin');
              }.bind(this));
        }.bind(this), 800);
      } else {
        if (_.isString(this.event.content)) {
          result += this.event.content;
        } else if (_.isNumber(this.event.content)) {
          result += '<span class="value">' + this.event.content + '</span>';
        } else if (_.isObject(this.event.content)) {
          result += JSON.stringify(this.event.content, null, 2);
        } else if (this.event.attachments) {
          var keys = _.keys(this.event.attachments);
          result += '<span class="fa fa-paperclip"></span> ' +
            this.event.attachments[keys[0]].fileName;
        } else {
          result += '<span class="fa fa-question"></span> ' +
           this.event.type;
        }
      }
      result += '</div>' +
          '</div>' +
          '</div>';
      return result;
    },
    getUniqueId: function () {
      UNIQUE_ID++;
      return UNIQUE_ID;
    }
  },
  ui: {
    checkbox: '.checkbox'
  },
  initialize: function () {
    //this.listenTo(this.model, 'change', this.render);
    this.listenTo(this.model, 'change:highlighted', this.highlight);
    this.listenTo(this.model, 'change:checked', this.check);
    this.listenTo(this.model, 'change:content', this.render);

  },
  check: function () {
    this.ui.checkbox[0].checked = !!this.model.get('checked');
    this.ui.checkbox[0].checked = !!this.model.get('checked');
  },
  highlight: function () {
    if (this.model.get('highlighted')) {
      this.$el.addClass('highlighted');
    } else {
      this.$el.removeClass('highlighted');
    }
  },
  onRender: function () {
    this.check();
    this.highlight();
    if (this.model.isEditPermission()) {
      this.$('input').bind('click', function (e) {
        e.stopPropagation();
        this.model.check(!this.model.get('checked'));
        this.check();
        this.trigger('item:checked');
      }.bind(this));
      this.$('label').bind('click', function (e) {
        e.stopPropagation();
      });
    } else {
      this.$('.pryv-checkbox').hide();
    }
    if (this.model.get('event').type.indexOf('picture') === 0) {
      this.$el.css(
          {'background': 'url(' + this.model.get('event').getPicturePreview() +
              ') no-repeat center center',
            '-webkit-background-size': 'cover',
            '-moz-background-size': 'cover',
            '-o-background-size': 'cover',
            'background-size': 'cover'
          });
    }
    this.$el.bind('click', function () {
      this.trigger('date:clicked', this.model);
    }.bind(this));


    $(this.$el).find('.Center-Container').dotdotdot({watch: true, wrap: 'letter'});
  }
});

},{"../../../utility/eventUtils":134,"backbone.marionette":3,"pryv":50,"underscore":104}],153:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
    ItemView = require('./ItemView.js'),
    _ = require('underscore');

var listView = {
  template: '#template-detailListCompositeView',
  container: '.modal-content',
  itemView: ItemView,
  itemViewContainer: '#detail-list',
  events: {
    'scroll #detail-list': '_showMore'
  }
};

listView.initialize = function () {
  if ($('.modal-panel-right').length === 0) {
    /* jshint -W101 */
    $(this.container).append(
      '<div class="modal-panel-right">' +
      '  <div id="modal-right-content">' +
      '    <div id="detail-list"></div>' +
      '  </div>' +
      '</div>');
  }
  //this.listenTo(this.collection, 'add remove', this.debounceRender);
  //this.listenTo(this.collection, 'change', this.bindClick);
};
listView.scrollTo = function () {
  var $detailList = $('#detail-list');
  var listHeight = $detailList.height();
  var $item = $('.detail-item.highlighted');
  var itemHeight = $item.height();
  var itemPosition = $item.position().top;
  if (itemPosition < 0) {
    $detailList.scrollTo($item, 0);
  } else if (itemPosition > listHeight - itemHeight) {
    $detailList.scrollTo($item, 0, {offset: itemHeight - listHeight});
  }
  //$('#detail-list').scrollTo('.detail-item.highlighted');
};
listView.appendHtml = function (collectionView, itemView) {
  $(this.itemViewContainer).append(itemView.el);
};

listView.onRender = function () {
  $('#detail-list').bind('scroll', this._showMore.bind(this));
  this.collection.on('highlightIndex', this.scrollTo.bind(this));
};



listView.debounceRender = _.debounce(function () {
  this.render();
}, 100);

listView._showMore = function () {
  var $detailList = $('#detail-list');
  var height = $detailList.height();
  var scrollHeight = $detailList[0].scrollHeight;
  var scrollTop = $detailList.scrollTop();
  var triggerOffset = 1.25;
  var scrollBarHeight = height * height / scrollHeight;
  var currentScroll = (scrollBarHeight + (scrollTop / (scrollHeight / height))) * triggerOffset;
  // if we are closer than 'margin' to the end of the content, load more books
  if (currentScroll >= height) {
    this.trigger('showMore');
  }
};

module.exports = Marionette.CompositeView.extend(listView);

},{"./ItemView.js":152,"backbone.marionette":3,"underscore":104}],154:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
    eventUtils = require('../../../../utility/eventUtils');

module.exports = Marionette.ItemView.extend({
  type: 'Activity',
  template: '#template-detail-content-activity',
  itemViewContainer: '#detail-content',
  className: 'activity-content',
  templateHelpers: function () {
    return {
      getContent: function () {
        return eventUtils.getActivityPreview(this.model.get('event'));
      }.bind(this)
    };
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
  }
});

},{"../../../../utility/eventUtils":134,"backbone.marionette":3}],155:[function(require,module,exports){
/* global $*/
var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  creationStep = {typeSelect: 'typeSelect', streamSelect: 'streamSelect'},
  validType = ['note/txt', 'picture/attached', 'position/wgs84'];

module.exports = Marionette.ItemView.extend({
  type: 'Creation',
  step: creationStep.typeSelect,
  getTemplate: function () {
    if (this.step === creationStep.typeSelect) {
      return '#template-detail-creation-type';
    } else if (this.step === creationStep.streamSelect) {
      return '#template-detail-creation-stream';
    }
  },
  templateHelpers: function () {
    return {
      getStream: function () {
        return this.getStream();
      }.bind(this)
    };
  },
  itemViewContainer: '#detail-content',
  ui: {
    type: '#type-select',
    stream: 'ul#stream-select'
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);
    this.step = creationStep.typeSelect;
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
    this.ui.type.bind('click', this.onTypeClick.bind(this));
    this.ui.stream.bind('click', this.onStreamClick.bind(this));
  },
  onStreamClick: function (e) {
    var streamSelected = $(e.target).attr('data-stream'),
      connectionSelected = this.connection.get($(e.target).attr('data-connection')),
      event = this.model.get('event');
    event.streamId = streamSelected;
    if (connectionSelected) {
      event.connection = connectionSelected;
      this.trigger('endOfSelection');
    }
    return true;
  },
  onTypeClick: function (e) {
    var typeSelected =  $(e.target).attr('data-type') || $(e.target).parent().attr('data-type'),
        event = this.model.get('event');

    if (validType.indexOf(typeSelected) !== -1) {
      event.type = typeSelected;
      this.step = creationStep.streamSelect;
      this.render();
    }
    return true;
  },
  getStream: function () {
    var result = '<ul id="stream-select">',
      connections  = this.connection._connections;
    _.each(connections, function (c) {
      if (!this._isWritePermission(c)) {
        return;
      }
      result += '<ul>' + c.username + ' / ' + c._accessInfo.name;
      result += this.getStreamStructure(c);
      result += '</ul>';

    }.bind(this));
    return result + '</ul>';
  },
  getStreamStructure: function (connection) {
    var rootStreams = connection.datastore.getStreams(),
      result = '';
    for (var i = 0; i < rootStreams.length; i++) {
      if (this._isWritePermission(connection, rootStreams[i])) {
        result += '<ul>' + this._walkStreamStructure(rootStreams[i]) + '</ul>';
      }
    }
    return result;

  },
  _walkStreamStructure: function (stream) {
    var preSelected = this.connectionId === stream.connection.serialId &&
      this.streamId === stream.id ? 'preSelected-stream' : '';
    var result = '<li class="' + preSelected + '" data-connection="' +
      stream.connection.serialId + '" data-stream="' +
      stream.id + '">' + stream.name + '</li>';
    for (var j = 0; j < stream.children.length; j++) {
      if (this._isWritePermission(stream.connection, stream.children[j])) {
        result += '<ul>' + this._walkStreamStructure(stream.children[j]) + '</ul>';
      }
    }
    return result;
  },
  _isWritePermission: function (connection, streamId) {
    if (!connection._accessInfo) {
      return false;
    }
    if (connection._accessInfo.type === 'personal') {
      return true;
    }
    if (connection._accessInfo.permissions &&
      connection._accessInfo.permissions[0].streamId === '*' &&
      connection._accessInfo.permissions[0].streamId !== 'read') {
      return true;
    }
    if (connection._accessInfo.permissions &&
      connection._accessInfo.permissions[0].streamId === '*' &&
      connection._accessInfo.permissions[0].streamId === 'read') {
      return false;
    }
    if (streamId) {
      return !!_.find(connection._accessInfo.permissions, function (p) {
        return p.streamId === streamId && p.level !== 'read';
      });
    }
    return false;
  }
});
},{"backbone.marionette":3,"underscore":104}],156:[function(require,module,exports){
/* global $, FormData */
var Marionette = require('backbone.marionette'),
  _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  type: 'Generic',
  template: '#template-detail-content-generic',
  itemViewContainer: '#detail-content',
  addAttachmentContainer: '#add-attachment',
  addAttachmentId: 0,
  attachmentId: {},
  ui: {
    li: 'li.editable',
    edit: '.edit'
  },
  templateHelpers: function () {
    return {
      renderContent: function () {
        return this.renderContent(this.model.get('event').content);
      }.bind(this),
      renderAttachments: function () {
        return this.renderAttachments();
      }.bind(this)
    };
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
    //this.addAttachment();
//    this.ui.li.bind('dblclick', this.onEditClick.bind(this));
//    this.ui.edit.bind('blur', this.onEditBlur.bind(this));
//    this.ui.edit.bind('keypress', this.onEditKeypress.bind(this));
//    _.each(_.keys(this.attachmentId), function (k) {
//      $('#' + k + ' i').bind('click', { id: k, fileName: this.attachmentId[k] },
//        this._onRemoveFileClick.bind(this));
//    }.bind(this));
  },
  onEditClick: function (e) {
    $(e.currentTarget).addClass('editing');
    this.ui.edit.focus();
  },
  onEditBlur: function (e) {
    this.updateEvent(e.currentTarget);
    if (e.relatedTarget && e.relatedTarget.id === 'submit-edit') {
      this.submit();
    }
    return true;
  },
  onEditKeypress: function (e) {
    var ENTER_KEY = 13;
    if (e.which === ENTER_KEY) {
      this.updateEvent(e.currentTarget);
    }
  },
  addAttachment: function () {
    var id = 'attachment-' + this.addAttachmentId;
    var html = '<li><input type="file" id="' + id + '"></li>';
    this.addAttachmentId++;
    $(this.addAttachmentContainer).append(html);
    $('#' + id).bind('change', this._onFileAttach.bind(this));
  },
  _onFileAttach : function (event)	{
    var file = new FormData();
    event.target.disabled = true;
    file.append('attachment-0', event.target.files[0]);
    this.model.addAttachment(file);
    this.addAttachment();
  },
  renderAttachments: function () {
    var event =  this.model.get('event');
    var attachments = event.attachments;
    var html = '';
    if (attachments) {
      html += '<ul class="generic-attachments">';
      var keys = _.keys(attachments);
      var href = event.url + '/' + attachments[keys[0]].id + '/' +
        attachments[keys[0]].fileName + '?readToken=' + attachments[keys[0]].readToken;
      html += '<li id="' + keys[0] + '"> <a href="' + href + '" target="_blank">' +
        '<span class="fa fa-paperclip"></span> ' + attachments[keys[0]].fileName + '</a></li>';
      this.attachmentId[keys[0]] = attachments[keys[0]].fileName;
      /* _.each(_.keys(attachments), function (k) {
       html += '<li id="' + k + '">' + k + ': <a href="' + href + '" target="_blank"> ' +
       attachments[k].fileName + '</a>  <i class="delete"></i> </li>';
       this.attachmentId[k] = attachments[k].fileName;
       }.bind(this));  */
      html += '</ul>';
    } else {
      return '';
    }
    return html;
  },
  _onRemoveFileClick: function (event) {
    this.model.removeAttachment(event.data.fileName, function () {
      $('#' + event.data.id + ' i').off();
      $('#' + event.data.id).remove();
      delete this.attachmentId[event.data.id];
    }.bind(this));
  },
  /* jshint -W098, -W061 */
  updateEvent: function ($elem) {
    var event = this.model.get('event'),
      key = ($($elem).attr('id')).replace('edit-', '').replace('-', '.'),
      value = $($elem).val().trim();
    eval('event.' + key + ' = value');
    this.completeEdit($($elem).parent());
    this.render();

  },
  completeEdit: function ($elem) {
    $($elem).removeClass('editing');
  },
  renderContent: function (content, cssExtraClass) {
    var classSuffix = cssExtraClass ? (' ' + cssExtraClass) : '';
    if (_.isBoolean(content)) {
      return this.renderSimpleValue(content, 'generic-bool' + classSuffix);
    } else if (_.isNumber(content)) {
      return this.renderSimpleValue(content, 'generic-num' + classSuffix);
    } else if (_.isString(content)) {
      return this.renderSimpleValue(content, 'generic-str' + classSuffix);
    } else if (_.isArray(content)) {
      return this.renderArray(content, 'generic-arr' + classSuffix);
    } else if (_.isObject(content)) {
      return this.renderObject(content, 'generic-obj' + classSuffix);
    } else {
      throw new Error('Unknown content type: ' + content);
    }
  },

  renderSimpleValue: function (value, cssClass) {
    return '<span class="' + cssClass + '">' + value + '</span>';
  },

  renderObject: function (obj, cssClass) {
    var res = '<ul class="' + cssClass + '">';
    _.each(obj, function (value, key) {
      res += '<li class="generic-prop">';
      res += '<span class="generic-prop-key">' + key + '</span>';
      res += this.renderContent(value, 'generic-prop-val');
      res += '</li>';
    }.bind(this));
    res += '</ul>';
    return res;
  },

  renderArray: function (arr, cssClass) {
    var res = '<ol class="' + cssClass + '">';
    _.each(arr, function (item) {
      res += '<li class="generic-arr-item">';
      res += this.renderContent(item);
      res += '</li>';
    }.bind(this));
    res += '</ol>';
    return res;
  }
});

},{"backbone.marionette":3,"underscore":104}],157:[function(require,module,exports){
/* global $, window */
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({
  type: 'Note',
  template: '#template-detail-content-note',
  itemViewContainer: '#detail-content',
  className: 'note-content',
  ui: {
    content: '#edit-content'
  },
  templateHelpers: function () {
    return {
      getContent: function () {
        return window.PryvBrowser.renderNote(this.model.get('event').content);
      }.bind(this)
    };
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
    this.ui.content.bind('keyup input paste', function () {
      this.model.get('event').content = this.ui.content.val();
    }.bind(this));
    $('body').i18n();
  },
});
},{"backbone.marionette":3}],158:[function(require,module,exports){
/* global $, FormData */
var Marionette = require('backbone.marionette'),
  _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  type: 'Picture',
  tagName: 'div',
  className: 'full-height full-width',
  template: '#template-detail-content-picture',
  itemViewContainer: '#detail-content',
  addAttachmentContainer: '#add-attachment',
  addAttachmentId: 0,
  attachmentId: {},
  ui: {
    li: 'li.editable',
    edit: '.edit'
  },
  templateHelpers: function () {
    return {
      getSrc: function () {
        return this.getSrc();
      }.bind(this),
      getAlt: function () {
        return this.getAlt();
      }.bind(this)
    };
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
    $('#current-picture .fa-angle-left').click(function () {
      this.trigger('previous');
    }.bind(this));
    $('#current-picture .fa-angle-right').click(function () {
      this.trigger('next');
    }.bind(this));
    this.addAttachment();
  },
  addAttachment: function () {
    var id = 'attachment-' + this.addAttachmentId;
    var html = '<li><input type="file" id="' + id + '"></li>';
    this.addAttachmentId++;
    $(this.addAttachmentContainer).append(html);
    $('#' + id).bind('change', this._onFileAttach.bind(this));
  },
  _onFileAttach : function (e)	{
    var file = new FormData(),
      keys = this.model.get('event').attachments ? _.keys(this.model.get('event').attachments) :
        [e.target.files[0].name];
    e.target.disabled = true;
    file.append(keys[0].split('.')[0], e.target.files[0]);
    this.model.addAttachment(file);
  },
  getSrc: function () {
    var event = this.model.get('event'),
      attachments = event.attachments;
    if (attachments) {
      var keys = _.keys(attachments);
      return event.url + '/' + attachments[keys[0]].id + '?readToken=' +
        attachments[keys[0]].readToken;
    } else {
      return '';
    }
  },
  getAlt: function () {
    var event = this.model.get('event'),
      attachments = event.attachments;
    if (attachments) {
      var keys = _.keys(attachments);
      return keys[0];
    } else {
      return '';
    }
  },
  /* jshint -W098, -W061 */
  updateEvent: function ($elem) {
    var event = this.model.get('event'),
      key = ($($elem).attr('id')).replace('edit-', '').replace('-', '.'),
      value = $($elem).val().trim();
    eval('event.' + key + ' = value');
    this.completeEdit($($elem).parent());
    this.render();

  },
  completeEdit: function ($elem) {
    $($elem).removeClass('editing');
  }
});
},{"backbone.marionette":3,"underscore":104}],159:[function(require,module,exports){
/* global $, document*/
var Marionette = require('backbone.marionette'),
    MapLoader = require('google-maps'),
    streamUtils = require('../../../../utility/streamUtils'),
    _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  type: 'Position',
  template: '#template-detail-content-position',
  tagName: 'div',
  id: 'map_canvas',
  itemViewContainer: '#detail-content',
  google: null,
  map: null,
  waitForGoogle: false,
  marker: null,
  positions: null,
  bounds: null,
  paths: null,
  markers: null,
  ui: {
    li: 'li.editable',
    edit: '.edit'
  },
  initialize: function () {
    this.positions = this.model.get('collection');
    this.listenTo(this.model, 'change', this.actualizePosition);
    this.listenTo(this.model, 'collectionChanged', this.render);
    MapLoader.KEY = 'AIzaSyCWRjaX1-QcCqSK-UKfyR0aBpBwy6hYK5M';
    MapLoader.load().then(function (google) {
      this.google = google;
      if (this.waitForGoogle) {
        this.waitForGoogle = false;
        this.render();
      }
    }.bind(this));
  },
  actualizePosition: function () {
    if (!this.google) {
      this.waitForGoogle = true;
    } else {
      var lat = this.model.get('event').content.latitude,
        lng = this.model.get('event').content.longitude;
      this.marker.setPosition(new this.google.maps.LatLng(lat, lng));
      this.map.setCenter(this.marker.position);
    }
  },
  editOn: function () {
    if (this.marker) {
      this.marker.setDraggable(true);
      this.marker.setTitle('Drag me!');
    }
  },
  editOff: function () {
    if (this.marker) {
      this.marker.setDraggable(false);
      this.marker.setTitle('');
    }
  },
  _initMap: function () {
    var geopoint;
    this.markers = [];
    this.paths = {};
    this.mapOptions =  {
      zoom: 10,
      zoomControl: false,
      mapTypeControl: false,
      scaleControl: false,
      streetViewControl: false,
      overviewMapControl: false,
      scrollwheel: true,
      mapTypeId: this.google.maps.MapTypeId.ROADMAP
    };
    this.positions.each(function (p) {
      p = p.get('event');
      geopoint = new this.google.maps.LatLng(p.content.latitude, p.content.longitude);
      this.markers.push(new this.google.maps.Marker({
        position: geopoint,
        visible: false
      }));
      if (!this.bounds) {
        this.bounds = new this.google.maps.LatLngBounds(geopoint, geopoint);
        this.mapOptions.center = geopoint;
      } else {
        this.bounds.extend(geopoint);
      }
      if (!this.paths[p.streamId]) {
        this.paths[p.streamId] = [];
        geopoint.pathColor = streamUtils.getColor(p.stream);
      }
      this.paths[p.streamId].push(geopoint);
    }.bind(this));
  },
  _drawMap: function () {
    if (!this.google.maps) {
      return;
    }
    //this.map = new this.gmaps.Map($container, this.mapOptions);
    //this.gmaps.event.trigger(this.map, 'resize');
    this.map.fitBounds(this.bounds);
    /*var listener = this.gmaps.event.addListener(this.map, 'idle', function () {
      if (this.map.getZoom() > 10) {
        this.map.setZoom(10);
      }
      this.gmaps.event.removeListener(listener);
    }.bind(this));*/
    var gPath, gMarker;
    _.each(this.paths, function (path) {
      if (path.length > 1) {
        gPath = new this.google.maps.Polyline({
          path: path,
          strokeColor: path[0].pathColor,
          strokeOpacity: 1.0,
          strokeWeight: 6
        });
        gPath.setMap(this.map);
      } else {
        gMarker = new this.google.maps.Marker({
          position: path[0]
        });
        gMarker.setMap(this.map);
      }
    }, this);
    //gMarker = new MarkerClusterer(this.map, this.markers);
  },
  onRender: function () {
    if (!this.google) {
      this.waitForGoogle = true;
    } else {
      $(this.itemViewContainer).html(this.el);
      setTimeout(function () {
        if (this.model.get('event')) {
          if (!this.model.get('event').content) {
            this.model.get('event').content = {};
          }
          var lat = this.model.get('event').content.latitude || 46.51759,
            lng = this.model.get('event').content.longitude || 6.56267;
          this.map = new this.google.maps.Map(document.getElementById('map_canvas'), {
            zoom: 16,
            center: new this.google.maps.LatLng(lat, lng),
            mapTypeId: this.google.maps.MapTypeId.ROADMAP
          });
          var elevator = new this.google.maps.ElevationService();
          this.marker = new this.google.maps.Marker({
            position: new this.google.maps.LatLng(lat, lng)
          });
          this._initMap();
          this._drawMap();
          this.google.maps.event.addListener(this.marker, 'dragend', function (evt) {
            var event = this.model.get('event');
            event.content.latitude = evt.latLng.lat();
            event.content.longitude = evt.latLng.lng();
            var positionalRequest = {
              'locations': [evt.latLng]
            };
            elevator.getElevationForLocations(positionalRequest, function (results, status) {
              if (status === this.google.maps.ElevationStatus.OK) {
                // Retrieve the first result
                if (results[0]) {
                  var event = this.model.get('event');
                  event.content.altitude = results[0].elevation;
                }
              }
            }.bind(this));
          }.bind(this));
          $('#modal-left-content').on('editing:on', this.editOn.bind(this));
          $('#modal-left-content').on('editing:off', this.editOff.bind(this));
          if ($('#modal-left-content').hasClass('editing')) {
            this.editOn();
          } else {
            this.editOff();
          }
          this.map.setCenter(this.marker.position);
          this.marker.setMap(this.map);
        }
      }.bind(this), 1000);

    }
  }
});

},{"../../../../utility/streamUtils":135,"backbone.marionette":3,"google-maps":14,"underscore":104}],160:[function(require,module,exports){
/* global $, FormData, PryvBrowser */
var Marionette = require('backbone.marionette'),
    dateTime = require('../../../../utility/dateTime'),
    _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  type: 'Tweet',
  template: '#template-detail-content-tweet',
  itemViewContainer: '#detail-content',
  className: 'note-content',
  templateHelpers: {
    getUrl: function () {
      var id = this.event.content.id,
        screenName = this.event.content['screen-name'],
        date = new Date(this.event.time * 1000);
      return '<a href="https://twitter.com/' + screenName + '/status/' + id + '"' +
        'data-datetime="' + date.toISOString() + '">' +
          dateTime.getTimeText(this.event.time) + '</a>';
    }
  },
  ui: {
    li: 'li.editable',
    edit: '.edit'
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
    this.ui.li.bind('dblclick', this.onEditClick.bind(this));
    this.ui.edit.bind('blur', this.onEditBlur.bind(this));
  },
  onEditClick: function (e) {
    $(e.currentTarget).addClass('editing');
    this.ui.edit.focus();
  },
  onEditBlur: function (e) {
    this.updateEvent(e.currentTarget);
    return true;
  },
  /* jshint -W098, -W061 */
  updateEvent: function ($elem) {
    var event = this.model.get('event'),
      key = ($($elem).attr('id')).replace('edit-', '').replace('-', '.'),
      value = $($elem).val().trim();
    eval('event.' + key + ' = value');
    this.completeEdit($($elem).parent());
    this.render();

  },
  completeEdit: function ($elem) {
    $($elem).removeClass('editing');
  }
});

},{"../../../../utility/dateTime":133,"backbone.marionette":3,"underscore":104}],161:[function(require,module,exports){
/* global window, $ */
var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  Model = require('../../../numericals/TimeSeriesModel.js'),
  Collection = require('../../../numericals/TimeSeriesCollection.js'),
  Settings = require('../../../numericals/utils/ChartSettings.js'),
  SingleEditView = require('./SingleEditView.js'),
  GeneralConfigView = require('./GeneralConfigView.js');

module.exports = Marionette.ItemView.extend({
  type: 'Numerical',
  template: '#template-detail-content-numerical-general',
  itemViewContainer: '#detail-content',
  //addAttachmentContainer: '#add-attachment',
  //addAttachmentId: 0,
  //attachmentId: {},
  collection: new Collection([], {type: 'All'}),
  view: null,
  viewModel: null,
  viewType: GeneralConfigView,
  rendered: false,
  needToRender: null,
  firstRender: null,
  virtual: null,
  initialize: function () {
    this.firstRender = true;
    this.listenTo(this.model, 'change:collection', this.collectionChanged.bind(this));
    this.listenTo(this.model, 'change:event', this.highlightEvent.bind(this));
    this.updateCollection();
    this.prepareGeneralConfigModel();
    window.addEventListener('resize', this.debounceChildRender.bind(this));
  },
  highlightEvent: function () {
    this.viewModel.set('event', this.model.get('event'));
  },
  onRender: function () {
    this.view = new this.viewType({model: this.viewModel});

    if (this.viewType === GeneralConfigView) {
      this.view.bind('edit', this.editSeriesEvent.bind(this));
      this.view.bind('duplicate', this.duplicateSeriesEvent.bind(this));
      this.view.bind('remove', this.removeSeriesEvent.bind(this));
    } else if (this.viewType === SingleEditView) {
      this.view.bind('ready', this.readySeriesEvent.bind(this));
      this.view.bind('cancel', this.cancelSeriesEvent.bind(this));
      this.view.bind('eventEdit', this.eventEdited.bind(this));
    }
    if (this.firstRender) {
      this.firstRender = false;
      this.debounceChildRender();
    } else {
      this.view.render();
    }
    $('body').i18n();
  },
  updateCollection: function () {
    if (!this.collection) {
      this.collection = new Collection([], {type: 'All'});
    }

    var c = this.collection;
    this.model.get('collection').each(function (e) {
      var ev = e.get('event');
      var connectionId = ev.connection.id;
      var streamId = ev.streamId;
      var streamName = ev.stream.name;
      var type = ev.type;

      var filter = {
        connectionId: connectionId,
        streamId: streamId,
        type: type
      };

      var m = c.where(filter);
      if (m && m.length !== 0) {
        for (var i = 0; i < m.length; ++i) {
          if (_.indexOf(m[i].get('events'), ev) === -1) {
            m[i].get('events').push(ev);
          }
        }
      } else {
        var s = new Settings(ev.stream, ev.type, this.model.get('virtual'));
        c.add(new Model({
            events: [ev],
            connectionId: connectionId,
            stream: ev.stream,
            streamId: streamId,
            streamName: streamName,
            type: type,
            category: 'any',
            virtual: this.model.get('virtual'),
            color: s.get('color'),
            style: s.get('style'),
            transform: s.get('transform'),
            interval: s.get('interval')
          })
        );
      }
    }.bind(this));
  },
  onClose: function () {
    this.view.close();
    this.view = null;
    this.viewType = GeneralConfigView;
    this.viewModel = null;
    this.collection.reset();
    this.collection = null;
    this.rendered = null;
    this.needToRender = null;
  },
  editSeriesEvent: function (m) {

    this.closeChild();
    this.viewType = SingleEditView;
    this.prepareSingleEditModel(m);
    this.render();
  },
  cancelSeriesEvent: function () {
    this.closeChild();
    this.viewType = GeneralConfigView;
    this.prepareGeneralConfigModel();
    this.render();
  },
  eventEdited: function (event) {
    var c = this.model.get('collection');
    var submitter = function () {
      this.collectionChanged.bind(this);
    }.bind(this);

    for (var i = 0; i < c.length; ++i) {
      var current = c.at(i);
      var e = current.get('event');
      if (e.id === event.eventId) {
        e.content = event.value;
        current.save(submitter);
        break;
      }
    }


  },
  readySeriesEvent: function (m) {
    var s = new Settings(m.get('stream'), m.get('type'), m.get('virtual'));
    s.set('color', m.get('color'));
    s.set('style', m.get('style'));
    s.set('transform', m.get('transform'));
    s.set('interval', m.get('interval'));

    this.closeChild();
    this.viewType = GeneralConfigView;
    this.prepareGeneralConfigModel();
    this.render();
  },
  duplicateSeriesEvent: function (m) {

    this.closeChild();
    this.viewType = GeneralConfigView;
    var model = new Model({
      events: m.get('events'),
      connectionId: m.get('connectionId'),
      streamId: m.get('streamId'),
      streamName: m.get('streamName'),
      type: m.get('type'),
      category: m.get('category')
    });
    this.collection.add(model);
    this.prepareGeneralConfigModel();
    this.render();
  },
  removeSeriesEvent: function (m) {
    var virtual = this.model.get('virtual');
    var streamId = m.get('streamId');
    var type = m.get('type');
    var filters = virtual.filters;
    var newFilter = [];
    for (var i = 0; i < filters.length; ++i) {
      if (!(filters[i].streamId === streamId &&
        filters[i].type === type)) {
        newFilter.push(filters[i]);
      }
    }
    virtual.filters = newFilter;



    this.closeChild();
    this.viewType = GeneralConfigView;
    this.collection.remove(m);
    this.prepareGeneralConfigModel();
    this.render();
  },
  collectionChanged: function () {
    // TODO: depends on view type
    this.updateCollection();
    if (this.view) {
      this.view.unbind();
      this.view.close();
    }
    this.render();
  },
  prepareSingleEditModel: function (m) {
    this.viewModel = new Model({
      collection: this.collection,
      edited: m
    });
  },
  prepareGeneralConfigModel: function () {
    this.viewModel = new Model({
      collection: this.collection,
      virtual: this.model.get('virtual')
    });
  },
  closeChild: function () {
    this.view.unbind();
    this.view.close();
  },
  debounceChildRender: _.debounce(function () {
    if (this.view) {
      this.view.render();
    }
  }, 1000)
});

},{"../../../numericals/TimeSeriesCollection.js":174,"../../../numericals/TimeSeriesModel.js":175,"../../../numericals/utils/ChartSettings.js":176,"./GeneralConfigView.js":162,"./SingleEditView.js":163,"backbone.marionette":3,"underscore":104}],162:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  //Model = require('../../../numericals/TimeSeriesModel.js'),
  ChartModel = require('../../../numericals/ChartModel.js'),
  ChartView = require('../../../numericals/ChartView.js');


module.exports = Marionette.ItemView.extend({
  type: 'Numerical',
  template: '#template-detail-content-numerical-general',
  itemViewContainer: '#detail-content',
  chartView: null,
  rendered: false,
  initialize: function () {
    this.listenTo(this.model, 'change:collection', this.render.bind(this));
    this.listenTo(this.model, 'change:event', this.highlightEvent.bind(this));
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);

    if (this.chartView) {
      this.chartView.model.set('collection', this.model.get('collection'));
    } else {
      this.chartView = new ChartView({model:
        new ChartModel({
          container: '#detail-chart-container-general',
          view: null,
          requiresDim: false,
          collection: this.model.get('collection'),
          highlighted: false,
          highlightedTime: null,
          allowPieChart: false,
          singleNumberAsText: false,
          dimensions: null,
          showLegend: true,
          legendActions: this.model.get('virtual') ? [ 'edit', 'remove' ] : ['edit'],
          onClick: false,
          onHover: true,
          onDnD: false,
          enableNavigation: true,
          xaxis: true,
          editPoint: false,
          showNodeCount: false
        })});

      this.chartView.on('remove', function (m) {
        this.trigger('remove', m);
      }.bind(this));

      this.chartView.on('edit', function (m) {
        this.trigger('edit', m);
      }.bind(this));

      this.chartView.on('duplicate', function (m) {
        this.trigger('duplicate', m);
      }.bind(this));
    }

    if ($('#detail-chart-container-general').length !== 0) {
      this.chartView.render();
      this.highlightEvent();
      this.rendered = true;
    }
    $('body').i18n();
  },
  debounceRender: _.debounce(function () {
    if (!this.rendered) {
      this.render();
      this.highlightEvent();
    }
  }, 1000),

  highlightEvent: function () {
    if (this.chartView && this.model.get('event')) {
      this.chartView.highlightEvent(this.model.get('event'));
    }
  },
  onClose: function () {
    if (this.chartView) {
      this.chartView.close();
    }
    this.chartView = null;
    $(this.itemViewContainer).empty();
  }
});

},{"../../../numericals/ChartModel.js":171,"../../../numericals/ChartView.js":172,"backbone.marionette":3,"underscore":104}],163:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  //Model = require('../../../numericals/TimeSeriesModel.js'),
  ChartModel = require('../../../numericals/ChartModel.js'),
  ChartView = require('../../../numericals/ChartView.js');


module.exports = Marionette.ItemView.extend({
  type: 'Numerical',
  template: '#template-detail-content-numerical-edit',
  itemViewContainer: '#detail-content',
  ui: {
    seriesName: '#detailed-view-chart-series-name',
    selColor: '#detailed-view-chart-color',
    selStyle: '#detailed-view-chart-style',
    selOperation: '#detailed-view-chart-operation',
    selIntervalGroup: '#detailed-view-chart-interval-group',
    selInterval: '#detailed-view-chart-interval',
    butOk: '#detailed-view-chart-ok',
    butCancel: '#detailed-view-chart-cancel'
  },
  chartView: null,
  chartViewModel: null,
  rendered: false,
  collection: null,
  edited: null,
  old: null,
  color: null,
  style: null,
  transform: null,
  interval: null,
  initialize: function () {
    this.listenTo(this.model, 'change:collection', this.prepareCollection.bind(this));
    this.listenTo(this.model, 'change:event', this.highlightEvent.bind(this));
    this.edited = this.model.get('edited');
    this.old = {
      color: this.edited.get('color'),
      style: this.edited.get('style'),
      transform: this.edited.get('transform'),
      interval: this.edited.get('interval')
    };
  },
  onRender: function () {
    $(this.itemViewContainer).html(this.el);
    if (this.chartView) {
      this.chartView.model.set('collection', this.collection);
    } else {
      this.prepareCollection();
      this.chartViewModel = new ChartModel({
          container: '#detail-chart-container-edit',
          view: null,
          requiresDim: false,
          collection: this.model.get('collection'),
          highlighted: false,
          highlightedTime: null,
          allowPieChart: false,
          singleNumberAsText: false,
          dimensions: null,
          showLegend: false,
          onClick: false,
          onHover: true,
          onDnD: false,
          editPoint: true,
          enableNavigation: false,
          xaxis: true,
          showNodeCount: false
        });

      this.chartView = new ChartView({model: this.chartViewModel});
      this.ui.selColor.bind('change', this.editorChange.bind(this));
      this.ui.selStyle.bind('change', this.editorChange.bind(this));
      this.ui.selOperation.bind('change', this.editorChange.bind(this));
      this.ui.selInterval.bind('change', this.editorChange.bind(this));
      this.ui.butOk.on('click', function () {
        this.trigger('ready', this.edited);
      }.bind(this));
      this.ui.butCancel.on('click', function () {
        this.edited.set('color', this.old.color);
        this.edited.set('style', this.old.style);
        this.edited.set('transform', this.old.transform);
        this.edited.set('interval', this.old.interval);
        this.trigger('cancel');
      }.bind(this));
    }

    if ($('#detail-chart-container-edit').length !== 0) {
      this.updateEditor();
      if (this.chartView) { this.chartView.unbind(); }
      this.chartView.render();
      this.chartView.on('eventEdit', this.onValueEdited.bind(this));
      this.highlightEvent();
      this.rendered = true;
    }
    $('body').i18n();
  },
  debounceRender: _.debounce(function () {
    if (!this.rendered) {
      if (this.chartView) { this.chartView.unbind(); }
      this.render();
      this.highlightEvent();
      this.chartView.on('eventEdit', this.onValueEdited.bind(this));
    }
  }, 1000),
  onValueEdited: function (event) {
    this.trigger('eventEdit', event);
  },
  editorChange: function () {
    if (this.ui.selColor[0].selectedIndex > -1) {
      this.color = this.ui.selColor[0].options[this.ui.selColor[0].selectedIndex].value;
      this.ui.selColor.css({'background-color': this.color});
    }
    if (this.ui.selStyle[0].selectedIndex > -1) {
      this.style = this.ui.selStyle[0].options[this.ui.selStyle[0].selectedIndex].value;
    }
    if (this.ui.selOperation[0].selectedIndex > -1) {
      this.transform = this.ui.selOperation[0].options[this.ui.selOperation[0].selectedIndex].value;
    }
    if (this.ui.selInterval[0].selectedIndex > -1) {
      this.interval = this.ui.selInterval[0].options[this.ui.selInterval[0].selectedIndex].value;
    }

    this.edited.set('color', this.color);
    this.edited.set('style', this.style);
    this.edited.set('transform', this.transform);
    this.edited.set('interval', this.interval);

    this.updateEditor();

    if (this.chartView) { this.chartView.unbind(); }
    this.chartView.render();
    this.chartView.on('eventEdit', this.onValueEdited.bind(this));
  },
  highlightEvent: function () {
    if (this.chartView && this.model.get('event')) {
      this.chartView.highlightEvent(this.model.get('event'));
    }
  },
  prepareCollection: function () {
    this.collection = this.model.get('collection');
  },
  onClose: function () {
    this.chartView.close();
    this.chartView = null;
    $(this.itemViewContainer).empty();
  },
  updateEditor: function () {
    var i,
        editedModel = this.model.get('edited');

    this.ui.seriesName.html(editedModel.get('seriesLegend'));
    this.ui.selColor.css({'background-color': editedModel.get('color')});

    var colorFound = false,
        options = this.ui.selColor[0].options;
    for (i = 0; i < options.length; ++i) {
      if (options[i].value === editedModel.get('color')) {
        this.ui.selColor[0].selectedIndex = i;
        colorFound = true;
        break;
      }
    }
    if (! colorFound) {
      if (editedModel.get('color')) {
        $(this.ui.selColor).css({
          'background-color': editedModel.get('color')
        });
      }
    }

    options = this.ui.selStyle[0].options;
    for (i = 0; i < options.length; ++i) {
      if (options[i].value === editedModel.get('style')) {
        this.ui.selStyle[0].selectedIndex = i;
        break;
      }
    }

    options = this.ui.selOperation[0].options;
    var transform = editedModel.get('transform');
    for (i = 0; i < options.length; ++i) {
      if (options[i].value === transform) {
        this.ui.selOperation[0].selectedIndex = i;
        break;
      }
    }

    // show/hide interval control depending on transform
    $(this.ui.selIntervalGroup[0]).toggle(transform !== 'none');

    options = this.ui.selInterval[0].options;
    for (i = 0; i < options.length; ++i) {
      if (options[i].value === editedModel.get('interval')) {
        this.ui.selInterval[0].selectedIndex = i;
        break;
      }
    }
  }
});

},{"../../../numericals/ChartModel.js":171,"../../../numericals/ChartView.js":172,"backbone.marionette":3,"underscore":104}],164:[function(require,module,exports){
/* global window, $ */
var _ = require('underscore'),
  ListView = require('./ListView.js'),
  ChartView = require('./../numericals/ChartView.js'),
  Model = require('./../numericals/ChartModel.js'),
  TimeSeriesCollection = require('./../numericals/TimeSeriesCollection.js'),
  TimeSeriesModel = require('./../numericals/TimeSeriesModel.js'),
  Settings = require('./../numericals/utils/ChartSettings.js');

var Controller = module.exports = function ($modal, events, treemap) {
  this.$modal = $modal;
  this.events = events;
  this.treemap = treemap;
  this.datas = {};
  this.chartView = null;

  // Very important hack flag.
  this.initial = true;
  this.called = false;

  /* Base event containers */
  this.eventsToAdd = [];
  this.eventsToRem = [];
  this.eventsToCha = [];

  this.chartCollection = new TimeSeriesCollection([], {type: 'All'});
  this.eventCollections = {
    note: new TimeSeriesCollection([], {type: 'Note'}),
    picture: new TimeSeriesCollection([], {type: 'Pictures'}),
    position: new TimeSeriesCollection([], {type: 'Positions'}),
    numerical: new TimeSeriesCollection([], {type: 'Numericals'})
  };

  this.eventCollectionsViews = {
    note: null,
    picture: null,
    position: null,
    numerical: null
  };

  for (var e in events) {
    if (events.hasOwnProperty(e)) {
      this.eventEnter(events[e]);
    }
  }

  this.$content = $modal.find('.modal-content');

  // Create the div we will use
  this.$content.html($('#template-draganddrop').html());
  this.resizeModal();

  $(window).resize(this.resizeModal.bind(this));
};

_.extend(Controller.prototype, {

  show: function () {
    if (this.initial) {
      this.called = true;
      return;
    }
    this.$modal.modal();
    this.eventCollectionsViews.note =
      new ListView({collection: this.eventCollections.note });
    this.eventCollectionsViews.picture =
      new ListView({collection: this.eventCollections.picture });
    this.eventCollectionsViews.position =
      new ListView({collection: this.eventCollections.position });
    this.eventCollectionsViews.numerical =
      new ListView({collection: this.eventCollections.numerical });

    this.chartView = new ChartView({model:
      new Model({
        container: '.modal-dnd-chart',
        view: null,
        requiresDim: false,
        collection: this.chartCollection,
        highlighted: false,
        highlightedTime: null,
        allowPieChart: false,
        dimensions: null,
        showLegend: true,
        legendActions: ['remove'],
        onClick: false,
        onHover: true,
        onDnD: false,
        enableNavigation: false,
        xaxis: true,
        showNodeCount: false
      })});

    this.chartView.render();

    this.chartView.on('remove', function (m) {
      this.chartCollection.remove(m);
      var e = {type: m.get('type')};
      var c = this.getTimeSeriesCollectionByEvent(e);
      c.add(m);

      this.eventCollectionsViews.note.render();
      this.eventCollectionsViews.position.render();
      this.eventCollectionsViews.picture.render();
      this.eventCollectionsViews.numerical.render();

    }.bind(this));

    var $list = $('.modal-dnd-list'),
        $curContainer,
        elt;

    if (this.eventCollections.note.notNull) {
      $list.append('<h5>Notes</h5>');
      $curContainer = $('<div>');
      $list.append($curContainer);
      this.eventCollectionsViews.note.ul = $curContainer;
      this.eventCollectionsViews.note.render();
      elt = this.eventCollectionsViews.note.el;
      $curContainer.append(elt);
    }

    if (this.eventCollections.picture.notNull) {
      $list.append('<h5>Pictures</h5>');
      $curContainer = $('<div>');
      $list.append($curContainer);
      this.eventCollectionsViews.picture.ul = $curContainer;
      this.eventCollectionsViews.picture.render();
      elt = this.eventCollectionsViews.picture.el;
      $curContainer.append(elt);
    }

    if (this.eventCollections.position.notNull) {
      $list.append('<h5>Positions</h5>');
      $curContainer = $('<div>');
      $list.append($curContainer);
      this.eventCollectionsViews.position.ul = $curContainer;
      this.eventCollectionsViews.position.render();
      elt = this.eventCollectionsViews.position.el;
      $curContainer.append(elt);
    }

    if (this.eventCollections.numerical.notNull) {
      $list.append('<h5>Values</h5>');
      $curContainer = $('<div>');
      $list.append($curContainer);
      this.eventCollectionsViews.numerical.ul = $curContainer;
      this.eventCollectionsViews.numerical.render();
      elt = this.eventCollectionsViews.numerical.el;
      $curContainer.append(elt);
    }

    this.eventCollectionsViews.note.on('itemview:series:click', function (evt) {
      this.addSerieToChart(evt.model);
      this.eventCollections.note.remove(evt.model);
    }.bind(this));

    this.eventCollectionsViews.picture.on('itemview:series:click', function (evt) {
      this.addSerieToChart(evt.model);
      this.eventCollections.picture.remove(evt.model);
    }.bind(this));

    this.eventCollectionsViews.position.on('itemview:series:click', function (evt) {
      this.addSerieToChart(evt.model);
      this.eventCollections.position.remove(evt.model);
    }.bind(this));

    this.eventCollectionsViews.numerical.on('itemview:series:click', function (evt) {
      this.addSerieToChart(evt.model);
      this.eventCollections.numerical.remove(evt.model);
    }.bind(this));

    $('#dnd-btn-cancel').bind('click', function () {
      this.close();
      this.$modal.modal('hide');
    }.bind(this));

    $('#dnd-field-name').bind('input', function () {
      var val = $('#dnd-field-name').val();
      if (val.length > 0) {
        $('.modal-dnd-footer').removeClass('has-error');
        $('.modal-dnd-footer').addClass('has-success');
      } else {
        $('.modal-dnd-footer').removeClass('has-success');
        $('.modal-dnd-footer').addClass('has-error');
      }
    });

    $('#dnd-btn-create').bind('click', function () {
      var errors = 0;
      var vn_filters = [];
      var vn_name = $('#dnd-field-name').val();

      this.chartCollection.each(function (e) {
        vn_filters.push({stream: e.get('events')[0].stream, type: e.get('type')});
      });

      if (!vn_name) {
        errors++;
      }

      if (vn_filters.length === 0) {
        errors++;
      }

      if (errors > 0) {
        return;
      } else {
        this.treemap.createVirtualNode(vn_filters, vn_name);
        this.close();
        $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
        $('.modal-backdrop').remove();
      }
    }.bind(this));
  },



  /* Base event functions */
  eventEnter: function (event) {
    this.events[event.id] = event;
    if (!this.datas[event.streamId]) {
      this.datas[event.streamId] = {};
    }
    if (!this.datas[event.streamId][event.type]) {
      this.datas[event.streamId][event.type] = {};
    }
    this.datas[event.streamId][event.type][event.id] = event;
    this.eventsToAdd.push(event);
    this.debounceUpdateCollections();
  },

  eventLeave: function (event) {
    if (this.events[event.id]) {
      delete this.events[event.id];
    }
    if (this.datas[event.streamId] &&
      this.datas[event.streamId][event.type] &&
      this.datas[event.streamId][event.type][event.id]) {
      delete this.datas[event.streamId][event.type][event.id];
    }
    this.eventsToRem.push(event);
    this.debounceUpdateCollections();
  },

  eventChange: function (event) {
    if (this.events[event.id]) {
      this.events[event.id] = event;
    }
    if (this.datas[event.streamId] &&
      this.datas[event.streamId][event.type] &&
      this.datas[event.streamId][event.type][event.id]) {
      this.datas[event.streamId][event.type][event.id] = event;
    }
    this.eventsToCha.push(event);
    this.debounceUpdateCollections();
  },

  debounceUpdateCollections: _.debounce(function () {
    var eventsToAdd = this.eventsToAdd;
    var eventsToRem = this.eventsToRem;
    var eventsToCha = this.eventsToCha;

    var eventsCategory;
    var eventsCollection;
    var eventsModel;
    var events;
    var matching;

    this.eventsToAdd = [];
    this.eventsToRem = [];
    this.eventsToCha = [];

    var i;
    var eIter;

    // Process those to add
    for (i = 0; i < eventsToAdd.length; ++i) {
      var filter = {
        connectionId: eventsToAdd[i].connection.id,
        streamId: eventsToAdd[i].streamId,
        type: eventsToAdd[i].type
      };
      eventsCategory = this.getEventsCategory(eventsToAdd[i]);
      eventsCollection = this.getTimeSeriesCollectionByEvent(eventsToAdd[i]);
      if (eventsCollection) {
        // find corresponding model
        matching = eventsCollection.where(filter);
        if (matching && matching.length !== 0) {
          eventsModel = matching[0];
          eventsModel.get('events').push(eventsToAdd[i]);
        } else {
          var s = new Settings(eventsToAdd[i].stream,
            eventsToAdd[i].type, null);
          eventsModel = new TimeSeriesModel({
            events: [eventsToAdd[i]],
            connectionId: eventsToAdd[i].connection.id,
            streamId: eventsToAdd[i].streamId,
            streamName: eventsToAdd[i].stream.name,
            type: eventsToAdd[i].type,
            category: this.getEventsCategory(eventsToAdd[i]),
            color: s.get('color'),
            style: s.get('style'),
            transform: s.get('transform'),
            interval: s.get('interval')
          });
          eventsCollection.add(eventsModel);
        }
      }
    }

    // Process those to remove
    for (i = 0; i < eventsToRem.length; ++i) {
      eventsCategory = this.getEventsCategory(eventsToRem[i]);
      eventsCollection = this.getTimeSeriesCollectionByEvent(eventsToRem[i]);
      if (eventsCollection) {
        // find corresponding model
        matching = eventsCollection.where({
          connectionId: eventsToRem[i].connection.id,
          streamId: eventsToRem[i].streamId,
          type: eventsToRem[i].type
        });
        if (matching && matching.length !== 0) {
          eventsModel = matching[0];
          events = eventsModel.get('events');
          for (eIter = 0; eIter < events.length; ++eIter) {
            if (events[eIter].id === eventsToRem[i].id) {
              delete events[eIter];
            }
          }
        }
      }
    }

    // Process those to change
    for (i = 0; i < eventsToCha.length; ++i) {
      eventsCategory = this.getEventsCategory(eventsToCha[i]);
      eventsCollection = this.getTimeSeriesCollectionByEvent(eventsToCha[i]);
      if (eventsCollection) {
        // find corresponding model
        matching = eventsCollection.where({
          connectionId: eventsToCha[i].connection.id,
          streamId: eventsToCha[i].streamId,
          type: eventsToCha[i].type
        });
        if (matching && matching.length !== 0) {
          eventsModel = matching[0];
          events = eventsModel.get('events');
          for (eIter = 0; eIter < events.length; ++eIter) {
            if (events[eIter].id === eventsToCha[i].id) {
              events[eIter] = eventsToCha[i];
            }
          }
        }
      }
    }

    if (this.initial) {
      this.initial = false;
      this.eventCollections.note.each(function (m) {
        this.addSerieToChart(m);
      }.bind(this));
      this.eventCollections.numerical.each(function (m) {
        this.addSerieToChart(m);
      }.bind(this));
      this.eventCollections.picture.each(function (m) {
        this.addSerieToChart(m);
      }.bind(this));
      this.eventCollections.position.each(function (m) {
        this.addSerieToChart(m);
      }.bind(this));

      var m = null;
      while (this.eventCollections.note.length !== 0) {
        this.eventCollections.note.notNull = true;
        m = this.eventCollections.note.at(0);
        this.eventCollections.note.remove(m);
      }
      while (this.eventCollections.numerical.length !== 0) {
        this.eventCollections.numerical.notNull = true;
        m = this.eventCollections.numerical.at(0);
        this.eventCollections.numerical.remove(m);
      }
      while (this.eventCollections.picture.length !== 0) {
        this.eventCollections.picture.notNull = true;
        m = this.eventCollections.picture.at(0);
        this.eventCollections.picture.remove(m);
      }
      while (this.eventCollections.position.length !== 0) {
        this.eventCollections.position.notNull = true;
        m = this.eventCollections.position.at(0);
        this.eventCollections.position.remove(m);
      }
      if (this.called) {

        this.show();
      }
    }
  }, 100),

  getEventsCategory: function (event) {
    if (window.PryvBrowser.eventTypes.isNote(event)) {
      return 'note';
    } else if (window.PryvBrowser.eventTypes.isNumerical(event)) {
      return 'numerical';
    } else if (window.PryvBrowser.eventTypes.isPicture(event)) {
      return 'picture';
    } else if (window.PryvBrowser.eventTypes.isPosition(event)) {
      return 'position';
    } else {
      return null;
    }
  },

  getTimeSeriesCollectionByEvent: function (event) {
    if (window.PryvBrowser.eventTypes.isNote(event)) {
      return this.eventCollections.note;
    } else if (window.PryvBrowser.eventTypes.isNumerical(event)) {
      return this.eventCollections.numerical;
    } else if (window.PryvBrowser.eventTypes.isPicture(event)) {
      return this.eventCollections.picture;
    } else if (window.PryvBrowser.eventTypes.isPosition(event)) {
      return this.eventCollections.position;
    } else {
      return null;
    }
  },

  close: function () {
    this.chartView.close();
    $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
    $('.modal-backdrop').remove();
    this.$modal.find('.modal-content').empty();
  },


  /**
   * Adder functions
   */

  addSerieToChart: function (m) {
    this.chartCollection.add(m);
  },

  resizeModal: _.debounce(function () {
    this.chartView.render();
  }, 250)
});

},{"./../numericals/ChartModel.js":171,"./../numericals/ChartView.js":172,"./../numericals/TimeSeriesCollection.js":174,"./../numericals/TimeSeriesModel.js":175,"./../numericals/utils/ChartSettings.js":176,"./ListView.js":166,"underscore":104}],165:[function(require,module,exports){
var Marionette = require('backbone.marionette');

module.exports = Marionette.CompositeView.extend({
  template: '#template-draganddrop-itemview',
  tagName: 'li',
  ui: {
    selector: '.legend-candidate-item .legend-action',
    spanText: '.legend-candidate-item .legend-item-text'
  },
  state: false,
  templateHelpers: {
    displayName: function () {
      return this.streamName + ' (' + this.type + ')';
    }
  },
  onRender: function () {
    this.ui.selector.bind('click', function () {
      this.state = true;
      this.trigger('series:click', this.model);
    }.bind(this));
  }
});

},{"backbone.marionette":3}],166:[function(require,module,exports){
var Marionette = require('backbone.marionette'),
  ItemView = require('./ItemView.js');

module.exports = Marionette.CollectionView.extend({
  tagName: 'ul',
  itemView: ItemView,

  onRender: function () {
    if (this.children.length === 0) {
      this.$el.parent().css({visibility: 'hidden'});
    }
  }
});

},{"./ItemView.js":165,"backbone.marionette":3}],167:[function(require,module,exports){
var _ = require('underscore'),
  GenericsView = require('./View.js'),
  CommonModel = require('../common/Model.js');

module.exports = CommonModel.implement(
  function (events, params) {
    CommonModel.call(this, events, params);
    this.typeView = GenericsView;
    this.eventDisplayed = null;
    this.modelContent = {};
  },
  {
    beforeRefreshModelView: function () {
      this.modelContent = {
        content: this.eventDisplayed.content,
        description: this.eventDisplayed.description,
        id: this.eventDisplayed.id,
        modified: this.eventDisplayed.modified,
        streamId: this.eventDisplayed.streamId,
        tags: this.eventDisplayed.tags,
        time: this.eventDisplayed.time,
        type: this.eventDisplayed.type,
        event: this.eventDisplayed,
        eventsNbr: _.size(this.events)
      };
    }
  }
);
},{"../common/Model.js":146,"./View.js":168,"underscore":104}],168:[function(require,module,exports){
/* global $ */
var  Marionette = require('backbone.marionette');
var _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  template: '#genericsView',
  container: null,
  animation: null,
  templateHelpers: function () {
    return {
      getContent: function () {
        var event = this.model.get('event');
        if (event.type.split('/')[0] === 'url') {
          return  '<a href="' + event.content + '" target="_blank">' + event.content + '</a>';
        }
        if (_.isString(event.content)) {
          return event.content;
        }
        if (_.isNumber(event.content)) {
          return '<span class="value">' + event.content + '</span>';
        }
        if (_.isObject(event.content)) {
          return JSON.stringify(event.content, null, 2);
        }
        if (event.attachments) {
          var keys = _.keys(event.attachments);
          var href = event.url + '/' + event.attachments[keys[0]].id + '/' +
            event.attachments[keys[0]].fileName + '?readToken=' +
            event.attachments[keys[0]].readToken;
          return '<p><span class="fa fa-paperclip fa-2x"></span> </p>' +
            '<p><a href="' + href + '" target="_blank">' +
            event.attachments[keys[0]].fileName + '</a></p>';
        }
        return '<p><span class="fa fa-2x fa-question"></span></p>' +
          '<p>' + event.type + '</p>';
      }.bind(this)
    };
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.change);
    this.$el.css('height', '100%');
    this.$el.css('width', '100%');
    this.$el.addClass('animated node');
  },
  change: function () {
    $('#' + this.container).removeClass('animated ' + this.animation);
    this.animation = 'pulse';
    this.render();
  },
  renderView: function (container) {
    this.container = container;
    this.animation = 'bounceIn';
    this.render();
  },
  onRender: function () {
    if (this.container) {
      $('#' + this.container).removeClass('animated fadeIn');
      $('#' + this.container).html(this.el);
      $('#' + this.container).bind('click', function () {
        this.trigger('nodeClicked');
      }.bind(this));
      $('#' + this.container).addClass('animated ' + this.animation);
      setTimeout(function () {
        $('#' + this.container).removeClass('animated ' + this.animation);
      }.bind(this), 1000);
      $('#' + this.container).find('.content').dotdotdot();
    }
  },
  close: function () {
    this.remove();
  }
});
},{"backbone.marionette":3,"underscore":104}],169:[function(require,module,exports){
var _ = require('underscore'),
  NotesView = require('./View.js'),
  CommonModel = require('../common/Model.js');
var minWidth = 300;
var minHeight = 200;
var maxWidth = 300;
var maxHeight = 200;
module.exports = CommonModel.implement(
  function (events, params) {
    CommonModel.call(this, events, params);
    this.typeView = NotesView;
    this.eventDisplayed = null;
    this.modelContent = {};
    this.nbrDisplayW = -1;
    this.nbrDisplayH = -1;
    this.change = false;
  },

  {
    _howManyEventsCanBeDisplayed: function () {
      if (this.width < minWidth || this.height < minHeight) {
        this.nbrDisplayW = 1;
        this.nbrDisplayH = 1;
      }
      if (Math.ceil(this.width / maxWidth) !== this.nbrDisplayW ||
        Math.ceil(this.height / maxHeight) !== this.nbrDisplayH) {
        this.nbrDisplayW = Math.ceil(this.width / maxWidth);
        this.nbrDisplayH = Math.ceil(this.height / maxHeight);
      }
    },
    _findEventToDisplay: function () {
      this._howManyEventsCanBeDisplayed();
      this.eventsToDisplay = [];
      // sort events oldest first, latest last
      var events = _.sortBy(_.toArray(this.events), function (event) {
        return event.time;
      });
      var nbrEventToDisplay = this.nbrDisplayW * this.nbrDisplayH;
      if (events.length < nbrEventToDisplay) {
        this.nbrDisplayW = Math.ceil(Math.sqrt(events.length));
        this.nbrDisplayH = Math.ceil(events.length / this.nbrDisplayW);
        nbrEventToDisplay = events.length;
      }
      if (this.highlightedTime === Infinity) {
        this.eventsToDisplay = events.splice(events.length - nbrEventToDisplay);
      } else {
        //find nearest event
        var nearestIndex = 0;
        var timeDiff = Infinity;
        var nextTimeDiff = 0;
        for (var i = 0; i < events.length; i++) {
          nextTimeDiff = Math.abs(events[i].time - this.highlightedTime);
          if (nextTimeDiff <= timeDiff) {
            timeDiff = nextTimeDiff;
            nearestIndex = i;
          } else {
            break;
          }
        }
        this.eventsToDisplay.push(events[nearestIndex]);
        var beforeIndex = nearestIndex - 1;
        var afterIndex = nearestIndex + 1;
        for (var j = 0; j < nbrEventToDisplay - 1; j++) {
          if (!events[beforeIndex]) {
            this.eventsToDisplay.push(events[afterIndex]);
            afterIndex++;
          } else if (!events[afterIndex]) {
            this.eventsToDisplay.unshift(events[beforeIndex]);
            beforeIndex--;
          } else if (this.highlightedTime - events[beforeIndex].time >
            events[afterIndex].time - this.highlightedTime) {
            this.eventsToDisplay.push(events[afterIndex]);
            afterIndex++;
          } else {
            this.eventsToDisplay.unshift(events[beforeIndex]);
            beforeIndex--;
          }
        }

      }
    },
    beforeRefreshModelView: function () {
      for (var i = 0; i < this.eventsToDisplay.length; ++i) {
        var denomW = i >= (this.nbrDisplayH - 1) * this.nbrDisplayW &&
          this.eventsToDisplay.length % this.nbrDisplayW !== 0 ?
          this.eventsToDisplay.length % this.nbrDisplayW:
          this.nbrDisplayW;

        var border = 0;
        var width = (100 - (border * (denomW - 1))) / denomW;
        var left = (Math.floor(i % this.nbrDisplayW)) * (width + border);
        var height = (100 - (border * (this.nbrDisplayH - 1))) / this.nbrDisplayH;
        var top = (Math.floor(i / this.nbrDisplayW)) * (height + border);
        this.eventsToDisplay[i].width = width * this.width / 100.0;
        this.eventsToDisplay[i].height = height * this.height / 100.0;
        this.eventsToDisplay[i].top = top * this.height / 100.0;
        this.eventsToDisplay[i].left = left * this.width / 100.0;
      }

      this.modelContent = {
        events: this.eventsToDisplay,
        eventsNbr: _.size(this.events),
        change: this.change
      };
      this.change = !this.change;
    }
  }
);
},{"../common/Model.js":146,"./View.js":170,"underscore":104}],170:[function(require,module,exports){
/* global $, window */
var  Marionette = require('backbone.marionette'),
    _ = require('underscore');
module.exports = Marionette.ItemView.extend({
  template: '#picturesView',
  container: null,
  animation: null,
  currentId: null,
  initialize: function () {
    this.listenTo(this.model, 'change', this.change);
    this.$el.css('height', '100%');
    this.$el.css('width', '100%');
    this.$el.addClass('animated node');

  },
  change: function () {
    if (!this.currentId || this.currentId !== this.model.get('id')) {
      $('#' + this.container).removeClass('animated ' + this.animation);
      this.animation = '';
      this.$el.attr('id', this.model.get('id'));
      this.currentId = this.model.get('id');
    } else {
      this.animation = null;
    }
    this.render();
  },
  renderView: function (container) {
    this.container = container;
    this.animation = 'bounceIn';
    this.currentId = this.model.get('id');
    this.render();
  },
  onRender: function () {
    if (this.container) {
      var $mosaics = $('#' + this.container + ' .mosaic');
      var events = this.model.get('events');
      var displayedIds  = [];
      _.each($mosaics, function (mosaic) {
        displayedIds.push($(mosaic).attr('id'));
      });
      _.each(events, function (event) {
        var index = displayedIds.indexOf(event.id);
        if (index !== -1) {
          $('#' + event.id).css({
            width: event.width,
            height: event.height,
            top: event.top,
            left: event.left
          }).find('.Center-Block').html(window.PryvBrowser.renderNote(event.content));

          displayedIds[index] = null;
        } else {

          var toAdd = $('<div></div>')
            .addClass('mosaic node content Center-Container is-Table').attr('id', event.id)
            .append(
              '<div class="Table-Cell">' +
              '<div class="Center-Block">' +
                  window.PryvBrowser.renderNote(event.content) +
              '</div>' +
              '</div>')
            .css({
              'width': event.width,
              'height': event.height,
              'top': event.top,
              'left': event.left,
              'position': 'absolute'
            });
          $('#' + this.container).append(toAdd.fadeIn());
          setTimeout(function () {
            $('#' + event.id).dotdotdot({watch: true});
          }, 800);
        }
      }.bind(this));
      _.each(displayedIds, function (id) {
        if (id) {
          $('#' + id).remove();
        }
      });
      var $eventsNbr = $('#' + this.container + ' .aggregated-nbr-events');
      if ($eventsNbr.length === 0) {
        if (this.model.get('eventsNbr') > 1) {
          $('#' + this.container).append('<span class="aggregated-nbr-events">' +
            this.model.get('eventsNbr') + '</span>');
        }
        $('#' + this.container).bind('click', function () {
          this.trigger('nodeClicked');
        }.bind(this));
      } else {
        $eventsNbr.html(this.model.get('eventsNbr'));
      }




      $('#' + this.container).removeClass('animated fadeIn');

      if (this.animation) {
        $('#' + this.container).addClass('animated ' + this.animation);
        setTimeout(function () {
          $('#' + this.container).removeClass('animated ' + this.animation);
        }.bind(this), 1000);
      }
    }
  },
  close: function () {
    this.remove();
  }
});
},{"backbone.marionette":3,"underscore":104}],171:[function(require,module,exports){
var Backbone = require('backbone');

var ChartModel = {
  defaults: {
    // TODO: review those fields

    container: null,
    view: null,

    requiresDim: false,

    collection: null,

    highlighted: false,
    highlightedTime: null,

    allowPieChart: false,

    singleNumberAsText: true,

    // Chart dimensions
    dimensions: null,

    // Legend

    showLegend: true,
    legendActions: [ 'edit', 'duplicate', 'remove' ],

    /* Events control */
    onClick: null,
    onHover: null,
    onDnD: null,

    /**
     * Allow zooming & panning via subchart control.
     */
    enableNavigation: false,

    // Display X-axis
    xaxis: null,

    // Editable point mode
    editPoint: false,

    // Show node count
    showNodeCount: true
  }
};

ChartModel.initialize = function () {
  this.on('remove', function () {
    console.log('model: remove received');
  });
};

ChartModel.setHighlighted = function (highlight) {
  this.set('highlighted', highlight);
};

module.exports = Backbone.Model.extend(ChartModel);

},{"backbone":5}],172:[function(require,module,exports){
/* global $, Highcharts, moment, pryvBrowser */

var _ = require('underscore'),
    dateTime = require('../../../utility/dateTime'),
    Marionette = require('backbone.marionette'),
    pryv = require('pryv'),
    tsTransform = require('./utils/timeSeriesTransform.js');

var ChartView = {
  template: '#template-chart-container',
  container: null,
  data: null,
  chartSettings: {},
  chart: null,
  chartContainer: null,
  useExtras: null,
  waitExtras: null,
  currentlyEdited: null
};

ChartView.initialize = function () {
  this.listenTo(this.model.get('collection'), 'add', this.render);
  this.listenTo(this.model.get('collection'), 'remove', this.render);
  this.listenTo(this.model, 'change:dimensions', this.resize);
  this.listenTo(this.model, 'change:highlightedTime', this.onDateHighLighted);
  this.container = this.model.get('container');
};

ChartView.resize = function () {
  if (! this.model.get('dimensions')) {
    return;
  }
  if (this.model.get('requiresDim')) {
    $(this.chartContainer).css(this.model.get('dimensions'));
  }
  if (this.chart) {
    this.chart.reflow();
  } else { // TODO: may not be needed
    this.render();
  }
};

ChartView.onRender = function () {
  if (! this.model.get('collection') ||
      this.model.get('collection').length === 0 ||
      ! this.model.get('container')) {
    if (this.model.get('collection').length === 0) {
      $(this.model.get('container')).empty();
    }
    return;
  }

  this.useExtras  = true;
  try {
    if (! pryv.eventTypes.extras('mass/kg')) {
      this.useExtras = false;
    }
  } catch (e) {
    this.useExtras = false;
  }

  this.container = this.model.get('container');

  if (this.model.get('collection').length === 1 &&
      this.model.get('collection').at(0).get('events').length === 1 &&
      this.model.get('singleNumberAsText')) {
    this.singleEventSetup();
  } else {
    this.makeChart();
    this.onDateHighLighted();
  }
};

ChartView.makeChart = function () {
  var chartView = this,
      collection = this.model.get('collection');
  this.container = this.model.get('container');

  var settings = this.chartSettings = {
    series: [],
    yAxis: []
  };

  this.setUpContainer();

  var timeScale = pryvBrowser.timeView.getScale(),
      timeBounds = pryvBrowser.timeView.getTimeBounds(),
      fromMsTime = timeBounds.from * 1000,
      toMsTime = timeBounds.to * 1000,
      autoSeriesInterval = getAutoSeriesInterval(timeScale, fromMsTime, toMsTime);

  var eventsCount = 0,
      streamNamesPerDataId = {},
      eventSymbolsPerDataId = {},
      yIndexForType = {};
  collection.each(function (seriesModel) {
    seriesModel.sortData();

    var seriesId = getSeriesId(seriesModel.get('streamId'), seriesModel.get('type')),
        eventType = seriesModel.get('type'),
        eventSymbol = getEventValueSymbol(eventType,
            this.useExtras ? pryv.eventTypes.extras(eventType) : null);

    seriesModel.set('seriesId', seriesId);
    eventSymbolsPerDataId[seriesId] = eventSymbol;
    streamNamesPerDataId[seriesId] = seriesModel.get('streamName');
    seriesModel.set('seriesLegend', streamNamesPerDataId[seriesId] + ' (' + eventSymbol + ')');

    // separate y axis per event type
    var yIndex = yIndexForType[eventType];
    if (! yIndex) {
      yIndex = settings.yAxis.push({
        title: {text: null},
        labels: {enabled: false},
        gridLineWidth: 0
      }) - 1;
      yIndexForType[eventType] = yIndex;
    }

    var setInterval = seriesModel.get('interval');
    seriesModel.actualInterval = setInterval !== 'auto' ? setInterval : autoSeriesInterval;
    var series = {
      id: seriesId,
      name: seriesModel.get('seriesLegend'),
      type: getSeriesChartType(seriesModel.get('style')),
      yAxis: yIndex,
      data: tsTransform.transform(seriesModel.get('events'), {
        seriesId: seriesId,
        transform: seriesModel.get('transform'),
        interval: seriesModel.actualInterval
      }),
      tooltip: {valueSuffix: ' ' + eventSymbol}
    };

    if (seriesModel.get('color')) {
      series.color = seriesModel.get('color');
    }

    settings.series.push(series);

    eventsCount += seriesModel.get('events').length;
  }.bind(this));

  settings.plotOptions = {
    column: {
      borderColor: null,
      borderWidth: 1
    },
    series: {
      marker: {
        symbol: 'circle',
        radius: 3,
        lineColor: null,
        lineWidth: 1,
        fillColor: '#FFFFFF',
        states: {
          select: {
            fillColor: null,
            lineColor: null,
            radius: 5
          }
        }
      },
      states: {
        select: {
          color: null,
          borderColor: '#719726'
        }
      },
      turboThreshold: 0
    }
  };
  var tickSettings = dateTime.getTickSettings(timeScale, fromMsTime, toMsTime);
  settings.xAxis = {
    type: 'datetime',
    min: fromMsTime,
    max: toMsTime,
    tickPositions: tickSettings.getValues(fromMsTime, toMsTime),
    labels: {
      formatter: tickSettings.getLabel
    }
  };
  settings.tooltip = {
    shared: true,
    borderColor: '#BDC3C7',
    shadow: false,
    crosshairs: {
      width: 1,
      color: 'gray',
      dashStyle: 'dot'
    },
    formatter: function () {
      var s = '<strong>' + dateTime.getTimeText(this.x / 1000) + '</strong>';

      _.forEach(this.points, function (pt) {
        s += '<br/> <span style="color:' + pt.series.color + '">\u25CF</span> ' +
            streamNamesPerDataId[pt.series.options.id] +
            ': <strong>' + (+(pt.y).toFixed(2)) + '</strong> ' +
            pt.series.tooltipOptions.valueSuffix;
      }, this);

      return s;
    }
  };
  if (this.model.get('showLegend')) {
    var actions = this.model.get('legendActions');
    settings.legend = {
      verticalAlign: 'top',
      itemStyle: {
        //TODO: see about extracting all styles into a theme (see Highcharts docs)
        fontSize: actions ? '13px' : '10px',
        fontWeight: 'normal'
      },
      useHTML: true,
      labelFormatter: function () {
        var s = this.name;
        if (actions) {
          _.each(actions, function (action) {
            s += ' ' + getLegendActionButtonHTML(this.options.id, action);
          }.bind(this));
        }
        return s;
      }
    };
  } else {
    settings.legend = {enabled: false};
  }
  // TODO fix: this triggers an issue with model being modified by detailed view
  // (to reproduce: chart in treemap, open details, back, refresh: treemap chart model corrupted)
//  if (this.model.get('enableNavigation')) {
//    this.chartSettings.subchart = {show: true};
//  }
  settings.title = {text: ''};
  settings.chart = {
    reflow: false,
    renderTo: $(this.chartContainer)[0],
    style: {
      fontFamily: 'Roboto, Georgia, Arial, sans-serif'
    }
  };
  settings.credits = {enabled: false};

  this.chart = new Highcharts.Chart(settings);

  // event bindings, TODO: review & cleanup

  var $container = $(this.container);
  $container.off();
  if (this.model.get('showNodeCount')) {
    $container.append('<span class="aggregated-nbr-events">' + eventsCount + '</span>');
    // override default Highcharts handlers to let events we need get through
    this.chart.container.onmousedown = null;
    this.chart.container.onclick = function () {
      this.trigger('nodeClicked');
    }.bind(this);
  }

  if (this.model.get('legendActions')) {
    $('.legend-action', $container).on('click', function () {
      var $this = $(this),
          seriesId = $this.data('series-id');
      var seriesModel = collection.find(function (model) {
        return model.get('seriesId') === seriesId;
      });
      chartView.trigger($this.data('action'), seriesModel);
    });
  }

  // TODO review & cleanup

//  if (this.model.get('editPoint')) {
//    $container.bind('plotclick', this.onEdit.bind(this));
//  }
//
//  if (this.model.get('onClick')) {
//    $container.bind('plotclick', this.onClick.bind(this));
//  }
//  if (this.model.get('onHover')) {
//    $container.bind('plothover', this.onHover.bind(this));
//  }

  if (this.model.get('onDnD')) {
    $container.attr('draggable', true);
    $container.bind('dragstart', this.onDragStart.bind(this));
    $container.bind('dragenter', this.onDragEnter.bind(this));
    $container.bind('dragover', this.onDragOver.bind(this));
    $container.bind('dragleave', this.onDragLeave.bind(this));
    $container.bind('drop', this.onDrop.bind(this));
    $container.bind('dragend', this.onDragEnd.bind(this));
  }
};

function getSeriesId(streamId, eventType) {
  return streamId + '_' + eventType.replace('/', '_');
}

var ChartTypePerSeriesStyle = {
  bar: 'column',
  line: 'line',
  spline: 'spline',
  point: 'scatter'
};
function getSeriesChartType(seriesStyle) {
  return ChartTypePerSeriesStyle[seriesStyle] || ChartTypePerSeriesStyle.bar;
}

var SeriesIntervalForScale = {
  day: 'hourly',
  week: 'daily',
  month: 'daily',
  year: 'monthly',
  custom: null // dynamically determined
};

function getAutoSeriesInterval(timeScale, fromMsTime, toMsTime) {
  var interval = SeriesIntervalForScale[timeScale];
  if (! interval) {
    // custom scale
    var duration = moment.duration(toMsTime - fromMsTime);
    if (duration.months() >= 2) {
      interval = 'monthly';
    } else if (duration.days() >= 2) {
      interval = 'daily';
    } else {
      interval = 'hourly';
    }
  }
  return interval;
}

// TODO: extract event type formatting stuff to utility helper

function getEventValueSymbol(eventType, typeExtra) {
  var symbol;
  if (typeExtra) {
    symbol = typeExtra.symbol || typeExtra.name.en;
  }
  if (! symbol) {
    var typeParts = eventType.split('/');
    symbol = typeParts[typeParts.length - 1];
  }
  return symbol;
}

// TODO: see if we actually need this extra element
ChartView.setUpContainer = function () {
  // Setting up the chart container
  this.chartContainer = this.container + ' .chartContainer';
  $(this.container).html('<div class="chartContainer"></div>');
};

function getLegendActionButtonHTML(seriesId, action) {
  var iconClasses = {
    ready: 'fa-check',
    duplicate: 'fa-files-o',
    remove: 'fa-minus',
    edit: 'fa-cog'
  };
  var titles = {
    ready: '',
    duplicate: 'Duplicate',
    remove: 'Remove',
    edit: 'Edit settings'
  };
  return '<a class="legend-action legend-action-' + action + '" href="javascript:;" ' +
      'data-series-id="' + seriesId + '" data-action="' + action + '" ' +
      'title="' + titles[action] + '"><i class="fa ' + iconClasses[action] + '"></i></a>';
}

ChartView.onDateHighLighted = function (highlightedTime) {
  if (! highlightedTime) {
    highlightedTime = this.model.get('highlightedTime');
  }
  if (! this.chart || ! highlightedTime) { return; }

  this._deselectAllPoints();

  this.model.get('collection').each(function (seriesModel) {
    var seriesId = seriesModel.get('seriesId'),
        points = this.chart.get(seriesId).points,
        dF = getDurationFunction(seriesModel.get('interval')),
        distance = null,
        best = 0;

    for (var i = 0, len = points.length; i < len; i++) {
      var ptTime = points[i].x,
          duration = dF(new Date(ptTime)),
          distToStart = Math.abs(highlightedTime - (ptTime / 1000)),
          distToEnd = Math.abs(highlightedTime - ((ptTime + duration) / 1000));

      if (distance === null) {
        best = i;
        distance = distToStart < distToEnd ? distToStart : distToEnd;
      } else if ((ptTime / 1000) <= highlightedTime &&
          highlightedTime <= ((ptTime + duration) / 1000)) {
        best = i;
        break;
      } else if (distToStart <= distance || distToEnd <= distance) {
        best = i;
        distance = distToStart < distToEnd ? distToStart : distToEnd;
      }
    }

    best = points.length === best ? best - 1: best;
    points[best].select(true, true);
  }.bind(this));
};

function getDurationFunction(interval) {
  switch (interval) {
  case 'hourly' :
    return function () { return 3600 * 1000; };
  case 'daily' :
    return function () { return 24 * 3600 * 1000; };
  case 'weekly' :
    return function () { return 7 * 24 * 3600 * 1000; };
  case 'monthly' :
    return function (d) {
      return (new Date(d.getFullYear(), d.getMonth(), 0)).getDate() * 24 * 3600 * 1000;
    };
  case 'yearly' :
    return function (d) {
      return (d.getFullYear() % 4 === 0 &&
      (d.getFullYear() % 100 !== 0 || d.getFullYear() % 400 === 0)) ? 366 :365;
    };
  default :
    return function () {
      return 0;
    };
  }
}

ChartView.highlightEvent = function (event) {
  if (! this.chart) { return; }

  this._deselectAllPoints();

  var pt = this.chart.get(event.id);
  if (! pt) {
    var seriesId = getSeriesId(event.streamId, event.type);
    var seriesModel = this.model.get('collection').find(function (model) {
      return model.get('seriesId') === seriesId;
    });
    var getPtId = tsTransform.getAggregationGroupKeyFn(seriesId, seriesModel.actualInterval);
    pt = this.chart.get(getPtId(new Date(event.time * 1000)));
  }

  pt.select(true);
};

ChartView._deselectAllPoints = function () {
  _.forEach(this.chart.getSelectedPoints(), function (pt) { pt.select(false); });
};

ChartView.onClose = function () {
  $('#editPointVal').unbind();
  $('#editPointBut').unbind();
  $('#chart-pt-editor').remove();
  $(this.chartContainer).empty();
  $(this.container).unbind();
  $(this.container).empty();
  this.container = null;
  this.chartContainer = null;
  this.chartSettings = null;
  this.chart = null;
};

/************************
 * Click Functions
 */

ChartView.onClick = function () {
  this.trigger('chart:clicked', this.model);
};

//ChartView.onEdit = function (event, pos, item) {
//  if ($('#chart-pt-editor')) {
//    $('#editPointVal').unbind();
//    $('#editPointBut').unbind();
//    $('#chart-pt-editor').remove();
//  }
//  if (this.model.get('editPoint') && item) {
//    var tc = this.model.get('collection').at(0);
//    if ((tc.get('transform') === 'none' || tc.get('transform') === null) &&
//      (tc.get('interval') === 'none' || tc.get('interval') === null)) {
//      var editedSerie =  this.model.get('collection').at(item.seriesIndex);
//      var allEvents = editedSerie.get('events');
//      var editedEvent = null;
//      for (var i = 0; i < allEvents.length; ++i) {
//        if (allEvents[i].content === item.datapoint[1] &&
//          allEvents[i].time * 1000 === item.datapoint[0]) {
//          editedEvent =  allEvents[i];
//          break;
//        }
//      }
//      this.currentlyEdited = {
//        event: editedEvent,
//        eventId: editedEvent.id,
//        streamId: editedEvent.streamId,
//        value: editedEvent.content,
//        time: editedEvent.time
//      };
//      this.showPointEditor(item.pageY + 5, item.pageX + 5);
//    }
//  }
//};
//
//ChartView.showPointEditor = function (x, y) {
//  $('.modal-content').append(
//    '<div id="chart-pt-editor" class="tooltip has-feedback">' +
//    '  <div class="input-group">' +
//    '    <input type="text" class="form-control" id="editPointVal" placeholder="' +
//      this.currentlyEdited.value + '">' +
//    '      <span id="feedback" class="glyphicon form-control-feedback"></span>' +
//    '    <span class="input-group-btn">' +
//    '      <button class="btn" id="editPointBut" type="button">Ok!</button>' +
//    '    </span>' +
//    '  </div>' +
//    '</div>');
//
//  var os = $('.modal-content').offset();
//  $('#chart-pt-editor').css({
//    color: 'none',
//    'background-color': 'none',
//    width: '20%',
//    top: x - os.top,
//    left: y - os.left
//  }).fadeIn(200);
//
//  $('#editPointVal').bind('input', function () {
//    if ($(this).val().length < 1) {
//      $('#chart-pt-editor').removeClass('has-success');
//      $('#chart-pt-editor').removeClass('has-warning');
//      $('#editPointBut').removeClass('btn-success');
//      $('#editPointBut').removeClass('btn-danger');
//    } else if (isNaN($(this).val())) {
//      $('#chart-pt-editor').removeClass('has-success');
//      $('#chart-pt-editor').addClass('has-warning');
//      $('#editPointBut').removeClass('btn-success');
//      $('#editPointBut').addClass('btn-danger');
//    } else {
//      $('#chart-pt-editor').removeClass('has-warning');
//      $('#chart-pt-editor').addClass('has-success');
//      $('#editPointBut').removeClass('btn-danger');
//      $('#editPointBut').addClass('btn-success');
//    }
//  });
//
//  $('#editPointBut').bind('click', function () {
//    this.currentlyEdited.value = +$('#editPointVal').val();
//    this.currentlyEdited.event.content = this.currentlyEdited.value;
//    if ($('#chart-pt-editor')) {
//      $('#editPointVal').unbind();
//      $('#editPointBut').unbind();
//      $('#chart-pt-editor').remove();
//    }
//    this.trigger('eventEdit', this.currentlyEdited);
//    this.render();
//  }.bind(this));
//};

/************************
 * Drag and Drop Functions
 */

var dndTransferData = null;

/* Called when this object is starts being dragged */
ChartView.onDragStart = function (e) {
  dndTransferData = '{ "nodeId": "' + this.container.substr(1) + '", ' +
    '"streamId": "' + $(this.container).attr('data-streamid') + '", ' +
    '"connectionId": "' + $(this.container).attr('data-connectionid') + '"}';
  e.originalEvent.dataTransfer.setData('text', dndTransferData);
};

/* Fires when a dragged element enters this' scope */
ChartView.onDragEnter = function (e) {
  var data = dndTransferData;
  var droppedNodeID = data.nodeId;
  if ($(e.currentTarget).attr('id') !== droppedNodeID) {
    $('.chartContainer', $(e.currentTarget)).not(this.container).addClass('animated shake');
    $('.NumericalsEventsNode  > div').not(this.container).addClass('animated shake');
    setTimeout(function () {
      $('.chartContainer', $(e.currentTarget)).removeClass('animated shake');
      $('.NumericalsEventsNode  > div', $(e.currentTarget)).removeClass('animated shake');
    }, 1000);
  }
};

/* Fires when a dragged element is over this' scope */
ChartView.onDragOver = function (e) {
  e.preventDefault();
};

/* Fires when a dragged element leaves this' scope */
ChartView.onDragLeave = function () {
  var data = dndTransferData;
  var droppedNodeID = data.nodeId;
  $('.chartContainer').not('#' + droppedNodeID + ' .chartContainer').addClass('animated shake');
  $('.NumericalsEventsNode  > div')
    .not('#' + droppedNodeID + ' .chartContainer').addClass('animated shake');
  setTimeout(function () {
    $('.chartContainer').removeClass('animated shake');
    $('.NumericalsEventsNode > div').removeClass('animated shake');
  }, 1000);
};

/* Called when this object is stops being dragged */
ChartView.onDragEnd = function () {};

/* Called when an element is dropped on it */
ChartView.onDrop = function (e) {
  e.stopPropagation();
  e.preventDefault();
  var data = JSON.parse(e.originalEvent.dataTransfer.getData('text'));
  var droppedNodeID = data.nodeId;
  var droppedStreamID = data.streamId;
  var droppedConnectionID = data.connectionId;
  this.trigger('chart:dropped', droppedNodeID, droppedStreamID, droppedConnectionID);
};

ChartView.singleEventSetup = function () {
  var m = this.model.get('collection').at(0);
  if (this.model.get('showNodeCount')) {
    $(this.container).html(
    '<div class="content Center-Container is-Table">' +
    '<div class="Table-Cell">' +
    '<div class="Center-Block">' +
    '<span class="value"> ' +
    m.get('events')[0].content + ' ' +
    '</span><span class="unity">' +
    (this.useExtras ?
      pryv.eventTypes.extras(m.get('events')[0].type).symbol ||
      pryv.eventTypes.extras(m.get('events')[0].type).name.en || '' : m.get('events')[0].type) +
    '</span></div></div></div>');
  }

  $(this.container).unbind();

  $(this.container).bind('resize', function () {
    this.trigger('chart:resize', this.model);
  });

  if (this.model.get('onDnD')) {
    $(this.container).attr('draggable', true);
    $(this.container).bind('dragstart', this.onDragStart.bind(this));
    $(this.container).bind('dragenter', this.onDragEnter.bind(this));
    $(this.container).bind('dragover', this.onDragOver.bind(this));
    $(this.container).bind('dragleave', this.onDragLeave.bind(this));
    $(this.container).bind('drop', this.onDrop.bind(this));
    $(this.container).bind('dragend', this.onDragEnd.bind(this));
  }
  if (this.model.get('showNodeCount')) {
    $(this.container).bind('click',
    function () {
      this.trigger('nodeClicked');
    }.bind(this));
  }
};

module.exports = Marionette.CompositeView.extend(ChartView);

/**
 * Highcharts plugin for setting a lower opacity for other series than the one that is hovered
 * in the legend
 *
 * TODO: separate into its own file
 */
(function (Highcharts) {
  var each = Highcharts.each;

  Highcharts.wrap(Highcharts.Legend.prototype, 'renderItem', function (proceed, item) {
    proceed.call(this, item);

    var isPoint = !!item.series,
        collection = isPoint ? item.series.points : this.chart.series,
        groups = isPoint ? ['graphic'] : ['group', 'markerGroup'],
        element = (this.options.useHTML ? item.legendItem : item.legendGroup).element;

    element.onmouseover = function () {
      each(collection, function (seriesItem) {
        if (seriesItem !== item) {
          each(groups, function (group) {
            seriesItem[group].animate({opacity: 0.25}, {duration: 150});
          });
        }
      });
    };

    element.onmouseout = function () {
      each(collection, function (seriesItem) {
        if (seriesItem !== item) {
          each(groups, function (group) {
            seriesItem[group].animate({opacity: 1}, {duration: 50});
          });
        }
      });
    };
  });
}(Highcharts));

},{"../../../utility/dateTime":133,"./utils/timeSeriesTransform.js":177,"backbone.marionette":3,"pryv":50,"underscore":104}],173:[function(require,module,exports){
/* global window, $ */

var _ = require('underscore'),
  DetailView = require('../detailed/Controller.js'),
  ChartView = require('./ChartView.js'),
  ChartModel = require('./ChartModel.js'),
  TsCollection = require('./TimeSeriesCollection.js'),
  TsModel = require('./TimeSeriesModel.js'),
  Settings = require('./utils/ChartSettings.js');

var NumericalsPlugin = module.exports = function (events, params, node) {
  this.seriesCollection = null;

  /* Base event containers */
  this.eventsToAdd = [];
  this.eventsToRem = [];
  this.eventsToCha = [];

  this.debounceRefresh = _.debounce(function () {
    this.refreshCollection();
  }, 1000);

  this.debounceResize = _.debounce(function () {
    this.resize();
  }, 1500);

  this.events = {};
  this.highlightedTime = Infinity;
  this.modelView = null;
  this.view = null;
  this.eventDisplayed = null;
  this.container = null;
  this.needToRender = null;
  this.datas = {};
  this.streamIds = {};
  this.eventsNode = node;
  this.hasDetailedView = false;
  this.$modal = $('#pryv-modal').on('hidden.bs.modal', function () {
    if (this.detailedView) {
      this.detailedView.close();
      this.detailedView = null;
    }
  }.bind(this));
  _.extend(this, params);

  for (var e in events) {
    if (events.hasOwnProperty(e)) {
      this.eventEnter(events[e]);
    }
  }
  $(window).resize(this.debounceRefresh.bind(this));
};

NumericalsPlugin.prototype.eventEnter = function (event) {
  this.streamIds[event.streamId] = event;
  this.events[event.id] = event;
  if (!this.datas[event.streamId]) {
    this.datas[event.streamId] = {};
  }
  if (!this.datas[event.streamId][event.type]) {
    this.datas[event.streamId][event.type] = {};
  }
  this.datas[event.streamId][event.type][event.id] = event;
  this.needToRender = true;
  if (this.hasDetailedView) {
    this.treeMap.addEventsDetailedView(event);
  }
  this.eventsToAdd.push(event);
  this.debounceRefresh();
};

NumericalsPlugin.prototype.eventLeave = function (event) {
  if (this.events[event.id]) {
    delete this.events[event.id];
    delete this.datas[event.streamId][event.type][event.id];
    this.needToRender = true;
    if (this.hasDetailedView) {
      this.treeMap.deleteEventDetailedView(event);
    }
    this.eventsToRem.push(event);
    this.debounceRefresh();
  }
};

NumericalsPlugin.prototype.eventChange = function (event) {
  if (this.events[event.id]) {
    this.events[event.id] = event;
    this.datas[event.streamId][event.type][event.id] = event;
    this.needToRender = true;
    if (this.hasDetailedView) {
      this.treeMap.updateEventDetailedView(event);
    }
    this.eventsToCha.push(event);
    this.debounceRefresh();
  }
};

NumericalsPlugin.prototype.OnDateHighlightedChange = function (time) {
  if (time) {
    this.highlightedTime = time;
  }
  if (this.view) {
    this.view.onDateHighLighted(time);
  }
  if (this.hasDetailedView) {
    this.treeMap.highlightDateDetailedView(this.highlightedTime);
  }
};

NumericalsPlugin.prototype.render = function (container) {
  this.container = container;
  this.needToRender = true;
  this.debounceRefresh();
};
NumericalsPlugin.prototype.refresh = function (object) {
  _.extend(this, object);
  this.needToRender = true;
  this.debounceRefresh();
};

NumericalsPlugin.prototype.close = function () {
  if (this.view) {
    this.view.close();
  }

  delete this.modelView;
  delete this.view;
  this.view = null;
  this.events = null;
  this.datas = null;
  this.highlightedTime = Infinity;
  this.modelView = null;
  this.eventDisplayed = null;
  this.needToRender = false;
};

NumericalsPlugin.prototype.refreshCollection = function () {
  if (this.seriesCollection === null) {
    this.seriesCollection = new TsCollection([], {type: 'any'});
  }

  var eventsToAdd = this.eventsToAdd;
  var eventsToRem = this.eventsToRem;
  var eventsToCha = this.eventsToCha;

  var eventsModel;
  var events;
  var matching;

  this.eventsToAdd = [];
  this.eventsToRem = [];
  this.eventsToCha = [];

  var i;
  var eIter;

  // Process those to add
  for (i = 0; i < eventsToAdd.length; ++i) {
    var filter = {
      connectionId: eventsToAdd[i].connection.id,
      streamId: eventsToAdd[i].streamId,
      type: eventsToAdd[i].type
    };


      // find corresponding model
    matching = this.seriesCollection.where(filter);
    if (matching && matching.length !== 0) {
      eventsModel = matching[0];
      eventsModel.get('events').push(eventsToAdd[i]);
    } else {
      var s = new Settings(eventsToAdd[i].stream,
        eventsToAdd[i].type, this.eventsNode.parent.stream.virtual);
      eventsModel = new TsModel({
        events: [eventsToAdd[i]],
        connectionId: eventsToAdd[i].connection.id,
        streamId: eventsToAdd[i].streamId,
        streamName: eventsToAdd[i].stream.name,
        type: eventsToAdd[i].type,
        category: 'any',
        virtual: this.eventsNode.parent.stream.virtual,
        color: s.get('color'),
        style: s.get('style'),
        transform: s.get('transform'),
        interval: s.get('interval')
      });
      this.seriesCollection.add(eventsModel);
    }
  }

  // Process those to remove
  for (i = 0; i < eventsToRem.length; ++i) {
      // find corresponding model
    matching = this.seriesCollection.where({
      connectionId: eventsToRem[i].connection.id,
      streamId: eventsToRem[i].streamId,
      type: eventsToRem[i].type
    });
    if (matching && matching.length !== 0) {
      eventsModel = matching[0];
      events = eventsModel.get('events');
      var events_new = [];
      for (eIter = 0; eIter < events.length; ++eIter) {
        if (events[eIter].id !== eventsToRem[i].id) {
          events_new.push(events[eIter]);
        }
      }
      if (events_new.length === 0) {
        this.seriesCollection.remove(eventsModel);
      } else {
        eventsModel.set('events', events_new);
      }
    }
  }


  // Process those to change
  for (i = 0; i < eventsToCha.length; ++i) {
    // find corresponding model
    matching = this.seriesCollection.where({
      connectionId: eventsToCha[i].connection.id,
      streamId: eventsToCha[i].streamId,
      type: eventsToCha[i].type
    });
    if (matching && matching.length !== 0) {
      eventsModel = matching[0];
      events = eventsModel.get('events');
      for (eIter = 0; eIter < events.length; ++eIter) {
        if (events[eIter].id === eventsToCha[i].id) {
          events[eIter] = eventsToCha[i];
        }
      }
    }
  }


  if ((! this.modelView || ! this.view) && this.seriesCollection.length !== 0 && this.container) {
    this.modelView = new ChartModel({
      container: '#' + this.container,
      view: null,
      requiresDim: true,
      collection: this.seriesCollection,
      highlighted: false,
      highlightedTime: null,
      allowPieChart: false,
      dimensions: this.computeDimensions(),
      showLegend: true,
      legendActions: false,  // A button in the legend
      onClick: true,
      onHover: true,
      onDnD: true,
      enableNavigation: false,
      xaxis: false
    });
    if (typeof(document) !== 'undefined')  {
      this.view = new ChartView({model: this.modelView});
      this.modelView.set('dimensions', this.computeDimensions());
      $('#' + this.container).resize(function () {
        this.debounceResize.bind(this);
      }.bind(this));
      this.view.render();
      this.view.onDateHighLighted(this.highlightedTime);
      this.view.on('chart:dropped', this.onDragAndDrop.bind(this));
      this.view.on('chart:resize', this.resize.bind(this));
      this.view.on('nodeClicked', function () {
        if (!this.detailedView) {
          this.detailedView = new DetailView(this.$modal, null, this.stream);
        }
        this.detailedView.addEvents(this.events);
        this.detailedView.show();
        this.detailedView.highlightDate(this.highlightedTime);
        this.detailedView.virtual = this.eventsNode.parent.stream.virtual;
      }.bind(this));
    }
  } else if (this.view) {
    this.view.render();
    this.view.onDateHighLighted(this.highlightedTime);
    this.debounceResize();
  }
};

NumericalsPlugin.prototype._findEventToDisplay = function () {
  if (this.highlightedTime === Infinity) {
    var oldestTime = 0;
    _.each(this.events, function (event) {
      if (event.time >= oldestTime) {
        oldestTime = event.time;
        this.eventDisplayed = event;
      }
    }, this);

  } else {
    var timeDiff = Infinity, debounceRefresh = 0;
    _.each(this.events, function (event) {
      debounceRefresh = Math.abs(event.time - this.highlightedTime);
      if (debounceRefresh <= timeDiff) {
        timeDiff = debounceRefresh;
        this.eventDisplayed = event;
      }
    }, this);
  }
};

/**
 * Propagates the drag and drop event further up to the TreeMap controller
 * @param nodeId
 * @param streamId
 * @param connectionId
 */
NumericalsPlugin.prototype.onDragAndDrop = function (nodeId, streamId, connectionId) {
  this.eventsNode.dragAndDrop(nodeId, streamId, connectionId);
};

NumericalsPlugin.prototype.computeDimensions = function () {
  var chartSizeWidth = null;
  var chartSizeHeight = null;

  if (this.width !== null) {
    chartSizeWidth = this.width;
  } else if ($('#' + this.container).length)  {
    chartSizeWidth = $('#' + this.container).width();
  } else if ($('#' + this.container).length)  {
    chartSizeWidth = parseInt($('#' + this.container).prop('style').width.split('px')[0], 0);
  }

  if (this.height !== null) {
    chartSizeHeight = this.height;
  } else if ($('#' + this.container).length)  {
    chartSizeHeight = $('#' + this.container).height();
  } else if ($('#' + this.container).length)  {
    chartSizeHeight = parseInt($('#' + this.container).prop('style').height.split('px')[0], 0);
  }

  return {width: chartSizeWidth, height: chartSizeHeight};
};

NumericalsPlugin.prototype.resize = function () {
  this.modelView.set('dimensions', this.computeDimensions());
  this.modelView.set('container', '#' + this.container);
  this.view.resize();
};

},{"../detailed/Controller.js":149,"./ChartModel.js":171,"./ChartView.js":172,"./TimeSeriesCollection.js":174,"./TimeSeriesModel.js":175,"./utils/ChartSettings.js":176,"underscore":104}],174:[function(require,module,exports){
var Backbone = require('backbone'),
    Model = require('./TimeSeriesModel.js');

var TimeSeriesCollection = {
  model: Model
};

TimeSeriesCollection.initialize = function (models, options) {
  this.type = options.type;
};

TimeSeriesCollection.comparator = function () {};

module.exports = Backbone.Collection.extend(TimeSeriesCollection);

},{"./TimeSeriesModel.js":175,"backbone":5}],175:[function(require,module,exports){
var Backbone = require('backbone');

// TODO: see for making this a plain constructor instead of a Backbone model for simplicity

var TimeSeriesModel = {
  defaults: {
    events: [],
    connectionId: null,
    streamId: null,
    streamName: null,
    type: null,
    category: null,

    seriesId: null,
    seriesLegend: null,

    color: null,
    style: 'bar',
    transform: 'sum',
    interval: 'auto',

    virtual: null
  }
};

TimeSeriesModel.sortData = function () {
  this.get('events').sort(function (a, b) {
    if (a.time < b.time) { return -1; }
    if (b.time < a.time) { return 1; }
    return 0;
  });
};

module.exports = Backbone.Model.extend(TimeSeriesModel);

},{"backbone":5}],176:[function(require,module,exports){
var streamUtils = require('../../../../utility/streamUtils');

var ChartSettings = module.exports = function ChartSettings(stream, type, virtualNode, offset) {
  this._stream = stream;
  this._type = type;
  this._virtualNode = virtualNode;

  this._offset = offset ? offset : 0;
  this._cnt = offset ? offset : 0;

  this._ptr = null;

  this._createIfNotExist();
};

ChartSettings.prototype._createIfNotExist = function () {
  if (this._virtualNode) {
    var found = false;
    for (var i = 0; i < this._virtualNode.filters.length; ++i) {
      if (this._virtualNode.filters[i].streamId === this._stream.id &&
        this._virtualNode.filters[i].type === this._type) {
        if (this._cnt === 0) {
          found = true;
          break;
        } else {
          this._cnt--;
        }
      }
    }
    if (found) {
      if (!this._virtualNode.filters[i].settings) {
        this._virtualNode.filters[i].settings = {};
      }
      this._ptr = this._virtualNode.filters[i].settings;
    }
  } else {
    this._ptr = streamUtils.getChartSettingsForType(this._stream, this._type);
    if (! this._ptr) {
      this._ptr = streamUtils.setChartSettingsForType(this._stream, this._type, {});
    }
  }
};

ChartSettings.prototype.get = function (key) {
  return this._ptr[key];
};

ChartSettings.prototype.set = function (key, value) {
  this._ptr[key] = value;
  this._pushChanges();
};

ChartSettings.prototype._pushChanges = function () {
  var changes = null;
  if (this._virtualNode) {
    changes = {'browser:virtualnode': this._virtualNode._getDataPointer()};
    console.log('Pushing these changes in privateProfile', changes);
    this._stream.connection.profile.setPrivate(changes, function (error, result) {
      console.log('privateProfile for', 'browser:virtualnode', 'has been pushed:', error, result);
    });
  } else {
    changes = {id: this._stream.id, clientData: this._stream.clientData};
    console.log('Pushing these changes in clientData', changes);
    this._stream.connection.streams._updateWithData(changes, function (error, result) {
      console.log('clientData for has been pushed:', error, result);
    });
  }
};

},{"../../../../utility/streamUtils":135}],177:[function(require,module,exports){
var _ = require('underscore');

var tsTransform = module.exports = {};

/**
 * @param {TimeSeriesModel} seriesModel
 * @param {String} autoInterval The dynamically-determined interval to use if interval is "auto"
 * @returns {Object} Object with array props `xCol` and `yCol`
 *                   (the first item of each one is the column header)
 */
tsTransform.transform = function (events, settings) {
  var aggGroupKeyFn = tsTransform.getAggregationGroupKeyFn(settings.seriesId, settings.interval),
      aggGroupTimeFn = tsTransform.getAggregationGroupTimeFn(settings.interval);

  var aggGroups = getAggregationGroups(events, aggGroupKeyFn, aggGroupTimeFn);

  switch (settings.transform) {
  case 'sum':
    return applySum(aggGroups);
  case 'average':
    return applyAverage(aggGroups);
  default:
    return applyRaw(events);
  }
};

tsTransform.getAggregationGroupKeyFn = function (seriesId, interval) {
  switch (interval) {
  case 'hourly' :
    return function (d) {
      return seriesId + '_' + d.getFullYear().toString() +  '-' + d.getMonth().toString() +  '-' +
          d.getDate().toString() +  '-' + d.getHours().toString();
    };
  case 'daily' :
    return function (d) {
      return seriesId + '_' + d.getFullYear().toString() +  '-' + d.getMonth().toString() +  '-' +
          d.getDate().toString();
    };
  case 'weekly' :
    return function (d) {
      var msSinceFirstWeekday = d.getDay() * 24 * 3600 * 1000 + d.getHours() * 3600 * 1000;
      var asWeek = new Date(d.getTime() - msSinceFirstWeekday);
      return seriesId + '_' + asWeek.getFullYear().toString() +  '-' +
          getISO8601Week(asWeek).toString();
    };
  case 'monthly' :
    return function (d) {
      return seriesId + '_' + d.getFullYear().toString() +  '-' + d.getMonth().toString();
    };
  case 'yearly' :
    return function (d) {
      return seriesId + '_' + d.getFullYear().toString();
    };
  default :
    return function (d) {
      return seriesId + '_' + d.getDate().toString();
    };
  }
};

/**
 * @returns {number} the week number of this date.
 */
function getISO8601Week(date) {
  var target = new Date(date.valueOf());
  var dayNr = (date.getDay() + 6) % 7;
  target.setDate(target.getDate() - dayNr + 3);
  var jan4 = new Date(target.getFullYear(), 0, 4);
  var dayDiff = (target - jan4) / 86400000;
  var weekNr = 1 + Math.ceil(dayDiff / 7);
  return weekNr;
}

tsTransform.getAggregationGroupTimeFn = function (interval) {
  switch (interval) {
  case 'hourly' :
    return function (d) {
      return (new Date(d.getFullYear(), d.getMonth(), d.getDate(),
          d.getHours(), 0, 0, 0)).getTime();
    };
  case 'daily' :
    return function (d) {
      return (new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0)).getTime();
    };
  case 'weekly' :
    return function (d) {
      var msSinceFirstWeekday = d.getDay() * 24 * 3600 * 1000 + d.getHours() * 3600 * 1000;
      var asWeek = new Date(d.getTime() - msSinceFirstWeekday);
      return (new Date(asWeek.getFullYear(), asWeek.getMonth(),
          asWeek.getDate(), 0, 0, 0, 0)).getTime();
    };
  case 'monthly' :
    return function (d) {
      return (new Date(d.getFullYear(), d.getMonth(), 0, 0, 0, 0, 0)).getTime();
    };
  case 'yearly' :
    return function (d) {
      return (new Date(d.getFullYear(), 0, 0, 0, 0, 0, 0)).getTime();
    };
  default :
    return function (d) {
      return d.getTime();
    };
  }
};

function applyRaw(events) {
  return _.map(events, function (e) {
    return {
      id: e.id,
      x: e.time * 1000,
      y: getValue(e)
    };
  });
}

function getAggregationGroups(events, aggGroupKeyFn, aggGroupTimeFn) {
  var mappedEvents = _.map(events, function (e) {
    var d = new Date(e.time * 1000);
    return {
      key: aggGroupKeyFn(d),
      time: +aggGroupTimeFn(d),
      value: getValue(e)
    };
  });
  return _.groupBy(mappedEvents, function (e) {
    return e.key;
  });
}

/*
 in -> {1234: [123, 1234, 345], 145: [1234] ,...}
 out -> [[1234, sum], [145, sum]]
 */
function applySum(aggregationGroups) {
  return _.map(aggregationGroups, function (groupEvents) {
    return {
      id: groupEvents[0].key,
      x: groupEvents[0].time,
      y: computeSum(groupEvents)
    };
  });

  function computeSum(a) {
    return _.reduce(a, function (c, e) {
      return c + e.value;
    }, 0);
  }
}

/*
 in -> {1234: [123, 1234, 345], 145: [1234] ,...}
 out -> [[1234, sum], [145, sum]]
 */
// TODO: cleanup (unused)
//function applyStackedSum(aggregationGroups, result) {
//  var total = 0;
//
//  var groupKeys = [];
//  _.each(aggregationGroups, function (groupEvents, key) {
//    groupKeys.push(key);
//  });
//  groupKeys.sort();
//
//  return _.map(groupKeys, function (key) {
//    return [ aggregationGroups[key][0].time, computeStackedSum(aggregationGroups[key]) ];
//  });
//
//  function computeStackedSum(events) {
//    total += _.reduce(events, function (current, e) {
//      return current + e.value;
//    }, 0);
//    return total;
//  }
//}

/*
 in -> {1234: [123, 1234, 345], 145: [1234] ,...}
 out -> [[1234, avg], [145, avg]]
 */
function applyAverage(aggregationGroups) {
  return _.map(aggregationGroups, function (groupEvents) {
    return {
      id: groupEvents[0].key,
      x: groupEvents[0].time,
      y: computeAverage(groupEvents)
    };
  });

  function computeAverage(a) {
    var sum = _.reduce(a, function (c, e) {
      return c + e.value;
    }, 0);
    return sum / a.length;
  }
}

function getValue(event) {
  return +event.content;
}

},{"underscore":104}],178:[function(require,module,exports){
var _ = require('underscore'),
  PicturesView = require('./View.js'),
  CommonModel = require('../common/Model.js');
var minWidth = 300;
var minHeight = 200;
var maxWidth = 300;
var maxHeight = 200;
module.exports = CommonModel.implement(
  function (events, params) {
    CommonModel.call(this, events, params);
    this.typeView = PicturesView;
    this.eventDisplayed = null;
    this.modelContent = {};
    this.nbrDisplayW = -1;
    this.nbrDisplayH = -1;
    this.change = false;
  },

  {
    _howManyEventsCanBeDisplayed: function () {
      if (this.width < minWidth || this.height < minHeight) {
        this.nbrDisplayW = 1;
        this.nbrDisplayH = 1;
      }
      if (Math.ceil(this.width / maxWidth) !== this.nbrDisplayW ||
        Math.ceil(this.height / maxHeight) !== this.nbrDisplayH) {
        this.nbrDisplayW = Math.ceil(this.width / maxWidth);
        this.nbrDisplayH = Math.ceil(this.height / maxHeight);
      }
    },
    _findEventToDisplay: function () {
      this._howManyEventsCanBeDisplayed();
      this.eventsToDisplay = [];
      // sort events oldest first, latest last
      var events = _.sortBy(_.toArray(this.events), function (event) {
        return event.time;
      });
      var nbrEventToDisplay = this.nbrDisplayW * this.nbrDisplayH;
      if (events.length < nbrEventToDisplay) {
        this.nbrDisplayW = Math.ceil(Math.sqrt(events.length));
        this.nbrDisplayH = Math.ceil(events.length / this.nbrDisplayW);
        nbrEventToDisplay = events.length;
      }
      if (this.highlightedTime === Infinity) {
        this.eventsToDisplay = events.splice(events.length - nbrEventToDisplay);
      } else {
        //find nearest event
        var nearestIndex = 0;
        var timeDiff = Infinity;
        var nextTimeDiff = 0;
        for (var i = 0; i < events.length; i++) {
          nextTimeDiff = Math.abs(events[i].time - this.highlightedTime);
          if (nextTimeDiff <= timeDiff) {
            timeDiff = nextTimeDiff;
            nearestIndex = i;
          } else {
            break;
          }
        }
        this.eventsToDisplay.push(events[nearestIndex]);
        var beforeIndex = nearestIndex - 1;
        var afterIndex = nearestIndex + 1;
        for (var j = 0; j < nbrEventToDisplay - 1; j++) {
          if (!events[beforeIndex]) {
            this.eventsToDisplay.push(events[afterIndex]);
            afterIndex++;
          } else if (!events[afterIndex]) {
            this.eventsToDisplay.unshift(events[beforeIndex]);
            beforeIndex--;
          } else if (this.highlightedTime - events[beforeIndex].time >
            events[afterIndex].time - this.highlightedTime) {
            this.eventsToDisplay.push(events[afterIndex]);
            afterIndex++;
          } else {
            this.eventsToDisplay.unshift(events[beforeIndex]);
            beforeIndex--;
          }
        }

      }
      /* DEBUG
      var times = [];
      var diff = [];
      var error = false;
      for (var k = 0; k < this.eventsToDisplay.length; k++) {
        times[k] = this.eventsToDisplay[k].time;
        if (times[k - 1] && times[k - 1] > times[k]) {
          error = true;
        }
        diff[k] = Math.abs(this.highlightedTime - this.eventsToDisplay[k].time);
      }
      if (error) {
        console.error('highlight', this.highlightedTime, 'times', times, 'diff', diff);
      } else {
        console.log('highlight', this.highlightedTime, 'times', times, 'diff', diff);
      }
      */
    },
    beforeRefreshModelView: function () {
      for (var i = 0; i < this.eventsToDisplay.length; ++i) {
        var denomW = i >= (this.nbrDisplayH - 1) * this.nbrDisplayW &&
          this.eventsToDisplay.length % this.nbrDisplayW !== 0 ?
          this.eventsToDisplay.length % this.nbrDisplayW:
          this.nbrDisplayW;

        var border = 0;
        var width = (100 - (border * (denomW - 1))) / denomW;
        var left = (Math.floor(i % this.nbrDisplayW)) * (width + border);
        var height = (100 - (border * (this.nbrDisplayH - 1))) / this.nbrDisplayH;
        var top = (Math.floor(i / this.nbrDisplayW)) * (height + border);
        this.eventsToDisplay[i].width = width * this.width / 100.0;
        this.eventsToDisplay[i].height = height * this.height / 100.0;
        this.eventsToDisplay[i].top = top * this.height / 100.0;
        this.eventsToDisplay[i].left = left * this.width / 100.0;
        this.eventsToDisplay[i].picUrl = this.eventsToDisplay[i]
            .getPicturePreview(width * this.width / 100.0, height * this.height / 100.0);
      }

      this.modelContent = {
        events: this.eventsToDisplay,
        eventsNbr: _.size(this.events),
        change: this.change
      };
      this.change = !this.change;
    }
  }
);
},{"../common/Model.js":146,"./View.js":179,"underscore":104}],179:[function(require,module,exports){
/* global $ */
var  Marionette = require('backbone.marionette'),
  _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  template: '#picturesView',
  container: null,
  animation: null,
  currentId: null,
  initialize: function () {
    this.listenTo(this.model, 'change', this.change);
    this.$el.css('height', '100%');
    this.$el.css('width', '100%');
    this.$el.addClass('animated node');

  },
  change: function () {
    if (!this.currentId || this.currentId !== this.model.get('id')) {
      $('#' + this.container).removeClass('animated ' + this.animation);
      this.animation = '';
      this.$el.attr('id', this.model.get('id'));
      this.currentId = this.model.get('id');
    } else {
      this.animation = null;
    }
    this.render();
  },
  renderView: function (container) {
    this.container = container;
    this.animation = 'bounceIn';
    this.currentId = this.model.get('id');
    this.render();
  },
  onRender: function () {
    if (this.container) {
      var $mosaics = $('#' + this.container + ' .mosaic');
      var events = this.model.get('events');
      var displayedIds  = [];
      _.each($mosaics, function (mosaic) {
        displayedIds.push($(mosaic).attr('id'));
      });
      _.each(events, function (event) {
        var index = displayedIds.indexOf(event.id);
        if (index !== -1) {
          $('#' + event.id).css({
            width: event.width,
            height: event.height,
            top: event.top,
            left: event.left
          });
          displayedIds[index] = null;
        } else {
          var toAdd = $('<div></div>').addClass('mosaic node').attr('id', event.id)
            .css({
              'background': 'url(' + event.picUrl + ') no-repeat center center',
              '-webkit-background-size': 'cover',
              '-moz-background-size': 'cover',
              '-o-background-size': 'cover',
              'background-size': 'cover',
              'width': event.width,
              'height': event.height,
              'top': event.top,
              'left': event.left,
              'position': 'absolute'
            });
          $('#' + this.container).append(toAdd.fadeIn());
        }
      }.bind(this));
      _.each(displayedIds, function (id) {
        if (id) {
          $('#' + id).remove();
        }
      });
      var $eventsNbr = $('#' + this.container + ' .aggregated-nbr-events');
      if ($eventsNbr.length === 0) {
        if (this.model.get('eventsNbr') > 1) {
          $('#' + this.container).append('<span class="aggregated-nbr-events">' +
          this.model.get('eventsNbr') + '</span>');
        }
        $('#' + this.container).bind('click', function () {
          this.trigger('nodeClicked');
        }.bind(this));
      } else {
        $eventsNbr.html(this.model.get('eventsNbr'));
      }




      $('#' + this.container).removeClass('animated fadeIn');

      if (this.animation) {
        $('#' + this.container).addClass('animated ' + this.animation);
        setTimeout(function () {
          $('#' + this.container).removeClass('animated ' + this.animation);
        }.bind(this), 1000);
      }
    }
  },
  close: function () {
    this.remove();
  }
});
},{"backbone.marionette":3,"underscore":104}],180:[function(require,module,exports){
var _ = require('underscore'),
  PositionsView = require('./View.js'),
  CommonModel = require('../common/Model.js');

module.exports = CommonModel.implement(
  function (events, params) {
    CommonModel.call(this, events, params);
    this.typeView = PositionsView;
    this.modelContent = {};
    this.positions = [];
  },

  {
    OnDateHighlightedChange: function (time) {
      this.highlightedTime = time;
      if (this.view) {
        this.view.onDateHighLighted(time);
      }
      if (this.detailedView) {
        this.detailedView.highlightDate(this.highlightedTime);
      }
    },

    _findEventToDisplay: function () {},

    beforeRefreshModelView: function () {
      // if (this.positions.length !== _.size(this.events)) {
      this.positions = [];
      _.each(this.events, function (event) {
        this.positions.push(event);
      }, this);
      this.positions = this.positions.sort(function (a, b) {
        return a.time <= b.time ? -1 : 1;
      });
      //  }
      this.modelContent = {
        positions: this.positions,
        posWidth: this.width,
        posHeight: this.height,
        id: this.id,
        eventsNbr: this.positions.length
      };
    }
  }
);
},{"../common/Model.js":146,"./View.js":181,"underscore":104}],181:[function(require,module,exports){
/* global document, $ */
var  Marionette = require('backbone.marionette'),
    MapLoader = require('google-maps'),
    _ = require('underscore'),
    MarkerClusterer = require('./utility/markerclusterer.js'),
    streamUtils = require('../../../utility/streamUtils');

module.exports = Marionette.ItemView.extend({
  template: '#positionsView',
  mapLoaded: false,
  mapOtions : {},
  bounds: null,
  paths: {},
  gmaps: null,
  map: null,
  container: null,
  markers: null,
  highlightedMarker: null,
  highlightedTime: Infinity,
  positions: null,
  highlightedPosition: null,

  initialize: function () {

    this.positions = this.model.get('positions');
    MapLoader.KEY = 'AIzaSyCWRjaX1-QcCqSK-UKfyR0aBpBwy6hYK5M';
    MapLoader.load().then(function (google) {
      this.gmaps = google.maps;
      if (this.waitingForInitMap) {
        this.waitingForInitMap = false;
        this._initMap();
      }
      if (this.waitingForDrawingMap) {
        this.waitingForDrawingMap = false;
        this._drawMap(document.getElementById('map-canvas-' + this.model.get('id')));
      }
    }.bind(this));

    this.listenTo(this.model, 'change:positions', this.changePos);
    this.listenTo(this.model, 'change:posWidth', this.resize);
    this.listenTo(this.model, 'change:posHeight', this.resize);
    this.$el.css('height', '100%');
    this.$el.css('width', '100%');
    this.$el.addClass('animated node');
  },
  resize: function () {
    if (this.map && this.bounds) {
      var timer = setInterval(function () {
        this.gmaps.event.trigger(this.map, 'resize');
      }.bind(this), 100);
      setTimeout(function () {
        clearInterval(timer);
        this.map.fitBounds(this.bounds);
        var listener = this.gmaps.event.addListener(this.map, 'idle', function () {
          if (this.map.getZoom() > 10) {
            this.map.setZoom(10);
          }
          this.gmaps.event.removeListener(listener);
        }.bind(this));
      }.bind(this), 1000);
    }
  },
  changePos: function () {
    this.positions = this.model.get('positions');
    this.model.set('eventsNbr', this.positions.length);
    this.render();
  },
  renderView: function (container) {
    this.container = container;
    this.render();
  },
  onBeforeRender: function () {
    this._initMap();
  },
  onRender: function () {
    if (this.container) {
      $('#' + this.container).append(this.el);
      $('#' + this.container).bind('click', function () {
        this.trigger('nodeClicked');
      }.bind(this));
    }
    this._drawMap(document.getElementById('map-canvas-' + this.model.get('id')));
  },
  _initMap: function () {
    if (!this.gmaps) {
      this.waitingForInitMap = true;
      return;
    }
    var geopoint;
    this.markers = [];
    this.paths = {};
    this.mapOptions =  {
      zoom: 10,
      zoomControl: false,
      mapTypeControl: false,
      scaleControl: false,
      streetViewControl: false,
      overviewMapControl: false,
      scrollwheel: true,
      mapTypeId: this.gmaps.MapTypeId.ROADMAP
    };
    _.each(this.positions, function (p) {
      geopoint = new this.gmaps.LatLng(p.content.latitude, p.content.longitude);
      this.markers.push(new this.gmaps.Marker({
        position: geopoint,
        visible: false
      }));
      if (!this.bounds) {
        this.bounds = new this.gmaps.LatLngBounds(geopoint, geopoint);
        this.mapOptions.center = geopoint;
      } else {
        this.bounds.extend(geopoint);
      }
      if (!this.paths[p.streamId]) {
        this.paths[p.streamId] = [];
        geopoint.pathColor = streamUtils.getColor(p.stream);
      }
      this.paths[p.streamId].push(geopoint);
    }, this);
  },
  _drawMap: function ($container) {
    if (!$container) {
      return;
    }
    if (!this.gmaps) {
      this.waitingForDrawingMap = true;
      return;
    }
    this.map = new this.gmaps.Map($container, this.mapOptions);
    this.gmaps.event.trigger(this.map, 'resize');
    this.map.fitBounds(this.bounds);
    var listener = this.gmaps.event.addListener(this.map, 'idle', function () {
      if (this.map.getZoom() > 10) {
        this.map.setZoom(10);
      }
      this.gmaps.event.removeListener(listener);
    }.bind(this));
    var gPath, gMarker;
    _.each(this.paths, function (path) {
      if (path.length > 1) {
        gPath = new this.gmaps.Polyline({
          path: path,
          strokeColor: path[0].pathColor,
          strokeOpacity: 1.0,
          strokeWeight: 6
        });
        gPath.setMap(this.map);
      } else {
        gMarker = new this.gmaps.Marker({
          position: path[0]
        });
        gMarker.setMap(this.map);
      }
    }, this);
    gMarker = new MarkerClusterer(this.map, this.markers);
  },
  onDateHighLighted : function (time) {
    this.highlightedTime = time;
    var positionToShow = null;

    var timeDiff = Infinity, temp = 0, highlightTime = this.highlightedTime;
    _.each(this.positions, function (position) {
      temp = Math.abs(position.time - highlightTime);
      if (temp <= timeDiff) {
        timeDiff = temp;
        positionToShow = position;
      }
    });
    if (this.highlightedPosition !== positionToShow) {
      if (this.highlightedMarker && this.map) {
        this.highlightedMarker.setMap(null);
      }

      var geopoint =  new this.gmaps.LatLng(positionToShow.content.latitude,
        positionToShow.content.longitude);
      this.highlightedMarker = new this.gmaps.Marker({
        position: geopoint
      });
      if (this.map) {
        this.highlightedMarker.setMap(this.map);
        this.map.panTo(geopoint);
      }
      this.highlightedPosition = positionToShow;
    }
    return positionToShow;
  },
  close: function () {
    this.remove();
  }
});

},{"../../../utility/streamUtils":135,"./utility/markerclusterer.js":182,"backbone.marionette":3,"google-maps":14,"underscore":104}],182:[function(require,module,exports){
/* global window, google, document */
/*jshint -W084 */
/*jshint -W089 */
/**
 * @name MarkerClusterer for Google Maps v3
 * @version version 1.0.1
 * @author Luke Mahe
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of
 * markers.
 * <br/>
 * This is a v3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >v2 MarkerClusterer</a>.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A Marker Clusterer that clusters markers.
 *
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
 *   the cluster.
 * @param {Object=} opt_options support the following options:
 *     'gridSize': (number) The grid size of a cluster in pixels.
 *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
 *                cluster.
 *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
 *                    cluster is to zoom into it.
 *     'averageCenter': (boolean) Wether the center of each cluster should be
 *                      the average of all markers in the cluster.
 *     'minimumClusterSize': (number) The minimum number of markers to be in a
 *                           cluster before the markers are hidden and a count
 *                           is shown.
 *     'styles': (object) An object that has style properties:
 *       'url': (string) The image url.
 *       'height': (number) The image height.
 *       'width': (number) The image width.
 *       'anchor': (Array) The anchor position of the label text.
 *       'textColor': (string) The text color.
 *       'textSize': (number) The text size.
 *       'backgroundPosition': (string) The position of the backgound x, y.
 * @constructor
 * @extends google.maps.OverlayView
 */
var MarkerClusterer = module.exports = function (map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);
  this.map_ = map;

  /**
   * @type {Array.<google.maps.Marker>}
   * @private
   */
  this.markers_ = [];

  /**
   *  @type {Array.<Cluster>}
   */
  this.clusters_ = [];

  this.sizes = [53, 56, 66, 78, 90];

  /**
   * @private
   */
  this.styles_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.ready_ = false;

  var options = opt_options || {};

  /**
   * @type {number}
   * @private
   */
  this.gridSize_ = options.gridSize || 60;

  /**
   * @private
   */
  this.minClusterSize_ = options.minimumClusterSize || 2;


  /**
   * @type {?number}
   * @private
   */
  this.maxZoom_ = options.maxZoom || null;

  this.styles_ = options.styles || [];

  /**
   * @type {string}
   * @private
   */
  this.imagePath_ = options.imagePath ||
    this.MARKER_CLUSTER_IMAGE_PATH_;

  /**
   * @type {string}
   * @private
   */
  this.imageExtension_ = options.imageExtension ||
    this.MARKER_CLUSTER_IMAGE_EXTENSION_;

  /**
   * @type {boolean}
   * @private
   */
  this.zoomOnClick_ = true;

  if (options.zoomOnClick !== undefined) {
    this.zoomOnClick_ = options.zoomOnClick;
  }

  /**
   * @type {boolean}
   * @private
   */
  this.averageCenter_ = false;

  if (options.averageCenter !== undefined) {
    this.averageCenter_ = options.averageCenter;
  }

  this.setupStyles_();

  this.setMap(map);

  /**
   * @type {number}
   * @private
   */
  this.prevZoom_ = this.map_.getZoom();

  // Add the map event listeners
  var that = this;
  google.maps.event.addListener(this.map_, 'zoom_changed', function () {
    // Determines map type and prevent illegal zoom levels
    var zoom = that.map_.getZoom();
    var minZoom = that.map_.minZoom || 0;
    var maxZoom = Math.min(that.map_.maxZoom || 100,
      that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);
    zoom = Math.min(Math.max(zoom, minZoom), maxZoom);

    if (that.prevZoom_ !== zoom) {
      that.prevZoom_ = zoom;
      that.resetViewport();
    }
  });

  google.maps.event.addListener(this.map_, 'idle', function () {
    that.redraw();
  });

  // Finally, add the markers
  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {
    this.addMarkers(opt_markers, false);
  }
};


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =
  'https://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +
    'images/m';


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';


/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function (obj1, obj2) {
  return (function (object) {
    for (var property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function () {
  this.setReady_(true);
};

/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function () {};

/**
 * Sets up the styles object.
 *
 * @private
 */
MarkerClusterer.prototype.setupStyles_ = function () {
  if (this.styles_.length) {
    return;
  }

  for (var i = 0, size; size = this.sizes[i]; i++) {
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
      height: size,
      width: size
    });
  }
};

/**
 *  Fit the map to the bounds of the markers in the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function () {
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }

  this.map_.fitBounds(bounds);
};


/**
 *  Sets the styles.
 *
 *  @param {Object} styles The style to set.
 */
MarkerClusterer.prototype.setStyles = function (styles) {
  this.styles_ = styles;
};


/**
 *  Gets the styles.
 *
 *  @return {Object} The styles object.
 */
MarkerClusterer.prototype.getStyles = function () {
  return this.styles_;
};


/**
 * Whether zoom on click is set.
 *
 * @return {boolean} True if zoomOnClick_ is set.
 */
MarkerClusterer.prototype.isZoomOnClick = function () {
  return this.zoomOnClick_;
};

/**
 * Whether average center is set.
 *
 * @return {boolean} True if averageCenter_ is set.
 */
MarkerClusterer.prototype.isAverageCenter = function () {
  return this.averageCenter_;
};


/**
 *  Returns the array of markers in the clusterer.
 *
 *  @return {Array.<google.maps.Marker>} The markers.
 */
MarkerClusterer.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 *  Returns the number of markers in the clusterer
 *
 *  @return {Number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function () {
  return this.markers_.length;
};


/**
 *  Sets the max zoom for the clusterer.
 *
 *  @param {number} maxZoom The max zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function (maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Gets the max zoom for the clusterer.
 *
 *  @return {number} The max zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function () {
  return this.maxZoom_;
};


/**
 *  The function for calculating the cluster icon image.
 *
 *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
 *  @param {number} numStyles The number of styles available.
 *  @return {Object} A object properties: 'text' (string) and 'index' (number).
 *  @private
 */
MarkerClusterer.prototype.calculator_ = function (markers, numStyles) {
  var index = 0;
  var count = markers.length;
  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index
  };
};


/**
 * Set the calculator function.
 *
 * @param {function (Array, number)} calculator The function to set as the
 *     calculator. The function should return a object properties:
 *     'text' (string) and 'index' (number).
 *
 */
MarkerClusterer.prototype.setCalculator = function (calculator) {
  this.calculator_ = calculator;
};


/**
 * Get the calculator function.
 *
 * @return {function (Array, number)} the calculator function.
 */
MarkerClusterer.prototype.getCalculator = function () {
  return this.calculator_;
};


/**
 * Add an array of markers to the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {
  var marker;
  if (markers.length) {
    for (var i = 0; marker = markers[i]; i++) {
      this.pushMarkerTo_(marker);
    }
  } else if (Object.keys(markers).length) {
    for (marker in markers) {
      this.pushMarkerTo_(markers[marker]);
    }
  }
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.pushMarkerTo_ = function (marker) {
  marker.isAdded = false;
  if (marker.draggable) {
    // If the marker is draggable add a listener so we update the clusters on
    // the drag end.
    var that = this;
    google.maps.event.addListener(marker, 'dragend', function () {
      marker.isAdded = false;
      that.repaint();
    });
  }
  this.markers_.push(marker);
};


/**
 * Adds a marker to the clusterer and redraws if needed.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Removes a marker and returns true if removed, false if not
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 * @private
 */
MarkerClusterer.prototype.removeMarker_ = function (marker) {
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m === marker) {
        index = i;
        break;
      }
    }
  }

  if (index === -1) {
    // Marker is not in our list of markers.
    return false;
  }

  marker.setMap(null);

  this.markers_.splice(index, 1);

  return true;
};


/**
 * Remove a marker from the cluster.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 * @return {boolean} True if the marker was removed.
 */
MarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  } else {
    return false;
  }
};


/**
 * Removes an array of markers from the cluster.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 */
MarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {
  var removed = false;

  for (var i = 0, marker; marker = markers[i]; i++) {
    var r = this.removeMarker_(marker);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  }
};


/**
 * Sets the clusterer's ready state.
 *
 * @param {boolean} ready The state.
 * @private
 */
MarkerClusterer.prototype.setReady_ = function (ready) {
  if (!this.ready_) {
    this.ready_ = ready;
    this.createClusters_();
  }
};


/**
 * Returns the number of clusters in the clusterer.
 *
 * @return {number} The number of clusters.
 */
MarkerClusterer.prototype.getTotalClusters = function () {
  return this.clusters_.length;
};


/**
 * Returns the google map that the clusterer is associated with.
 *
 * @return {google.maps.Map} The map.
 */
MarkerClusterer.prototype.getMap = function () {
  return this.map_;
};


/**
 * Sets the google map that the clusterer is associated with.
 *
 * @param {google.maps.Map} map The map.
 */
MarkerClusterer.prototype.setMap = function (map) {
  this.map_ = map;
};


/**
 * Returns the size of the grid.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function () {
  return this.gridSize_;
};


/**
 * Sets the size of the grid.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setGridSize = function (size) {
  this.gridSize_ = size;
};


/**
 * Returns the min cluster size.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getMinClusterSize = function () {
  return this.minClusterSize_;
};

/**
 * Sets the min cluster size.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setMinClusterSize = function (size) {
  this.minClusterSize_ = size;
};


/**
 * Extends a bounds object by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 */
MarkerClusterer.prototype.getExtendedBounds = function (bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
    bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
    bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Determins if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 * @private
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Clears all clusters and markers from the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function () {
  this.resetViewport(true);

  // Set the markers a empty array.
  this.markers_ = [];
};


/**
 * Clears all existing clusters and recreates them.
 * @param {boolean} opt_hide To also hide the marker.
 */
MarkerClusterer.prototype.resetViewport = function (opt_hide) {
  // Remove all the clusters
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    cluster.remove();
  }

  // Reset the markers to not be added and to be invisible.
  for (var j = 0, marker; marker = this.markers_[j]; j++) {
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }

  this.clusters_ = [];
};

/**
 *
 */
MarkerClusterer.prototype.repaint = function () {
  var oldClusters = this.clusters_.slice();
  this.clusters_.length = 0;
  this.resetViewport();
  this.redraw();

  // Remove the old clusters.
  // Do it in a timeout so the other clusters have been drawn first.
  window.setTimeout(function () {
    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
      cluster.remove();
    }
  }, 0);
};


/**
 * Redraws the clusters.
 */
MarkerClusterer.prototype.redraw = function () {
  this.createClusters_();
};


/**
 * Calculates the distance between two latlng locations in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @private
 */
MarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {
  if (!p1 || !p2) {
    return 0;
  }

  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Add a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.addToClosestCluster_ = function (marker) {
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  //var pos = marker.getPosition();
  var cluster;
  for (var i = 0; cluster = this.clusters_[i]; i++) {
    var center = cluster.getCenter();
    if (center) {
      var d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters.
 *
 * @private
 */
MarkerClusterer.prototype.createClusters_ = function () {
  if (!this.ready_) {
    return;
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
    this.map_.getBounds().getNorthEast());
  var bounds = this.getExtendedBounds(mapBounds);

  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      this.addToClosestCluster_(marker);
    }
  }
};


/**
 * A cluster that contains markers.
 *
 * @param {MarkerClusterer} markerClusterer The markerclusterer that this
 *     cluster is associated with.
 * @constructor
 * @ignore
 */
function Cluster(markerClusterer) {
  this.markerClusterer_ = markerClusterer;
  this.map_ = markerClusterer.getMap();
  this.gridSize_ = markerClusterer.getGridSize();
  this.minClusterSize_ = markerClusterer.getMinClusterSize();
  this.averageCenter_ = markerClusterer.isAverageCenter();
  this.center_ = null;
  this.markers_ = [];
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
    markerClusterer.getGridSize());
}

/**
 * Determins if a marker is already added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker is already added.
 */
Cluster.prototype.isMarkerAlreadyAdded = function (marker) {
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) !== -1;
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m === marker) {
        return true;
      }
    }
  }
  return false;
};


/**
 * Add a marker the cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @return {boolean} True if the marker was added.
 */
Cluster.prototype.addMarker = function (marker) {
  if (this.isMarkerAlreadyAdded(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  var len = this.markers_.length;
  if (len < this.minClusterSize_ && marker.getMap() !== this.map_) {
    // Min cluster size not reached so show the marker.
    marker.setMap(this.map_);
  }

  if (len === this.minClusterSize_) {
    // Hide the markers that were showing.
    for (var i = 0; i < len; i++) {
      this.markers_[i].setMap(null);
    }
  }

  if (len >= this.minClusterSize_) {
    marker.setMap(null);
  }

  this.updateIcon();
  return true;
};


/**
 * Returns the marker clusterer that the cluster is associated with.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 */
Cluster.prototype.getMarkerClusterer = function () {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 */
Cluster.prototype.getBounds = function () {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster
 */
Cluster.prototype.remove = function () {
  this.clusterIcon_.remove();
  this.markers_.length = 0;
  delete this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {number} The cluster center.
 */
Cluster.prototype.getSize = function () {
  return this.markers_.length;
};


/**
 * Returns the center of the cluster.
 *
 * @return {Array.<google.maps.Marker>} The cluster center.
 */
Cluster.prototype.getMarkers = function () {
  return this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {google.maps.LatLng} The cluster center.
 */
Cluster.prototype.getCenter = function () {
  return this.center_;
};


/**
 * Calculated the extended bounds of the cluster with the grid.
 *
 * @private
 */
Cluster.prototype.calculateBounds_ = function () {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Determines if a marker lies in the clusters bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 */
Cluster.prototype.isMarkerInClusterBounds = function (marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Returns the map that the cluster is associated with.
 *
 * @return {google.maps.Map} The map.
 */
Cluster.prototype.getMap = function () {
  return this.map_;
};


/**
 * Updates the cluster icon
 */
Cluster.prototype.updateIcon = function () {
  var zoom = this.map_.getZoom();
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz && zoom > mz) {
    // The zoom is greater than our max zoom so show all the markers in cluster.
    for (var i = 0, marker; marker = this.markers_[i]; i++) {
      marker.setMap(this.map_);
    }
    return;
  }

  if (this.markers_.length < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.setSums(sums);
  this.clusterIcon_.show();
};


/**
 * A cluster icon
 *
 * @param {Cluster} cluster The cluster to be associated with.
 * @param {Object} styles An object that has style properties:
 *     'url': (string) The image url.
 *     'height': (number) The image height.
 *     'width': (number) The image width.
 *     'anchor': (Array) The anchor position of the label text.
 *     'textColor': (string) The text color.
 *     'textSize': (number) The text size.
 *     'backgroundPosition: (string) The background postition x, y.
 * @param {number=} opt_padding Optional padding to apply to the cluster icon.
 * @constructor
 * @extends google.maps.OverlayView
 * @ignore
 */
function ClusterIcon(cluster, styles, opt_padding) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.styles_ = styles;
  this.padding_ = opt_padding || 0;
  this.cluster_ = cluster;
  this.center_ = null;
  this.map_ = cluster.getMap();
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(this.map_);
}


/**
 * Triggers the clusterclick event and zoom's if the option is set.
 */
ClusterIcon.prototype.triggerClusterClick = function () {
  var markerClusterer = this.cluster_.getMarkerClusterer();

  // Trigger the clusterclick event.
  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);

  if (markerClusterer.isZoomOnClick()) {
    // Zoom into the cluster.
    this.map_.fitBounds(this.cluster_.getBounds());
  }
};


/**
 * Adding the cluster icon to the dom.
 * @ignore
 */
ClusterIcon.prototype.onAdd = function () {
  this.div_ = document.createElement('DIV');
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.innerHTML = this.sums_.text;
  }

  var panes = this.getPanes();
  panes.overlayMouseTarget.appendChild(this.div_);

  var that = this;
  google.maps.event.addDomListener(this.div_, 'click', function () {
    that.triggerClusterClick();
  });
};


/**
 * Returns the position to place the div dending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 * @private
 */
ClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= parseInt(this.width_ / 2, 10);
  pos.y -= parseInt(this.height_ / 2, 10);
  return pos;
};


/**
 * Draw the icon.
 * @ignore
 */
ClusterIcon.prototype.draw = function () {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + 'px';
    this.div_.style.left = pos.x + 'px';
  }
};


/**
 * Hide the icon.
 */
ClusterIcon.prototype.hide = function () {
  if (this.div_) {
    this.div_.style.display = 'none';
  }
  this.visible_ = false;
};


/**
 * Position and show the icon.
 */
ClusterIcon.prototype.show = function () {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.style.display = '';
  }
  this.visible_ = true;
};


/**
 * Remove the icon from the map
 */
ClusterIcon.prototype.remove = function () {
  this.setMap(null);
};


/**
 * Implementation of the onRemove interface.
 * @ignore
 */
ClusterIcon.prototype.onRemove = function () {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Set the sums of the icon.
 *
 * @param {Object} sums The sums containing:
 *   'text': (string) The text to display in the icon.
 *   'index': (number) The style index of the icon.
 */
ClusterIcon.prototype.setSums = function (sums) {
  this.sums_ = sums;
  this.text_ = sums.text;
  this.index_ = sums.index;
  if (this.div_) {
    this.div_.innerHTML = sums.text;
  }

  this.useStyle();
};


/**
 * Sets the icon to the the styles.
 */
ClusterIcon.prototype.useStyle = function () {
  var index = Math.max(0, this.sums_.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style.url;
  this.height_ = style.height;
  this.width_ = style.width;
  this.textColor_ = style.textColor;
  this.anchor_ = style.anchor;
  this.textSize_ = style.textSize;
  this.backgroundPosition_ = style.backgroundPosition;
};


/**
 * Sets the center of the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function (center) {
  this.center_ = center;
};


/**
 * Create the css text based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position.
 * @return {string} The css style text.
 */
ClusterIcon.prototype.createCss = function (pos) {
  var style = [];
  style.push('background-image:url(' + this.url_ + ');');
  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
  style.push('background-position:' + backgroundPosition + ';');

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
      this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
        'px; padding-top:' + this.anchor_[0] + 'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
        'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
      this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
        'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
      this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  var txtColor = this.textColor_ ? this.textColor_ : 'black';
  var txtSize = this.textSize_ ? this.textSize_ : 11;

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
    pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
    txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');
  return style.join('');
};


// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
window.MarkerClusterer = MarkerClusterer;
MarkerClusterer.prototype.addMarker = MarkerClusterer.prototype.addMarker;
MarkerClusterer.prototype.addMarkers = MarkerClusterer.prototype.addMarkers;
MarkerClusterer.prototype.clearMarkers =
  MarkerClusterer.prototype.clearMarkers;
MarkerClusterer.prototype.fitMapToMarkers =
  MarkerClusterer.prototype.fitMapToMarkers;
MarkerClusterer.prototype.getCalculator =
  MarkerClusterer.prototype.getCalculator;
MarkerClusterer.prototype.getGridSize =
  MarkerClusterer.prototype.getGridSize;
MarkerClusterer.prototype.getExtendedBounds =
  MarkerClusterer.prototype.getExtendedBounds;
MarkerClusterer.prototype.getMap = MarkerClusterer.prototype.getMap;
MarkerClusterer.prototype.getMarkers = MarkerClusterer.prototype.getMarkers;
MarkerClusterer.prototype.getMaxZoom = MarkerClusterer.prototype.getMaxZoom;
MarkerClusterer.prototype.getStyles = MarkerClusterer.prototype.getStyles;
MarkerClusterer.prototype.getTotalClusters =
  MarkerClusterer.prototype.getTotalClusters;
MarkerClusterer.prototype.getTotalMarkers =
  MarkerClusterer.prototype.getTotalMarkers;
MarkerClusterer.prototype.redraw = MarkerClusterer.prototype.redraw;
MarkerClusterer.prototype.removeMarker =
  MarkerClusterer.prototype.removeMarker;
MarkerClusterer.prototype.removeMarkers =
  MarkerClusterer.prototype.removeMarkers;
MarkerClusterer.prototype.resetViewport =
  MarkerClusterer.prototype.resetViewport;
MarkerClusterer.prototype.repaint =
  MarkerClusterer.prototype.repaint;
MarkerClusterer.prototype.setCalculator =
  MarkerClusterer.prototype.setCalculator;
MarkerClusterer.prototype.setGridSize =
  MarkerClusterer.prototype.setGridSize;
MarkerClusterer.prototype.setMaxZoom =
  MarkerClusterer.prototype.setMaxZoom;
MarkerClusterer.prototype.onAdd = MarkerClusterer.prototype.onAdd;
MarkerClusterer.prototype.draw = MarkerClusterer.prototype.draw;

Cluster.prototype.getCenter = Cluster.prototype.getCenter;
Cluster.prototype.getSize = Cluster.prototype.getSize;
Cluster.prototype.getMarkers = Cluster.prototype.getMarkers;

ClusterIcon.prototype.onAdd = ClusterIcon.prototype.onAdd;
ClusterIcon.prototype.draw = ClusterIcon.prototype.draw;
ClusterIcon.prototype.onRemove = ClusterIcon.prototype.onRemove;

Object.keys = Object.keys || function (o) {
  var result = [];
  for (var name in o) {
    if (o.hasOwnProperty(name)) {
      result.push(name);
    }
  }
  return result;
};

},{}],183:[function(require,module,exports){
var _ = require('underscore'),
  TweetsView = require('./View.js'),
  CommonModel = require('../common/Model.js');
var minWidth = 300;
var minHeight = 200;
var maxWidth = 300;
var maxHeight = 200;
module.exports = CommonModel.implement(
  function (events, params) {
    CommonModel.call(this, events, params);
    this.typeView = TweetsView;
    this.eventDisplayed = null;
    this.modelContent = {};
    this.nbrDisplayW = -1;
    this.nbrDisplayH = -1;
    this.change = false;
  },

  {
    _howManyEventsCanBeDisplayed: function () {
      if (this.width < minWidth || this.height < minHeight) {
        this.nbrDisplayW = 1;
        this.nbrDisplayH = 1;
      }
      if (Math.ceil(this.width / maxWidth) !== this.nbrDisplayW ||
        Math.ceil(this.height / maxHeight) !== this.nbrDisplayH) {
        this.nbrDisplayW = Math.ceil(this.width / maxWidth);
        this.nbrDisplayH = Math.ceil(this.height / maxHeight);
      }
    },
    _findEventToDisplay: function () {
      this._howManyEventsCanBeDisplayed();
      this.eventsToDisplay = [];
      // sort events oldest first, latest last
      var events = _.sortBy(_.toArray(this.events), function (event) {
        return event.time;
      });
      var nbrEventToDisplay = this.nbrDisplayW * this.nbrDisplayH;
      if (events.length < nbrEventToDisplay) {
        this.nbrDisplayW = Math.ceil(Math.sqrt(events.length));
        this.nbrDisplayH = Math.ceil(events.length / this.nbrDisplayW);
        nbrEventToDisplay = events.length;
      }
      if (this.highlightedTime === Infinity) {
        this.eventsToDisplay = events.splice(events.length - nbrEventToDisplay);
      } else {
        //find nearest event
        var nearestIndex = 0;
        var timeDiff = Infinity;
        var nextTimeDiff = 0;
        for (var i = 0; i < events.length; i++) {
          nextTimeDiff = Math.abs(events[i].time - this.highlightedTime);
          if (nextTimeDiff <= timeDiff) {
            timeDiff = nextTimeDiff;
            nearestIndex = i;
          } else {
            break;
          }
        }
        this.eventsToDisplay.push(events[nearestIndex]);
        var beforeIndex = nearestIndex - 1;
        var afterIndex = nearestIndex + 1;
        for (var j = 0; j < nbrEventToDisplay - 1; j++) {
          if (!events[beforeIndex]) {
            this.eventsToDisplay.push(events[afterIndex]);
            afterIndex++;
          } else if (!events[afterIndex]) {
            this.eventsToDisplay.unshift(events[beforeIndex]);
            beforeIndex--;
          } else if (this.highlightedTime - events[beforeIndex].time >
            events[afterIndex].time - this.highlightedTime) {
            this.eventsToDisplay.push(events[afterIndex]);
            afterIndex++;
          } else {
            this.eventsToDisplay.unshift(events[beforeIndex]);
            beforeIndex--;
          }
        }

      }
    },
    beforeRefreshModelView: function () {
      for (var i = 0; i < this.eventsToDisplay.length; ++i) {
        var denomW = i >= (this.nbrDisplayH - 1) * this.nbrDisplayW &&
          this.eventsToDisplay.length % this.nbrDisplayW !== 0 ?
          this.eventsToDisplay.length % this.nbrDisplayW:
          this.nbrDisplayW;

        var border = 0;
        var width = (100 - (border * (denomW - 1))) / denomW;
        var left = (Math.floor(i % this.nbrDisplayW)) * (width + border);
        var height = (100 - (border * (this.nbrDisplayH - 1))) / this.nbrDisplayH;
        var top = (Math.floor(i / this.nbrDisplayW)) * (height + border);
        this.eventsToDisplay[i].width = width * this.width / 100.0;
        this.eventsToDisplay[i].height = height * this.height / 100.0;
        this.eventsToDisplay[i].top = top * this.height / 100.0;
        this.eventsToDisplay[i].left = left * this.width / 100.0;
      }

      this.modelContent = {
        events: this.eventsToDisplay,
        eventsNbr: _.size(this.events),
        change: this.change
      };
      this.change = !this.change;
    }
  }
);
},{"../common/Model.js":146,"./View.js":184,"underscore":104}],184:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
    dateTime = require('../../../utility/dateTime'),
    _ = require('underscore');

var getUrl =  function (event) {
  var id = event.content.id,
      screenName = event.content['screen-name'],
      date = new Date(event.time * 1000);
  return '<a href="https://twitter.com/' + screenName + '/status/' + id + '"' +
      'data-datetime="' + date.toISOString() + '">' +
      dateTime.getTimeText(event.time) + '</a>';
};
module.exports = Marionette.ItemView.extend({
  template: '#picturesView',
  container: null,
  animation: null,
  currentId: null,
  initialize: function () {
    this.listenTo(this.model, 'change', this.change);
    this.$el.css('height', '100%');
    this.$el.css('width', '100%');
    this.$el.addClass('animated node');

  },
  change: function () {
    if (!this.currentId || this.currentId !== this.model.get('id')) {
      $('#' + this.container).removeClass('animated ' + this.animation);
      this.animation = '';
      this.$el.attr('id', this.model.get('id'));
      this.currentId = this.model.get('id');
    } else {
      this.animation = null;
    }
    this.render();
  },
  renderView: function (container) {
    this.container = container;
    this.animation = 'bounceIn';
    this.currentId = this.model.get('id');
    this.render();
  },
  onRender: function () {
    if (this.container) {
      var $mosaics = $('#' + this.container + ' .mosaic');
      var events = this.model.get('events');
      var displayedIds  = [];
      _.each($mosaics, function (mosaic) {
        displayedIds.push($(mosaic).attr('id'));
      });
      _.each(events, function (event) {
        var index = displayedIds.indexOf(event.id);
        if (index !== -1) {
          $('#' + event.id).css({
            width: event.width,
            height: event.height,
            top: event.top,
            left: event.left
          }).find('.Center-Block').html('<div class="tweet" >' +
                  '<p>' + event.content.text + '</p><p>&mdash;' +
                  '@' + event.content['screen-name'] + '</p><p>' + getUrl(event) +
                  '</p></div>');

          displayedIds[index] = null;
        } else {

          var toAdd = $('<div></div>')
            .addClass('mosaic node content Center-Container is-Table').attr('id', event.id)
            .append(
              '<div class="Table-Cell">' +
              '<div class="Center-Block">' +
              '<div class="tweet" >' +
              '<p>' + event.content.text + '</p><p>&mdash;' +
              '@' + event.content['screen-name'] + '</p><p>' + getUrl(event) +
              '</p></div>' +
              '</div>' +
              '</div>')
            .css({
              'width': event.width,
              'height': event.height,
              'top': event.top,
              'left': event.left,
              'position': 'absolute'
            });
          $('#' + this.container).append(toAdd.fadeIn());
          setTimeout(function () {
            $('#' + event.id).dotdotdot({watch: true});
          }, 800);
        }
      }.bind(this));
      _.each(displayedIds, function (id) {
        if (id) {
          $('#' + id).remove();
        }
      });
      var $eventsNbr = $('#' + this.container + ' .aggregated-nbr-events');
      if ($eventsNbr.length === 0) {
        if (this.model.get('eventsNbr') > 1) {
          $('#' + this.container).append('<span class="aggregated-nbr-events">' +
              this.model.get('eventsNbr') + '</span>');
        }
        $('#' + this.container).bind('click', function () {
          this.trigger('nodeClicked');
        }.bind(this));
      } else {
        $eventsNbr.html(this.model.get('eventsNbr'));
      }




      $('#' + this.container).removeClass('animated fadeIn');

      if (this.animation) {
        $('#' + this.container).addClass('animated ' + this.animation);
        setTimeout(function () {
          $('#' + this.container).removeClass('animated ' + this.animation);
        }.bind(this), 1000);
      }
    }
  },
  close: function () {
    this.remove();
  }
});

},{"../../../utility/dateTime":133,"backbone.marionette":3,"underscore":104}],185:[function(require,module,exports){

var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({
  template: '#actions-template'
});
},{"backbone.marionette":3}],186:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
  FilterByStreamView = require('./FilterByStream.js'),
  ActionsView = require('./Actions.js'),
  _ = require('underscore');

var Layout = Marionette.Layout.extend({
  template: '#left-panel-template',

  regions: {
    filterByStream: '#filter-by-stream',
    actions: '#actions'
  },
  initialize: function () {
    this.$el =  $('.menu-panel');
  }
});
var Controller = module.exports  = {};

var view = null,
  filterByStreamView = null,
  actionsView = null,
  connectionsNumber = {
    logged: 0,
    sharings: 0,
    bookmarks: 0,
    public: 0
  };
Controller.render = function (MainModel) {
  if (!view || !filterByStreamView) {
    if (!view) {
      view = new Layout();
      view.render();
      actionsView = new ActionsView();
      view.actions.show(actionsView);
    }
    if (!filterByStreamView) {
      filterByStreamView = new FilterByStreamView({MainModel: MainModel});
      view.filterByStream.show(filterByStreamView);
    }
  } else if (view && filterByStreamView && isConnectionsNumberChange(MainModel)) {
    /*view.render();
    view.actions.show(actionsView);*/
    view.filterByStream.show(filterByStreamView);
  } else if (view && filterByStreamView) {
    if (!filterByStreamView.onFocusStreamChanged()) {
      view.filterByStream.show(filterByStreamView);
    }
  }



};

var isConnectionsNumberChange = function (MainModel) {
  // hack: need to have an onStream change and onConnection change;
  var logged = 0;
  if (MainModel.loggedConnection && MainModel.loggedConnection.datastore) {
    logged = _.size(MainModel.loggedConnection.datastore.getStreams());
  }
  var pub = 0;
  if (MainModel.publicConnection && MainModel.publicConnection.datastore) {
    pub = _.size(MainModel.publicConnection.datastore.getStreams());
  }
  var sharings = 0;
  _.each(MainModel.sharingsConnections, function (connection) {
    if (connection.datastore) {
      sharings += _.size(connection.datastore.getStreams());
    }
  });
  var bookmarks = 0;
  _.each(MainModel.bookmakrsConnections, function (connection) {
    if (connection.datastore) {
      bookmarks += _.size(connection.datastore.getStreams());
    }
  });
  var res = !(connectionsNumber.logged === logged &&
    connectionsNumber.public === pub &&
    connectionsNumber.sharings === sharings &&
    connectionsNumber.bookmarks === bookmarks
    );
  connectionsNumber.logged = logged;
  connectionsNumber.public = pub;
  connectionsNumber.sharings = sharings;
  connectionsNumber.bookmarks = bookmarks;
  return res;
};

},{"./Actions.js":185,"./FilterByStream.js":187,"backbone.marionette":3,"underscore":104}],187:[function(require,module,exports){
/*global $ */
var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  UNIQUE_ID = 0;

module.exports = Marionette.ItemView.extend({
  template: '#filter-by-stream-template',
  templateHelpers: function () {
    return {
      getStream: function () {
        return this._getStream();
      }.bind(this)
    };
  },
  ui: {
    label: 'label',
    checkbox: 'input[type=checkbox]',
    streamConfig: '.streamConfig',
    applyBtn: '#filter-by-stream-apply'
  },
  shushListenerOnce: false, //used to note trigger the render when we click on a checkbox
  initialize: function (options) {
    this.MainModel  = options.MainModel;
    var initListener = setInterval(function () {
      if (this.MainModel.activeFilter) {
        clearInterval(initListener);
        this.MainModel.activeFilter.addEventListener('filteredStreamsChange', function () {
          if (!this.shushListenerOnce) {
            this.render();
          } else {
            this.shushListenerOnce = false;
          }
        }.bind(this));
        this.MainModel.activeFilter.addEventListener('streamEnterScope', function () {
          if (!this.shushListenerOnce) {
            this.render();
          } else {
            this.shushListenerOnce = false;
          }
        }.bind(this));
        this.MainModel.activeFilter.addEventListener('streamLeaveScope', function () {
          if (!this.shushListenerOnce) {
            this.render();
          } else {
            this.shushListenerOnce = false;
          }
        }.bind(this));
      }
    }.bind(this), 100);
  },
  onRender: function () {
    if (!this.MainModel.activeFilter) {
      return;
    }
    var self = this;
    self.ui.applyBtn.prop('disabled', true);
    self.ui.applyBtn.click(this._applyFilter.bind(this));
    self.ui.streamConfig.click(function (e) {
      e.stopPropagation();
      var $parent = $($(e.currentTarget).parent().parent());
      var connId = $parent.attr('data-connection');
      var streamId = $parent.attr('data-stream');

      var conn = this.MainModel.connections.get(connId);
      if (conn) {
        var stream = conn.datastore.getStreamById(streamId);
        if (stream) {
          this.MainModel.treemap.closeViews();
          var $modal =  $('#pryv-modal').on('hidden.bs.modal', function () {
            this.MainModel.treemap.closeStreamView();
          }.bind(this));
          this.MainModel.treemap.showStreamView($modal, stream, self.$el);
        }
      }
    }.bind(this));
    this.ui.label.click(function (e) {
      e.stopPropagation();
      var input = $($(e.currentTarget).parent()).find('input');
      var checked = input.prop('checked');
      input.prop({
        indeterminate: false,
        checked: !checked
      });
      input.trigger('change');
      this.shushListenerOnce = true;
      this._applyFilter();
    }.bind(this));
    this.ui.checkbox.click(function (e) {
      e.stopPropagation();
    });
    this.ui.checkbox.change(function (e, options) {
      var checked = $(e.currentTarget).prop('checked'),
        container = $($(e.currentTarget).parent().parent().attr('data-target'), self.$el);
      self.ui.applyBtn.prop('disabled', false);
      container.find('input[type="checkbox"]').prop({
        indeterminate: false,
        checked: checked
      });
      if (!options || !options.noIndeterminate) {
        self._isChildrenCheck(container.parent().parent());
      }
    });
    this.bindUIElements();
    this.onFocusStreamChanged();
    setTimeout(function () {$('body').i18n(); }, 100);
  },
  onFocusStreamChanged: function () {
    var focusedStreams = this.MainModel.activeFilter.getStreams();
    var focusedStreamsIds = [];
    try {
      this.ui.checkbox.prop({
        indeterminate: false,
        checked: false
      });
    } catch (e) {
      return false;
    }

    _.each(focusedStreams, function (stream) {
      focusedStreamsIds.push(stream.connection.serialId + '/' + stream.id);
    });
    var $parent, c, s;
    _.each(this.ui.checkbox, function (checkbox) {
      checkbox = $(checkbox);
      $parent = $(checkbox.parent().parent());
      if ($parent && $parent.attr('data-connection') && $parent.attr('data-stream')) {
        c = this.MainModel.connections.get($parent.attr('data-connection'));
        if (c) {
          s = c.datastore.getStreamById($parent.attr('data-stream'));
          if (s) {
            if (focusedStreamsIds.indexOf(c.serialId + '/' + s.id) !== -1 ||
              focusedStreamsIds.length === 0) {
              checkbox.prop({
                indeterminate: false,
                checked: true
              });
              checkbox.trigger('change', {noIndeterminate: true});
            }
          }
        }
      }
    }.bind(this));
    return true;
  },
  _isChildrenCheck: function ($el) {
    if ($el.attr('id') === 'collapseFilterByStream') {
      return;
    }
    var allChecked = true;
    var allUncheck = true;
    var children  = $($el).find('input[type="checkbox"]');
    for (var i = 0; i < children.length; i++) {
      allChecked = allChecked && $(children[i]).prop('checked');
      allUncheck = allUncheck && !$(children[i]).prop('checked');
    }
    if (allUncheck) {
      $('li[data-target=#' + $el.attr('id') + ']', this.$el).find('input[type="checkbox"]').prop({
        indeterminate: false,
        checked: false
      });
    } else if (!allChecked && !allUncheck) {
      $('li[data-target=#' + $el.attr('id') + ']', this.$el).find('input[type="checkbox"]').prop({
        indeterminate: true,
        checked: false
      });
    }
    this._isChildrenCheck($($($el).parent().parent()));
  },
  _applyFilter: function () {
    var streams = [], $parent, connection, stream;
    this.ui.applyBtn.prop('disabled', true);
    _.each(this.ui.checkbox, function (checkbox) {
      checkbox = $(checkbox);
      if (checkbox.prop('checked')) {
        $parent = $(checkbox.parent().parent());
        if ($parent && $parent.attr('data-connection') && $parent.attr('data-stream')) {
          connection = this.MainModel.connections.get($parent.attr('data-connection'));
          if (connection) {
            stream = connection.datastore.getStreamById($parent.attr('data-stream'));
            if (stream) {
              streams.push(stream);
            }
          }
        }
      }
    }.bind(this));
    this.MainModel.activeFilter.focusOnStreams(streams);
  },
  _getStream: function () {
    var connections = [],
      result = '';
    if (!this.MainModel.loggedConnection) {
      return result;
    }
    if (this.MainModel.loggedConnection.datastore && this.MainModel.loggedConnection._accessInfo) {
      connections.push(this.MainModel.loggedConnection);
    }
    _.each(this.MainModel.sharingsConnections, function (c) {
      if (c._accessInfo) {
        connections.push(c);
      }
    });
    _.each(this.MainModel.bookmakrsConnections, function (c) {
      if (c._accessInfo) {
        connections.push(c);
      }
    });
    _.each(connections, function (c) {
      result += '<li class="stream-tree-summary connection disclosure"' +
        ' data-toggle="collapse" ' +
        'data-target="#collapse' + UNIQUE_ID + '">' +
        '<div class="pryv-checkbox">' +
        '<input type="checkbox" name="filterStream" id="filterStream' + UNIQUE_ID +
        '"><label for="afilterStream' + UNIQUE_ID + '">' +   c.username;
      if (c._accessInfo.name !== 'pryv-browser') {
        result += ' / ' + c._accessInfo.name;
      }
      result += '</label></div></li>';
      result += '<ul id="collapse' + UNIQUE_ID +
        '" class="panel-collapse  collapse in stream-tree-children">' +
        '<div class="panel-body">';
      UNIQUE_ID++;
      result += this._getStreamStructure(c);
      result += '</div></ul>';
    }.bind(this));

    return result;
  },
  _getStreamStructure: function (connection) {
    var rootStreams = connection.datastore.getStreams(),
      result = '';
    for (var i = 0; i < rootStreams.length; i++) {
      if (!rootStreams[i].virtual) {
        result += this._walkStreamStructure(rootStreams[i]);
      }
    }
    return result;
  },
  _walkStreamStructure: function (stream) {
    var disclosure = '';
    if (stream.children.length > 0) {
      disclosure = 'disclosure';
    }
    var result = '<li data-connection="' +
      stream.connection.serialId + '" data-stream="' +
      stream.id + '" class="stream-tree-summary collapsed ' + disclosure +
      '" data-toggle="collapse" ' +
      'data-target="#collapse' + UNIQUE_ID + '">' +
      '<div class="pryv-checkbox">' +
      '<input type="checkbox" name="filterStream" id="filterStream' + UNIQUE_ID +
      '"><label for="afilterStream' + UNIQUE_ID + '">' +
      stream.name + '</label><i class="fa fa-cog fa-fw streamConfig" ' +
      'title="Edit stream"></i></div></li>';
    result += '<ul id="collapse' + UNIQUE_ID +
      '" class="panel-collapse  collapse stream-tree-children">' +
      '<div class="panel-body">';
    UNIQUE_ID++;
    for (var j = 0; j < stream.children.length; j++) {
      if (!stream.children[j].virtual) {
        result += this._walkStreamStructure(stream.children[j]);
      }

    }
    result += '</div></ul>';
    return result;
  }

});



},{"backbone.marionette":3,"underscore":104}],188:[function(require,module,exports){
/* global $ */
var  Marionette = require('backbone.marionette');
/* TODO This a the view for each node, with dynamic animation
 we can't re-render on change because animation would no be done
 If the model is a event Node we must include a new typed view
 */
module.exports = Marionette.ItemView.extend({
  template: '#onboardingView',
  container: '#onboarding',
  className: 'onboarding',
  connection: null,
  onRender: function () {
    $(this.container).html(this.$el);
    $('#onboarding-add').click(function () {
      this.trigger('clickAdd');
    }.bind(this));
    $('#onboarding-connect').click(function () {
      this.trigger('clickConnect');
    }.bind(this));
    $('#onboarding-skip').click(function () {
      this.trigger('clickSkip');
    }.bind(this));
    $('.carousel').carousel({
      interval: false,
      wrap: false
    });
    $('#onboarding').removeClass('hidden');
    $('body').i18n();
  }
});
},{"backbone.marionette":3}],189:[function(require,module,exports){
/* global window, i18n, $, localStorage, location*/
var Marionette = require('backbone.marionette');
var Backbone = require('backbone');
var _ = require('underscore');

var GridRow = Marionette.ItemView.extend({
  template: '#other-apps-item-settings-template',
  tagName: 'div',
  className: 'col-sm-6 col-md-4'
});



var App = Backbone.Model.extend({});

var AppList = Backbone.Collection.extend({
  model: App
});

var allList = new AppList([]);


// The grid view
module.exports = Marionette.CompositeView.extend({
  tagName: 'div',
  template: '#other-apps-list-settings-template',
  itemView: GridRow,
  connection: null,
  myAppsId: null,
  apps: null,
  initialize: function () {
    this.myAppsId = [];
    this.apps = [];
    var sync = false;
    this.collection =  this.options.collection || allList;
    this.listenTo(allList, 'change', this.debounceRender);
    this.connection = this.options.connection;
    if (this.connection) {
      this.connection.accesses.get(function (error, result) {
        if (error) {
          window.PryvBrowser.showAlert('.modal-content',
            i18n.t('error.manageApps.' + error.id));
        } else {
          result.forEach(function (access) {
            if (access.type === 'app') {
              this.myAppsId.push(access.name);
            }
          }.bind(this));
          if (sync) {
            this.showAppList();
          } else {
            sync = true;
          }
        }
      }.bind(this));
     // var baseHref = $('base').attr('href');
      var domain = localStorage.getItem('domain') || 'pryv.me';
      var url = 'https://reg.' + domain + '/apps';

      $.get(url)
        .done(function (result) {
          result = result.apps || [];
          result.forEach(function (app) {
            this.apps.push(app);
          }.bind(this));
          if (sync) {
            this.showAppList();
          } else {
            sync = true;
          }
        }.bind(this))
        .fail(function () {
          window.PryvBrowser.showAlert('.modal-content',
            i18n.t('error.manageApps.cannot-load-app-list'));
        });

    }
  },
  showAppList: function () {
    this.apps.forEach(function (app) {
      if (this.myAppsId.indexOf(app.id) === -1) {
        if (app.appURL && app.appURL.length > 0 && app.trustedConnection) {
          app.appURL += '?username=' + this.connection.username + '&auth=' + this.connection.auth +
            '&domain=' + this.connection.settings.domain + '&returnUrl=' + location.href;
        }
        var m = new App({
          app: app
        });
        allList.add(m);
      }
    }.bind(this));
    this.debounceRender();
  },
  appendHtml: function (collectionView, itemView) {
    collectionView.$('#appList .panel-body').append(itemView.el);
  },
  onRender: function () {
    $('body').i18n();
  },
  reset: function () {
    this.collection.reset();
    allList.reset();
  },
  debounceRender: _.debounce(function () {
    this.render();
  }, 10)
});


},{"backbone":5,"backbone.marionette":3,"underscore":104}],190:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
  NavView = require('./NavView.js'),
  ManageAccountView = require('./ManageAccountView.js'),
  ManageAppsView = require('./ManageAppsView.js'),
  AppListView = require('./AppListView.js'),
  _ = require('underscore');

var Layout = Marionette.Layout.extend({
  template: '#settings-modal-template',

  regions: {
    nav: '#settings-nav',
    manageAccount: '#settings-manage-account',
    manageApps: '#settings-manage-apps',
    otherApps: '#settings-other-apps'
  },
  initialize: function () {
    this.$el =  $('.modal-content');
  }
});
var Controller = module.exports  = function ($modal, connection, target) {
  this.connection = connection;
  this.$modal = $modal;
  this.target = target;
  this.view  = null;
  this.nav = null;
  this.manageAccount = null;
  this.manageApps = null;
  this.appList = null;
  this.currentRegion = '';


};
_.extend(Controller.prototype, {
  show: function (region) {
    region = region || 'manageApps';
    this.$modal.modal({currentTarget: this.target});
    setTimeout(function () {
      $('.modal-content').fadeIn();
    }.bind(this), 500);
    this.view = new Layout();
    this.view.on('close', this.close.bind(this));
    this.nav = new NavView();
    this.manageAccount = new ManageAccountView({connection: this.connection});
    this.manageApps = new ManageAppsView({connection: this.connection});
    this.appList = new AppListView({connection: this.connection});
    this.view.render();
    this.view.nav.show(this.nav);
    this._showRegion(region);
    this.nav.activeRegion(region);
    this.nav.on('showRegion', this._showRegion.bind(this));
  },
  close: function () {
    if (this.view) {
      this.view = null;
      $('.modal-content').empty();
      $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
      $('.modal-backdrop').remove();
      this.$modal.trigger('hidden.bs.modal');
      this.manageApps.reset();
      this.appList.reset();
    }
  },
  _showRegion: function (region) {
    if (region && this.view && region !== this.currentRegion) {
      this.manageAccount.close();
      this.manageApps.close();
      this.appList.close();
      switch (region) {
        case 'manageAccount':
          this.view.manageAccount.show(this.manageAccount);
          break;
        case 'manageApps':
          this.view.manageApps.show(this.manageApps);
          this.view.otherApps.show(this.appList);
          break;
        default:
          break;
      }
      this.currentRegion = region;
      $('body').i18n();
    }
  }
});

},{"./AppListView.js":189,"./ManageAccountView.js":191,"./ManageAppsView.js":192,"./NavView.js":193,"backbone.marionette":3,"underscore":104}],191:[function(require,module,exports){
/* global window, i18n */
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({
  template: '#account-settings-modal-template',
  ui: {
    passwordForm: '#passwordForm',
    currentPass: '#currentPassword',
    newPass: '#newPassword',
    rePass: '#reNewPassword',
    emailForm: '#emailForm',
    newEmail: '#newEmail',
    save: 'button[type=submit]',
    spinner: '.fa-spinner'
  },
  onRender: function () {
    this.bindUIElements();
    this.ui.spinner.hide();
    this.ui.passwordForm.submit(this._onPasswordSubmit.bind(this));
    this.ui.emailForm.submit(this._onEmailSubmit.bind(this));
  },
  _onEmailSubmit: function (e) {
    e.preventDefault();

    this.ui.newEmail.parent().parent().removeClass('has-error');

    var newEmail = this.ui.newEmail.val();

    if (newEmail && newEmail.length > 0) {
      this.ui.spinner.show();
      this.ui.save.prop('disabled', true);
      
      this.options.connection.request({
        method: 'PUT',
        path: '/account',
        jsonData: {
          email: newEmail
        },
        callback: function (err) {
          this.ui.spinner.hide();
          this.ui.save.prop('disabled', false);
          if (err) {
            this.ui.save.addClass('btn-pryv-alizarin');
            var errMsg = i18n.t('settings.account.messages.errEmail');
            if (err.message) {
              errMsg += ' ' + err.message;
            }
            window.PryvBrowser.showAlert('.modal-content', errMsg);
          } else {
            this.ui.save.removeClass('btn-pryv-alizarin');
            this.ui.newEmail.val('');
            window.PryvBrowser.showSuccess('.modal-content',
              i18n.t('settings.account.messages.emailChanged'));
          }
        }.bind(this)
      });
    }
  },
  _onPasswordSubmit: function (e) {
    e.preventDefault();

    this.ui.currentPass.parent().parent().removeClass('has-error');
    this.ui.newPass.parent().parent().removeClass('has-error');
    this.ui.rePass.parent().parent().removeClass('has-error');

    var newPass = this.ui.newPass.val();
    var reNewPass = this.ui.rePass.val();
    var currentPass = this.ui.currentPass.val();

    if (newPass && newPass.length > 0 && newPass === reNewPass) {
      this.ui.spinner.show();
      this.ui.save.prop('disabled', true);
      this.options.connection.account.changePassword(currentPass, newPass, function (err) {
        this.ui.spinner.hide();
        this.ui.save.prop('disabled', false);
        if (err) {
          var errMsg;
          switch (err.id) {
          case 'invalid-operation':
            errMsg = i18n.t('settings.account.messages.errCurrentPasswordInvalid');
            this.ui.currentPass.parent().parent().addClass('has-error');
            break;
          case 'invalid-parameters-format':
            errMsg = i18n.t('settings.account.messages.errPasswordRequirements');
            this.ui.newPass.parent().parent().addClass('has-error');
            break;
          default:
            errMsg = i18n.t('common.messages.errUnexpected');
            window.PryvBrowser.reportError(err, {
              component: 'settings.account',
              action: 'change password'
            });
            break;
          }
          this.ui.save.addClass('btn-pryv-alizarin');
          window.PryvBrowser.showAlert('.modal-content', errMsg);
          return;
        }

        this.ui.save.removeClass('btn-pryv-alizarin');
        this.ui.currentPass.val('');
        this.ui.newPass.val('');
        this.ui.rePass.val('');
        window.PryvBrowser.showSuccess('.modal-content',
         i18n.t('settings.account.messages.passwordChanged'));
      }.bind(this));
    } else {
      this.ui.rePass.parent().parent().addClass('has-error');
      window.PryvBrowser.showAlert('.modal-content',
        i18n.t('settings.account.messages.errPasswordsDontMatch'));
    }
  }
});



},{"backbone.marionette":3}],192:[function(require,module,exports){
/* global window, i18n, $, localStorage, location*/
var Marionette = require('backbone.marionette');
var Backbone = require('backbone');
var _ = require('underscore');

var GridRow = Marionette.ItemView.extend({
  template: '#apps-item-settings-template',
  tagName: 'tr',
  events: {
    'click .app-trash': '_onTrashClick'
  },
  _onTrashClick: function () {
    this.trigger('app:delete', this.model);
  }
});



var App = Backbone.Model.extend({});

var AppList = Backbone.Collection.extend({
  model: App
});

var allList = new AppList([]);


// The grid view
module.exports = Marionette.CompositeView.extend({
  tagName: 'div',
  template: '#apps-list-settings-template',
  itemView: GridRow,
  connection: null,

  initialize: function () {
    this.collection =  this.options.collection || allList;
    this.listenTo(allList, 'change', this.debounceRender);
    this.on('itemview:app:delete', this._onDeleteAppClick.bind(this));
    this.connection = this.options.connection;
    if (this.connection) {

      //var baseHref = $('base').attr('href');
      var domain = localStorage.getItem('domain') || 'pryv.me';
      var url = 'https://reg.' + domain + '/apps';

      var apps = {};
      $.get(url)
        .done(function (result) {
          result = result.apps || [];
          result.forEach(function (app) {
            apps[app.id] = app;
          });

          this.connection.accesses.get(function (error, result) {
            if (error) {
              window.PryvBrowser.showAlert('.modal-content',
                i18n.t('error.manageApps.' + error.id));
            } else {
              result.forEach(function (access) {
                if (access.type === 'app') {
                  access.displayName = access.name;
                  if (apps[access.name]) {
                    access.displayName = apps[access.name].displayName;
                    access.settingsPageURL = apps[access.name].settingsPageURL;
                    if (apps[access.name].trustedConnection) {
                      access.settingsPageURL +=
                      '?username=' + this.connection.username + '&auth=' + this.connection.auth +
                      '&domain=' + this.connection.settings.domain + '&returnUrl=' + location.href;
                    }

                    access.iconURL = apps[access.name].iconURL;
                  }

                  var m = new App({
                    app: access
                  });
                  allList.add(m);
                }
              }.bind(this));
              this.debounceRender();
            }
          }.bind(this));

        }.bind(this))
        .fail(function () {
          window.PryvBrowser.showAlert('.modal-content',
            i18n.t('error.manageApps.cannot-load-app-list'));
        });




    }
  },
  appendHtml: function (collectionView, itemView) {
    collectionView.$('tbody').append(itemView.el);
  },
  _onDeleteAppClick: function (e, model) {
    this.connection.accesses.delete(model.get('app').id,
      function (err) {
        if (err) {
          // TODO: check actual error and handle it properly
          window.PryvBrowser.reportError(err, {
            component: 'connected apps',
            action: 'delete app access'
          });
          window.PryvBrowser.showAlert('.modal-content', i18n.t('common.messages.errUnexpected'));
          return;
        }
        allList.remove(model);
        this.debounceRender();
      }.bind(this));
  },
  onRender: function () {
    $('body').i18n();
  },
  reset: function () {
    this.collection.reset();
    allList.reset();
  },
  debounceRender: _.debounce(function () {
    this.render();
  }, 10)
});


},{"backbone":5,"backbone.marionette":3,"underscore":104}],193:[function(require,module,exports){
/*global $ */
var Marionette = require('backbone.marionette'),
  _ = require('underscore');

module.exports = Marionette.ItemView.extend({
  template: '#nav-settings-modal-template',
  ui: {
    a: 'a'
  },
  onRender: function () {
    this.ui.a.click(function (e) {
      this._removeActive();
      e.currentTarget.classList.add('active');
      this.trigger('showRegion', e.currentTarget.getAttribute('data-name'));
    }.bind(this));
    setTimeout(function () {$('body').i18n(); }, 100);
  },
  _removeActive: function () {
    _.each(this.ui.a, function (a) {
      a.classList.remove('active');
    });
  },
  activeRegion: function (regionName) {
    for (var i = 0 ; i < this.ui.a.length; i++) {
      if (this.ui.a[i].getAttribute('data-name') === regionName) {
        this._removeActive();
        this.ui.a[i].classList.add('active');
        break;
      }
    }
  }

});



},{"backbone.marionette":3,"underscore":104}],194:[function(require,module,exports){
var Backbone = require('backbone'),
  Model = require('./BookmarkModel.js');

module.exports = Backbone.Collection.extend({
  url: '#',
  model: Model
});
},{"./BookmarkModel.js":197,"backbone":5}],195:[function(require,module,exports){
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({

  tagName: 'tr',
  template: '#template-bookmarkItemView',
  events: {
    'click .bookmark-trash': '_onTrashClick'
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);

  },
  onRender: function () {
  },
  _onTrashClick: function () {
    this.trigger('bookmark:delete', this.model);
  }
});
},{"backbone.marionette":3}],196:[function(require,module,exports){
/* global $, window, i18n */
var Marionette = require('backbone.marionette'),
  ItemView = require('./BookmarkItemView.js'),
  Pryv = require('pryv'),
  _ = require('underscore');

module.exports = Marionette.CompositeView.extend({
  template: '#template-bookmarkListCompositeView',
  container: '.sharings',
  itemView: ItemView,
  itemViewContainer: '#bookmark-list',
  $url: null,
  $auth: null,
  $name: null,
  $tick: null,
  $form: null,
  _findAuthFromUrl: function () {

    var url = this.$url.val(),
        urlInfo = Pryv.utility.urls.parseClientURL(url),
        params = urlInfo.parseQuery(),
        sharingTokens = urlInfo.parseSharingTokens();
    if (params && params.auth) {
      this.$auth.val(params.auth);
    } else if (sharingTokens && sharingTokens.length > 0) {
      this.$auth.val(sharingTokens.join(','));
    }

  },
  initialize: function () {
    this.listenTo(this.collection, 'change', this.debounceRender);
    //this.listenTo(this.collection, 'change', this.bindClick);
    $(this.container).append('<h5 data-i18n="slices.labels.followedSlices"></h5>' +

      '<table class="table" >' +
      '<thead><tr><th data-i18n="slices.labels.name"></th>' +
      '<th data-i18n="slices.labels.link"></th><th></th></tr></thead>' +
      '<tbody id="bookmark-list"></tbody>' +
      '</table>' +
      '<button class="btn btn-default btn-sm" id="add-slice">' +
      ' <i class="fa fa-plus"></i> ' +
      '<span data-i18n="slices.actions.addNewFollowedSlice"></span></button>' +
      '<form class="form-inline" id="add-bookmark" role="form">' +
      '<div class="form-group">' +
      ' <label class="sr-only" for="add-bookmark-url">url</label>' +
      ' <input type="url" class="form-control" id="add-bookmark-url" ' +
      'data-i18n="[placeholder]slices.labels.linkPlaceholder" required>' +
      '</div> ' +
      '<div class="form-group">' +
        '<label class="sr-only" for="add-bookmark-name">Name</label>' +
        '<input type="text" class="form-control" id="add-bookmark-name" ' +
      'data-i18n="[placeholder]slices.labels.namePlaceholder" required>' +
      '</div>' +
      '<div class="form-group">' +
        ' <label class="sr-only" for="add-bookmark-auth">token</label>' +
        ' <input type="text" class="form-control" id="add-bookmark-auth" placeholder="Token(s)">' +
      '</div> ' +
      ' <button type="submit" id ="add-bookmark-btn" class="btn btn-default">' +
      '<span data-i18n="common.actions.add"></span> ' +
      '<i class="fa fa-spinner fa-spin"></i></button>  ' +
      '' +
      ' </form>');
    this.$url = $('#add-bookmark-url');
    this.$auth = $('#add-bookmark-auth');
    this.$name = $('#add-bookmark-name');
    this.$btn = $('#add-bookmark-btn');
    this.$form = $('#add-bookmark');
    this.$spin = $('#add-bookmark-btn .fa-spin');
    this.$spin.hide();
    this.$form.toggle();
    this.$addSlice = $('#add-slice');
    this.$addSlice.click(function () {
      this.$form.toggle();
      this.$addSlice.toggle();
    }.bind(this));
    this.$form.bind('change paste keyup', function () {
      this.$btn.removeClass('btn-danger btn-success').addClass('btn-default');
    }.bind(this));
    this.$url.bind('change paste keyup', this._findAuthFromUrl.bind(this));
    this.$form.submit(function (e) {
      e.preventDefault();
      var auths = this.$auth.val().split(','),
        url = this.$url.val(),
        name = this.$name.val(),
        sameNameExtension = '',
        i = 0;
      this.$spin.show();
      this.$btn.removeClass('btn-pryv-alizarin');
      auths.forEach(function (auth) {
        this.trigger('bookmark:add', url, auth, name + sameNameExtension);
        i += 1;
        sameNameExtension = '-' + i;
      }.bind(this));
    }.bind(this));
  },
  endAddBookmark: function (error) {
    this.$spin.hide();
    if (error) {
      var errorId;
      console.log(error.id);
      switch (error.id) {
        case 'slice-unknown':
        case 'API_UNREACHEABLE':
          errorId = 'slice-unknown';
          break;
        case 'item-already-exists':
          errorId = 'slice-already-exists';
          break;
        default:
          errorId = 'slice-unknown';
          break;
      }
      window.PryvBrowser.showAlert(this.container, i18n.t('error.followedSlice.add.' + errorId));
      this.$btn.removeClass('btn-success').addClass('btn-pryv-alizarin');
    } else {
      this.$btn.removeClass('btn-pryv-alizarin').addClass('btn-success');
    }
  },
  appendHtml: function (collectionView, itemView) {
    $(this.itemViewContainer).append(itemView.el);
  },
  onRender: function () {
    $('body').i18n();
  },
  onBeforeClose: function () {
    $(this.container).empty();
    return true;
  },
  debounceRender: _.debounce(function () {
    this.render();
  }, 10)
});

},{"./BookmarkItemView.js":195,"backbone.marionette":3,"pryv":50,"underscore":104}],197:[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  defaults: {
    bookmark: null,
    collection: null
  }
});
},{"backbone":5}],198:[function(require,module,exports){
/* global $, window, i18n */
var _ = require('underscore'),
  SharingCollection = require('./SharingCollection.js'),
  SharingModel = require('./SharingModel.js'),
  SharingListView = require('./SharingListView.js'),
  BookmarkCollection = require('./BookmarkCollection.js'),
  BookmarkModel = require('./BookmarkModel.js'),
  BookmarkListView = require('./BookmarkListView.js'),
  Pryv = require('pryv');
var Controller = module.exports = function ($modal, connection, target) {
  this.sharings = {};
  this.connection = connection;
  this.sharingCollection =  new SharingCollection();
  this.sharingListView = null;
  this.bookmarkCollection =  new BookmarkCollection();
  this.bookmarkListView = null;
  this.$modal = $modal;
  this.target = target;
  $('.modal-content').empty();
  $('.modal-content').prepend('<div class="modal-header">  ' +
    '<button type="button" class="close" data-dismiss="modal" aria-hidden="true">' +
    '&times;</button> ' +
    '<h4 class="modal-title" id="myModalLabel" data-i18n="slices.labels.manageTitle"></h4>' +
    '<div class="modal-close"></div> ' +
    '</div><div id="modal-content"><div id="creation-content">' +
    '<div class="sharings container"></div></div>' +
    '<div id="creation-footer" class="col-md-12">' +
    '<button id="ok" class="btn btn-primary" ' +
    'data-dismiss="modal" data-i18n="common.actions.close"></button>' +
    '</div></div>');
  $('body').i18n();
  this.container = '.sharings';

};

_.extend(Controller.prototype, {
  show: function () {
    this.$modal.modal({currentTarget: this.target});
    $('.modal-content').hide();
    setTimeout(function () {
      $('.modal-content').fadeIn();
    }.bind(this), 500);
    if (!this.sharingListView) {
      this.sharingListView = new SharingListView({
        collection: this.sharingCollection
      });
    }
    if (!this.bookmarkListView) {
      this.bookmarkListView = new BookmarkListView({
        collection: this.bookmarkCollection
      });
      this.bookmarkListView.on('bookmark:add', this._createBookmark.bind(this));
      this.bookmarkListView.on('itemview:bookmark:delete', this._onDeleteBookmarkClick.bind(this));
      this.sharingListView.on('itemview:sharing:delete', this._onDeleteSharingClick.bind(this));
      this.sharingListView.on('itemview:sharing:update', this._onUpdateSharingClick.bind(this));
    }
    this.sharingListView.render();
    this.bookmarkListView.render();
    this.connection.accesses.get(function (error, result) {
      if (error) {
        console.error('GET ACCESSES:', error);
      } else {
        this.addSharings(result, this.connection);
      }
    }.bind(this));
    this.connection.bookmarks.get(function (error, result) {
      if (error) {
        console.error('GET ACCESSES:', error);
      } else {
        this.addBookmarks(result);
      }
    }.bind(this));
  },
  close: function () {
    this.sharingListView.close();
    this.sharingCollection.reset();
    $(this.container).remove();
    $('.modal-content').empty();
    this.sharingCollection = null;
    this.sharings = {};
  },
  addSharings: function (sharings, connection) {
    if (!Array.isArray(sharings)) {
      sharings = [sharings];
    }
    sharings.forEach(function (sharing) {
      if (sharing.type === 'shared') {
        var url = connection.id.replace(/\?auth.*$/, '');
        url += '#/sharings/' + sharing.token;
        sharing.url = url;
        var m = new SharingModel({
          sharing: sharing
        });
        this.sharingCollection.add(m);
      }
    }.bind(this));
  },
  addBookmarks: function (bookmarks) {
    console.log('addBookmarks', bookmarks);
    if (!Array.isArray(bookmarks)) {
      bookmarks = [bookmarks];
    }
    bookmarks.forEach(function (bookmark) {
      var url = bookmark.settings.url;
      bookmark.settings.url = url;
      var m = new BookmarkModel({
        bookmark: bookmark
      });
      this.bookmarkCollection.add(m);
    }.bind(this));
  },
  _createBookmark: function (url, auth, name) {
    if (url && auth && name) {
      var conn = new Pryv.Connection({
        url: url,
        auth: auth,
      });
      conn.accessInfo(function (error) {
        if (!error) {
          this.connection.bookmarks.create({url: url, accessToken: auth, name: name},
          function (error, result) {
            if (!error && result) {
              this.addBookmarks(result);
            }
            if (error) {
              console.error('Bookmarks creation error:', error);
            }
            this.bookmarkListView.endAddBookmark(error);
          }.bind(this));
        } else {
          this.bookmarkListView.endAddBookmark(error);
          console.warn('Bookmark dont exist', url, auth);
        }
      }.bind(this));
    }
    else {
      this.bookmarkListView.endAddBookmark({id: 'slice-unknown'});
    }
  },
  _onDeleteBookmarkClick: function (e, bookmarkModel) {
    this.connection.bookmarks.delete(bookmarkModel.get('bookmark').settings.bookmarkId,
    function (error) {
      if (!error) {
        this.bookmarkCollection.remove(bookmarkModel);
      } else { window.PryvBrowser.showAlert(this.container,
        i18n.t('error.followedSlice.delete.' + error.id));
        console.warn(error);
      }
    }.bind(this));
  },
  _onDeleteSharingClick: function (e, sharingModel) {
    this.connection.accesses.delete(sharingModel.get('sharing').id,
    function (err) {
      if (err) {
        // TODO: check actual error and handle it properly
        window.PryvBrowser.reportError(err, {
          component: 'slices management',
          action: 'delete shared access'
        });
        window.PryvBrowser.showAlert(this.container, i18n.t('common.messages.errUnexpected'));
        return;
      }
      this.sharingCollection.remove(sharingModel);
    }.bind(this));
  },
  _onUpdateSharingClick: function (e, view) {
    this.connection.accesses.update(view.model.get('sharing'), view.endUpdateSharing.bind(view));
  }
});

},{"./BookmarkCollection.js":194,"./BookmarkListView.js":196,"./BookmarkModel.js":197,"./SharingCollection.js":199,"./SharingListView.js":201,"./SharingModel.js":202,"pryv":50,"underscore":104}],199:[function(require,module,exports){
var Backbone = require('backbone'),
  Model = require('./SharingModel.js');

module.exports = Backbone.Collection.extend({
  url: '#',
  model: Model
});
},{"./SharingModel.js":202,"backbone":5}],200:[function(require,module,exports){
/* global window, i18n */
var Marionette = require('backbone.marionette');


module.exports = Marionette.ItemView.extend({

  tagName: 'tr',
  template: '#template-sharingItemView',
  ui: {
    editName: '.sharing-edit-name',
    editNameInput: '.sharing-name .input-group input',
    editNameSpan: '.sharing-name .input-group span',
    editNameButton: '.sharing-name .input-group button',
    editNameSpinner: '.sharing-name .fa-spin'
  },
  events: {
    'click .sharing-trash': '_onTrashClick',
    'click i.sharing-edit-name': '_onEditNameClick'
  },

  initialize: function () {
    this.listenTo(this.model, 'change', this.render);

  },
  onRender: function () {
    this.ui.editNameInput.hide();
    this.ui.editNameSpan.hide();
    this.ui.editNameSpinner.hide();
    this.ui.editNameButton.click(this._onSaveClick.bind(this));
  },
  _onTrashClick: function () {
    this.trigger('sharing:delete', this.model);
  },
  _onEditNameClick: function () {
    this.ui.editName.hide();
    this.ui.editNameSpinner.hide();
    this.ui.editNameButton.removeClass('btn-danger').addClass('btn-default');
    this.ui.editNameInput.show();
    this.ui.editNameSpan.show();
  },
  _onSaveClick: function () {
    var val = this.ui.editNameInput.val().trim();
    if (val.length > 0) {
      this.model.get('sharing').oldName = this.model.get('sharing').name;
      this.model.get('sharing').name = val;
      this.ui.editNameSpinner.show();
      this.trigger('sharing:update', this);
    }
  },
  endUpdateSharing: function (err) {
    this.ui.editNameSpinner.hide();
    if (err) {
      this.ui.editNameButton.removeClass('btn-default').addClass('btn-danger');
      this.model.get('sharing').name = this.model.get('sharing').oldName;
      // TODO proper error handling
      window.PryvBrowser.showAlert('.modal-content',
          i18n.t('slices.messages.errSliceNameAlreadyExists'));
      return;
    }
    this.ui.editNameInput.hide();
    this.ui.editNameSpan.hide();
    this.ui.editName.show();
    this.render();
  }
});

},{"backbone.marionette":3}],201:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
  ItemView = require('./SharingItemView.js'),
  _ = require('underscore');

module.exports = Marionette.CompositeView.extend({
  template: '#template-sharingListCompositeView',
  container: '.sharings',
  itemView: ItemView,
  itemViewContainer: '#sharing-list',

  initialize: function () {
    this.listenTo(this.collection, 'add remove', this.debounceRender);
    //this.listenTo(this.collection, 'change', this.bindClick);
    $(this.container).append('<h5 data-i18n="slices.labels.sharedSlices"></h5>' +
    '<table class="table" >' +
      '<thead><tr><th data-i18n="slices.labels.name">Name</th>' +
      '<th data-i18n="slices.labels.link">Link</th>' +
      '<th data-i18n="slices.labels.share">Share</th><th></th></tr></thead>' +
      '<tbody id="sharing-list"></tbody>' +
    '</table>');
  },
  appendHtml: function (collectionView, itemView) {
    $(this.itemViewContainer).append(itemView.el);
  },
  onRender: function () {
    $('body').i18n();
  },
  onBeforeClose: function () {
    $(this.container).empty();
    return true;
  },
  debounceRender: _.debounce(function () {
    this.render();
  }, 10)
});

},{"./SharingItemView.js":200,"backbone.marionette":3,"underscore":104}],202:[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  defaults: {
    sharing: null,
    collection: null
  }
});
},{"backbone":5}],203:[function(require,module,exports){
/* global $, i18n, window */
var Marionette = require('backbone.marionette'),
  CreateFormView = require('./CreateFormView.js'),
  SuccessView = require('./SuccessView.js'),
  _ = require('underscore');


var Layout = Marionette.Layout.extend({
  template: '#create-sharings-modal-template',

  regions: {
    createForm: '#create-sharings-form',
    success: '#success-sharings'
  },
  initialize: function () {
    this.$el =  $('.modal-content');
    this.connection = this.options.connection;
  },
  ui: {
    cancel: '#cancel',
    publish: '#publish',
    submit: '#publish',
    checkbox: 'input[type=checkbox]'
  },
  onRender: function () {
    this.bindUIElements();
    this.ui.submit.click(this.createSharing.bind(this));
  },
  createSharing: function (e) {
    e.preventDefault();
    var $btn = this.ui.publish;
    var $name = $('#input-name', this.$el),
      //$token = $('#input-token', this.$el),
      $permission = $('#input-global-permission', this.$el),
      $spin = $('.fa-spin', $btn);
    var access = {}, name = $name.val().trim(),
      //token = $token.val().trim(),
      permission = $permission.val();
    if (name.length === 0) {
      $('#form-create-sharing', this.$el).find(':submit').click();
      return;
    }
    if (permission !== 'read' && permission !== 'manage' && permission !== 'contribute') {
      permission = 'read';
    }
    access.name = name;
   // access.token = token;
    access.permissions = [];
    if ($spin) {
      $spin.show();
    }

    _.each($('#sharing-stream-list input[type=checkbox]'), function (checkbox) {
      var streamId = $($(checkbox).parent().parent()).attr('data-stream');
      if ($(checkbox).prop('checked') && streamId) {
        access.permissions.push({streamId : streamId, level: permission});
      }
    }.bind(this));



    this.connection.accesses.create(access, function (error, result) {
      if ($spin) {
        $spin.hide();
      }

      if (error || result.message) {
        $btn.addClass('btn-pryv-alizarin');
        window.PryvBrowser.showAlert('.modal-content',
          i18n.t('slices.messages.errInvalidSharingToken'));
        return;
      }

      $btn.removeClass('btn-pryv-alizarin');
      this.trigger('sharing:createSuccess', { name: name, token: result.token });
    }.bind(this));
  }
});
var Controller = module.exports = function ($modal, connection, streams, timeFilter, target) {
  this.$modal = $modal;
  this.target = target;
  this.connection = connection;

  this.streams = streams;
  this.timeFrom = timeFilter[1];
  this.timeTo = timeFilter[0];
  this.container = '.modal-content';
  this.view = null;
  this.createForm = null;
  this.success = null;
};
_.extend(Controller.prototype, {
  show: function () {
    this.$modal.modal({currentTarget: this.target});
    setTimeout(function () {
      $('.modal-content').fadeIn();
    }.bind(this), 500);
    this.view = new Layout({connection: this.connection});
    this.view.on('close', this.close.bind(this));
    this.view.on('sharing:createSuccess', this.createSuccess.bind(this));
    this.createForm = new CreateFormView({connection: this.connection, streams: this.streams});
    this.view.render();
    this.view.createForm.show(this.createForm);
    $(this.view.regions.success).hide();
    $('body').i18n();
  },
  close: function () {
    if (this.view) {
      this.view = null;
      $('.modal-content').empty();
      $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
      $('.modal-backdrop').remove();
      this.$modal.trigger('hidden.bs.modal');
    }
  },
  createSuccess: function (params) {
    this.success = new SuccessView({connection: this.connection,
     token: params.token, name: params.name});
    $(this.view.regions.createForm).hide();
    $(this.view.regions.success).show();
    this.createForm.close();
    this.view.success.show(this.success);
    this.view.ui.publish.remove();
    this.view.ui.cancel.text(i18n.t('common.actions.close')).addClass('btn-primary');
  }
});
},{"./CreateFormView.js":204,"./SuccessView.js":205,"backbone.marionette":3,"underscore":104}],204:[function(require,module,exports){
/* global $ */

var Marionette = require('backbone.marionette'),
  _ = require('underscore'),
  UNIQUE_ID = 0;

module.exports = Marionette.ItemView.extend({
  template: '#create-sharings-form-template',
  className: 'create-sharing full-height',
  templateHelpers: function () {
    return {
      getStream: function () {
        return this._getStream();
      }.bind(this)
    };
  },
  ui: {
    label: 'label',
    checkbox: 'input[type=checkbox]'
  },
  initialize: function () {
    this.connection = this.options.connection;
    this.streams = this.options.streams;
  },
  onRender: function () {
    var self = this;
    this.bindUIElements();
    _.each(this.$el.find('input[type=checkbox]'), function (checkbox) {
      $(checkbox).prop({
        indeterminate: false,
        checked: true
      });
    });
    this.ui.label.click(function (e) {
      e.stopPropagation();
      var input = $($(e.currentTarget).parent()).find('input');
      var checked = input.prop('checked');
      input.prop({
        indeterminate: false,
        checked: !checked
      });
      input.trigger('change');
    }.bind(this));
    this.ui.checkbox.click(function (e) {
      e.stopPropagation();
    });
    this.ui.checkbox.change(function (e, options) {
      var checked = $(e.currentTarget).prop('checked'),
        container = $($(e.currentTarget).parent().parent().attr('data-target'), self.$el);
      container.find('input[type="checkbox"]').prop({
        indeterminate: false,
        checked: checked
      });
      if (!options || !options.noIndeterminate) {
        self._isChildrenCheck(container.parent().parent());
      }
    });

    setTimeout(function () {$('body').i18n(); }, 100);
  },
  _isChildrenCheck: function ($el) {
    if (!$el.hasClass('stream-tree-children')) {
      return;
    }
    var allChecked = true;
    var allUncheck = true;
    var children  = $($el).find('input[type="checkbox"]');
    for (var i = 0; i < children.length; i++) {
      allChecked = allChecked && $(children[i]).prop('checked');
      allUncheck = allUncheck && !$(children[i]).prop('checked');
    }
    if (allUncheck) {
      $('li[data-target=#' + $el.attr('id') + ']').find('input[type="checkbox"]').prop({
        indeterminate: false,
        checked: false
      });
    } else if (!allChecked && !allUncheck) {
      $('li[data-target=#' + $el.attr('id') + ']').find('input[type="checkbox"]').prop({
        indeterminate: true,
        checked: false
      });
    }
    this._isChildrenCheck($($($el).parent().parent()));
  },
  _getStream: function () {
    var connections = [this.connection],
      result = '';
    _.each(connections, function (c) {
      result += '<li class="stream-tree-summary connection disclosure"' +
        ' data-toggle="collapse" ' +
        'data-target="#collapse-sharing' + UNIQUE_ID + '">' +
        '<div class="pryv-checkbox">' +
        '<input type="checkbox" name="filterStream" id="filterStream' + UNIQUE_ID +
        '"><label for="afilterStream' + UNIQUE_ID + '">' +   c.username;
      if (c._accessInfo.name !== 'pryv-browser') {
        result += ' / ' + c._accessInfo.name;
      }
      result += '</label></div></li>';
      result += '<ul id="collapse-sharing' + UNIQUE_ID +
        '" class="panel-collapse  collapse in stream-tree-children">' +
        '<div class="panel-body">';
      UNIQUE_ID++;
      result += this._getStreamStructure();
      result += '</div></ul>';
    }.bind(this));

    return result;
  },
  _getStreamStructure: function () {
    var rootStreams = this.streams,
      result = '';
    for (var i = 0; i < rootStreams.length; i++) {
      if (!rootStreams[i].virtual) {
        result += this._walkStreamStructure(rootStreams[i]);
      }
    }
    return result;
  },
  _walkStreamStructure: function (stream) {
    var disclosure = '';
    if (stream.children.length > 0) {
      disclosure = 'disclosure';
    }
    if (stream.name.length === 0) {
      stream.name = '&nbsp;&nbsp;';
    }
    var result = '<li data-stream="' +
      stream.id + '" class="stream-tree-summary collapsed ' + disclosure +
      '" data-toggle="collapse" ' +
      'data-target="#collapse-sharing' + UNIQUE_ID + '">' +
      '<div class="pryv-checkbox">' +
      '<input type="checkbox" name="filterStream" id="filterStream' + UNIQUE_ID +
      '"><label for="afilterStream' + UNIQUE_ID + '">' +
      stream.name + '</label></div></li>';
    result += '<ul id="collapse-sharing' + UNIQUE_ID +
      '" class="panel-collapse  collapse stream-tree-children">' +
      '<div class="panel-body">';
    UNIQUE_ID++;
    for (var j = 0; j < stream.children.length; j++) {
      if (!stream.children[j].virtual) {
        result += this._walkStreamStructure(stream.children[j]);
      }

    }
    result += '</div></ul>';
    return result;
  }

});



},{"backbone.marionette":3,"underscore":104}],205:[function(require,module,exports){
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({
  template: '#success-sharings-template',
  className: 'create-sharing full-height',
  templateHelpers: function () {
    return {
      getUrl: function () {
        var url = this.connection.id.replace(/\?auth.*$/, '');
        url = url.replace(/:443/, '');
        url += '#/sharings/' + this.token;
        return url;
      }.bind(this)
    };
  },
  ui: {
    label: 'label',
    checkbox: 'input[type=checkbox]'
  },
  initialize: function () {
    this.connection = this.options.connection;
    this.name = this.options.name;
    this.token = this.options.token;
  }
});
},{"backbone.marionette":3}],206:[function(require,module,exports){
/* global $, i18n */
var Marionette = require('backbone.marionette'),
  Backbone = require('backbone'),
  StreamView = require('./View.js'),
  _ = require('underscore');

var Model = Backbone.Model.extend({});

var Layout = Marionette.Layout.extend({
  template: '#stream-config-modal-template',

  regions: {
    streamConfig: '#stream-config'
  },
  initialize: function () {
    this.$el =  $('.modal-content');
  }
});
var Controller = module.exports  = function ($modal, stream, target) {
  this.stream = stream;
  this.$modal = $modal;
  this.target = target;
  this.view  = null;
  this.streamConfig  = null;
};


_.extend(Controller.prototype, {
  show: function () {
    this.$modal.modal({currentTarget: this.target});
    setTimeout(function () {
      $('.modal-content').fadeIn();
    }.bind(this), 500);
    this.view = new Layout();
    this.view.on('close', this.close.bind(this));
    this.streamConfig = new StreamView({model: new Model({stream: this.stream})});
    this.view.render();
    this.view.streamConfig.show(this.streamConfig);
    this.streamConfig.on('close', this.close.bind(this));
    this.streamConfig.afterRender();
    this._getModalTitle();
  },
  close: function () {
    if (this.view) {
      this.view = null;
      $('.modal-content').empty();
      $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
      $('.modal-backdrop').remove();
      this.$modal.trigger('hidden.bs.modal');
    }
  },
  _getModalTitle: function () {
    $('#myModalLabel').html(i18n.t('stream.common.labels.title', {
      streamName: this.stream.name
    }));
  }
});
},{"./View.js":207,"backbone":5,"backbone.marionette":3,"underscore":104}],207:[function(require,module,exports){
/* global $, window, i18n*/
var Marionette = require('backbone.marionette'),
    streamUtils = require('../../utility/streamUtils');

// The grid view
module.exports = Marionette.ItemView.extend({
  tagName: 'div',
  template: '#stream-config-template',
  newName: null,
  newColor: null,
  newParent: null,
  ui: {
    form: '#stream-form',
    submitBtn: '#publish',
    submitSpinner: '#publish .fa-spinner',
    deleteBtn: '#delete',
    cancelBtn: '#cancel',
    deleteSpinner: '#delete .fa-spinner',
    colorPicker: '#streamColor',
    name: '#streamName',
    parent: '#streamParent',
    mergeParent: '#mergeParent'
  },
  templateHelpers: function () {
    return {
      getColor: function () {
        return streamUtils.getColor(this.stream);
      }.bind(this),
      getStreamStructure: function () {
        return this.getStreamStructure();
      }.bind(this)
    };
  },
  initialize: function () {
    this.stream = this.model.get('stream');
    this.newName = this.stream.name;
    this.newParent = this.stream.parentId;
    this.newColor = this.stream.clientData || {};
  },
  afterRender: function () {
    $('body').i18n();
    this.ui.submitSpinner.hide();
    this.ui.deleteSpinner.hide();
    this.ui.cancelBtn.click(function () {
      this.trigger('close');
    }.bind(this));
    this.ui.submitBtn.prop('disabled', false);
    var that = this;
    this.ui.name.change(function () {
      this.newName = this.ui.name.val().trim();
      this.ui.submitBtn.prop('disabled', false);
    }.bind(this));
    this.ui.parent.change(function () {
      this.newParent = this.ui.parent.val();
      if (this.newParent === '_null') {
        this.newParent = null;
      }
      this.ui.submitBtn.prop('disabled', false);
    }.bind(this));
    this.ui.deleteBtn.click(function (e) {
      e.preventDefault();
      var mergeParent = false;
      var confirmDeleteMsg = i18n.t('stream.messages.confirmDelete');
      if (this.stream.parentId) {
        mergeParent = !!this.ui.mergeParent.is(':checked');
        if (mergeParent) {
          confirmDeleteMsg = i18n.t('stream.messages.confirmDeleteMerging');
        }
      }

      var confirm = window.confirm(confirmDeleteMsg);
      if (confirm) {
        this.ui.deleteBtn.prop('disabled', true);
        this.ui.deleteSpinner.show();
        this.stream.connection.streams.delete(this.stream.id, function (err) {
          this.ui.deleteSpinner.hide();
          if (err) {
            var errMsg = i18n.t('stream.common.messages.' + err.id) ||
                         i18n.t('common.messages.errUnexpected');
            window.PryvBrowser.showAlert(this.$el, errMsg);
          } else {
            this.stream.connection.streams.delete(this.stream.id, function (err) {
              this.ui.deleteSpinner.hide();
              if (err) {
                var errMsg = i18n.t('stream.common.messages.' + err.id) ||
                  i18n.t('common.messages.errUnexpected');
                window.PryvBrowser.showAlert(this.$el, errMsg);
              } else {
                this.onActionDone();
              }
            }.bind(this), !!mergeParent);
          }
        }.bind(this), !!mergeParent);
      }
    }.bind(this));
    this.ui.colorPicker.colpick({
      colorScheme: 'light',
      layout: 'hex',
      color: streamUtils.getColor(this.stream),
      onSubmit: function (hsb, hex, rgb, el) {
        $(el).css('background-color', '#' + hex);
        $(el).colpickHide();
        this.newColor[streamUtils.BgColorClientDataKey] = '#' + hex;
        that.ui.submitBtn.prop('disabled', false);
      }.bind(this)
    });
    this.ui.form.submit(function (e) {
      e.preventDefault();
      this.ui.submitSpinner.show();
      var update = {
        id: this.stream.id,
        name: this.newName,
        parentId: this.newParent,
        clientData: this.newColor
      };
      this.stream.connection.streams.update(update, function (err) {

        this.ui.submitSpinner.hide();
        this.ui.submitBtn.prop('disabled', true);
        if (err) {
          var errMsg;
          switch (err.id) {
            case 'item-already-exists':
              errMsg = i18n.t('events.common.messages.errStreamNameAlreadyExists');
              break;
            default:
              errMsg = i18n.t('common.messages.errUnexpected');
              window.PryvBrowser.reportError(err, {
                component: 'stream config',
                action: 'stream edit'
              });
              break;
          }

          this.ui.submitBtn.prop('disabled', false);
          this.ui.submitBtn.addClass('btn-pryv-alizarin');
          window.PryvBrowser.showAlert(this.$el, errMsg);
        } else {
          this.onActionDone();
        }
      }.bind(this));
    }.bind(this));
  },
  onActionDone: function () {
    this.trigger('close');
    window.location.reload();
  },

  getStreamStructure: function () {
    var rootStreams = this.stream.connection.datastore.getStreams(),
      parentId = this.stream.parentId,
      result = '';
    var connName = this.stream.connection.username;
    if (this.stream.connection._accessInfo.name !== 'pryv-browser') {
      connName += ' / ' + this.stream.connection._accessInfo.name;
    }
    if (!parentId) {
      result += '<option selected="selected" value="_null">' + connName + '</options>';
    } else {
      result += '<option value="_null">' + connName + '</options>';
    }
    for (var i = 0; i < rootStreams.length; i++) {
      result += this._walkStreamStructure(rootStreams[i], 1, parentId);
    }
    return result;

  },
  _walkStreamStructure: function (stream, depth, parentId) {
    if (stream.id === this.stream.id) {
      return '';
    }
    var indentNbr = 4,
      result = '<option ';
    result += stream.id === parentId ? 'selected="selected" ' : '';
    result += 'value="' + stream.id + '" >';
    for (var i = 0; i < depth * indentNbr; i++) {
      result += '&nbsp;';
    }
    result += stream.name;
    result += '</option>';
    depth++;
    for (var j = 0; j < stream.children.length; j++) {
      result += this._walkStreamStructure(stream.children[j], depth, parentId);
    }
    return result;
  }
});

},{"../../utility/streamUtils":135,"backbone.marionette":3}],208:[function(require,module,exports){
var Backbone = require('backbone'),
  Model = require('./Model.js');

module.exports = Backbone.Collection.extend({
  url: '#',
  model: Model
});
},{"./Model.js":212,"backbone":5}],209:[function(require,module,exports){
/* global $, window, i18n */
var _ = require('underscore'),
  Collection = require('./Collection.js'),
  Model = require('./Model.js'),
  ListView = require('./ListView.js');
var Controller = module.exports = function ($modal, loggedConnection, sharingsConnections, target) {
  this.loggedConnection = loggedConnection;
  this.collection =  new Collection();
  this.listView = null;
  this.$modal = $modal;
  this.target = target;
  this.container = '.modal-content';
  console.log(sharingsConnections);
  this.addSharings(sharingsConnections);
};

_.extend(Controller.prototype, {
  show: function () {
    this.$modal.modal({currentTarget: this.target});
    $(this.container).empty().hide();
    setTimeout(function () {
      $(this.container).fadeIn();
    }.bind(this), 500);
    if (!this.listView) {
      this.listView = new ListView({
        collection: this.collection
      });
      this.listView.on('subscription:add', this._createSubscription.bind(this));
      this.listView.on('close', this.close.bind(this));
    }
    this.listView.render();
  },
  close: function () {
    this.listView.close();
    if (this.collection) {
      this.collection.reset();
      this.collection = null;
    }
    $('#pryv-modal').hide().removeClass('in').attr('aria-hidden', 'true');
    $('.modal-backdrop').remove();
  },
  addSharings: function (sharings) {
    if (!Array.isArray(sharings)) {
      sharings = [sharings];
    }
    sharings.forEach(function (sharing) {
      console.log(sharing);
      sharing.url = sharing.id.replace(/\?auth.*$/, '')
        .replace(/\.in/, '.li')
        .replace(/\.io/, '.me');
      sharing.url += '#/sharings/' + sharing.auth;
      var m = new Model({
        connection: sharing
      });
      this.collection.add(m);
    }.bind(this));
  },
  _createSubscription: function (subscriptions) {
    var subNumber = subscriptions.length;
    var gotError = false;
    subscriptions.forEach(function (model) {
      var connection = model.get('connection');
      if (!connection.name || connection.name.length === 0) {
        connection.name = connection._accessInfo.name;
      }
      if (connection.name && connection.auth && connection.url) {
        this.loggedConnection.bookmarks.create(
          {url: connection.url, accessToken: connection.auth, name: connection.name},
          function (error) {
            if (error) {
              window.PryvBrowser.showAlert(this.container,
                i18n.t('error.subscribeSlice.') + error.id);
              gotError = true;
            }
            model.set('error', error);
            model.set('created', !error);
            subNumber--;
            if (subNumber === 0) {
              this.listView.onCreateSubscriptionFinished(gotError);
            }

          }.bind(this));
      }
    }.bind(this));
  }
});
},{"./Collection.js":208,"./ListView.js":211,"./Model.js":212,"underscore":104}],210:[function(require,module,exports){
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({

  tagName: 'li',
  template: '#template-subscriptionItemView',
  ui: {
    checkbox: '.checkbox input',
    name: '.subscription-name'
  },
  initialize: function () {
    this.listenTo(this.model, 'change', this.render);

  },
  onRender: function () {
    this.ui.checkbox[0].checked = this.model.get('checked');
    this.ui.checkbox.bind('click', function () {
      this.model.set('checked', this.ui.checkbox[0].checked);
    }.bind(this));
    this.ui.name.val(this.model.get('connection').name);
    this.ui.name.bind('change paste keyup', function () {
      this.model.get('connection').name =  this.ui.name.val();
    }.bind(this));
  }
});
},{"backbone.marionette":3}],211:[function(require,module,exports){
/* global $ */
var Marionette = require('backbone.marionette'),
  ItemView = require('./ItemView.js'),
  _ = require('underscore');

module.exports = Marionette.CompositeView.extend({
  template: '#template-subscribeListCompositeView',
  container: '.modal-content',
  itemView: ItemView,
  itemViewContainer: '#subscribe-list',
  $addButton: null,
  $forms: null,
  initialize: function () {
    this.listenTo(this.collection, 'change', this.debounceRender);
    //this.listenTo(this.collection, 'change', this.bindClick);
    $(this.container).append('<div class="modal-header">  ' +
      '<button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>' +
      ' <h4 class="modal-title" id="myModalLabel">Add to my Pryv</h4><div class="modal-close">' +
      '</div></div>' +
      '<div id="modal-content">' +
      '<div id="creation-content"><ul id="subscribe-list"></ul></div>' +
      '<div id="creation-footer" class="col-md-12">' +
      '<button class="btn btn-primary" id="add-subscribe">Add ' +
      '<i class="fa fa-spinner fa-spin"></i></button>' +
      '<button id="cancel" class="btn btn-default" data-dismiss="modal">Cancel</button>' +
      '</div></div>');
    this.$addButton = $('#add-subscribe');
    $('.fa-spin', this.$addButton).hide();
    this.$addButton.bind('click', this._addSubscribe.bind(this));
  },
  _addSubscribe: function () {
    var subscriptions = [];
    $('.fa-spin', this.$addButton).show();
    this.$addButton.attr('disabled', 'disabled');
    this.collection.each(function (model) {
      if (model.get('checked') && !model.get('created')) {
        subscriptions.push(model);
      }
    }.bind(this));
    this.trigger('subscription:add', subscriptions);
  },
  onCreateSubscriptionFinished: function (error) {
    console.log('onCreateSubscriptionFinished');
    $('.fa-spin', this.$addButton).hide();
    this.$addButton.attr('disabled', false);
    if (!error) {
      this.trigger('close');
    }
  },
  appendHtml: function (collectionView, itemView) {
    $(this.itemViewContainer).append(itemView.el);
  },
  onRender: function () {
    this.$forms = $('form.subscribe');
    this.$forms.bind('submit',
      function (e) {
        e.preventDefault();
        this._addSubscribe();
      }.bind(this));
  },
  onBeforeClose: function () {
    $(this.container).empty();
    return true;
  },
  debounceRender: _.debounce(function () {
    this.render();
  }, 10)
});

},{"./ItemView.js":210,"backbone.marionette":3,"underscore":104}],212:[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({
  defaults: {
    connection: null,
    collection: null,
    checked: true,
    error: null,
    created: false
  }
});
},{"backbone":5}],"pryvApp":[function(require,module,exports){
/*global require, window*/
// ---------- helpers that should be  adapted to BackBone fashion ----------- //

var Model = require('./Model.js');


//----- test -------//
/*jshint -W098 */
exports.main = function () {

  var model = new Model();
  window.pryvBrowser = model;
};
},{"./Model.js":112}]},{},["pryvApp"])("pryvApp")
});
